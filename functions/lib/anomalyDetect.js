import * as functions from "firebase-functions";
import * as admin from "firebase-admin";
import OpenAI from "openai";
import fetch from "node-fetch";
/**
 * üö® AI Ïù¥Î≤§Ìä∏ ÌÉêÏßÄ ÏãúÏä§ÌÖú
 * Ïã§ÏãúÍ∞Ñ ÌôúÎèôÎüâ Í∏âÏ¶ù/Í∏âÍ∞ê Í∞êÏßÄ Î∞è ÏûêÎèô ÏïåÎ¶º
 */
// Firebase Admin Ï¥àÍ∏∞Ìôî
admin.initializeApp();
const db = admin.firestore();
/**
 * 30Î∂ÑÎßàÎã§ Ïã§ÌñâÎêòÎäî Ïù¥ÏÉÅ ÌÉêÏßÄ
 */
export const detectAnomalies = functions
    .region("asia-northeast3")
    .pubsub.schedule("*/30 * * * *") // 30Î∂ÑÎßàÎã§ Ïã§Ìñâ
    .timeZone("Asia/Seoul")
    .onRun(async (context) => {
    console.log("üö® Ïù¥ÏÉÅ ÌÉêÏßÄ ÏãúÏûë:", new Date().toISOString());
    try {
        const now = new Date();
        const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
        const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        // 1Ô∏è‚É£ ÏµúÍ∑º 1ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
        const [recentVoiceSnap, recentMarketSnap, recentTeamSnap] = await Promise.all([
            db.collection("voiceSessions")
                .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(oneHourAgo))
                .get(),
            db.collection("marketItems")
                .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(oneHourAgo))
                .get(),
            db.collection("teamRecruitments")
                .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(oneHourAgo))
                .get()
        ]);
        // 2Ô∏è‚É£ ÏßÄÎÇú 7Ïùº ÌèâÍ∑† Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
        const [weekVoiceSnap, weekMarketSnap, weekTeamSnap] = await Promise.all([
            db.collection("voiceSessions")
                .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(sevenDaysAgo))
                .get(),
            db.collection("marketItems")
                .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(sevenDaysAgo))
                .get(),
            db.collection("teamRecruitments")
                .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(sevenDaysAgo))
                .get()
        ]);
        // 3Ô∏è‚É£ Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò
        const recentData = {
            voice: recentVoiceSnap.docs.map(d => d.data()),
            market: recentMarketSnap.docs.map(d => d.data()),
            team: recentTeamSnap.docs.map(d => d.data())
        };
        const weekData = {
            voice: weekVoiceSnap.docs.map(d => d.data()),
            market: weekMarketSnap.docs.map(d => d.data()),
            team: weekTeamSnap.docs.map(d => d.data())
        };
        // 4Ô∏è‚É£ Ïù¥ÏÉÅ ÌÉêÏßÄ Ïã§Ìñâ
        const anomalies = await detectAnomaliesInData(recentData, weekData);
        if (anomalies.length === 0) {
            console.log("‚úÖ Ïù¥ÏÉÅ ÌÉêÏßÄ ÏôÑÎ£å: Ïù¥ÏÉÅ ÏóÜÏùå");
            return;
        }
        // 5Ô∏è‚É£ AI Î∂ÑÏÑù
        const analysis = await generateAIAnalysis(anomalies);
        // 6Ô∏è‚É£ ÏïåÎ¶º Ï†ÑÏÜ°
        await sendAnomalyAlerts(anomalies, analysis);
        // 7Ô∏è‚É£ Î°úÍ∑∏ Ï†ÄÏû•
        await saveAnomalyLog(anomalies, analysis);
        console.log(`‚úÖ Ïù¥ÏÉÅ ÌÉêÏßÄ ÏôÑÎ£å: ${anomalies.length}Í∞ú Ïù¥ÏÉÅ Í∞êÏßÄ`);
    }
    catch (error) {
        console.error("‚ùå Ïù¥ÏÉÅ ÌÉêÏßÄ Ïò§Î•ò:", error);
        await logError("detectAnomalies", error, { context: "main_execution" });
    }
});
/**
 * Îç∞Ïù¥ÌÑ∞ÏóêÏÑú Ïù¥ÏÉÅ ÌÉêÏßÄ
 */
async function detectAnomaliesInData(recentData, weekData) {
    const anomalies = [];
    // Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖÎ≥Ñ Ï≤òÎ¶¨
    const dataTypes = [
        { key: 'voice', label: 'ÏùåÏÑ± ÏÑ∏ÏÖò' },
        { key: 'market', label: 'ÏÉÅÌíà Îì±Î°ù' },
        { key: 'team', label: 'ÌåÄ Î™®Ïßë' }
    ];
    for (const dataType of dataTypes) {
        const recent = recentData[dataType.key];
        const week = weekData[dataType.key];
        // ÏßÄÏó≠Î≥Ñ ÏßëÍ≥Ñ
        const recentAgg = aggregateByLocation(recent);
        const weekAgg = aggregateByLocation(week);
        // Ïù¥ÏÉÅ ÌÉêÏßÄ
        Object.entries(recentAgg).forEach(([location, recentCount]) => {
            const weekAverage = weekAgg[location] ? weekAgg[location] / 7 : 0;
            if (weekAverage > 0) {
                const ratio = recentCount / weekAverage;
                // Í∏âÏ¶ù Í∞êÏßÄ (>150%)
                if (ratio > 1.5) {
                    const [lat, lng] = location.split(',').map(Number);
                    const severity = getSeverity(ratio);
                    anomalies.push({
                        location,
                        type: dataType.label,
                        recentCount: recentCount,
                        weekAverage,
                        ratio,
                        severity,
                        lat,
                        lng
                    });
                }
                // Í∏âÍ∞ê Í∞êÏßÄ (<50%) - ÌäπÎ≥ÑÌïú Í≤ΩÏö∞Îßå
                if (ratio < 0.5 && weekAverage > 5) {
                    const [lat, lng] = location.split(',').map(Number);
                    anomalies.push({
                        location,
                        type: dataType.label,
                        recentCount: recentCount,
                        weekAverage,
                        ratio,
                        severity: 'medium',
                        lat,
                        lng
                    });
                }
            }
        });
    }
    // Ïã¨Í∞ÅÎèÑÎ≥Ñ Ï†ïÎ†¨
    return anomalies.sort((a, b) => {
        const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
        return severityOrder[b.severity] - severityOrder[a.severity];
    });
}
/**
 * ÏúÑÏπòÎ≥Ñ Îç∞Ïù¥ÌÑ∞ ÏßëÍ≥Ñ
 */
function aggregateByLocation(data) {
    const map = {};
    data.forEach(item => {
        var _a, _b, _c, _d;
        let lat, lng;
        // ÏúÑÏπò Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú (Îã§ÏñëÌïú ÌïÑÎìúÎ™Ö ÏßÄÏõê)
        if (((_a = item.geo) === null || _a === void 0 ? void 0 : _a.lat) && ((_b = item.geo) === null || _b === void 0 ? void 0 : _b.lng)) {
            lat = item.geo.lat;
            lng = item.geo.lng;
        }
        else if (((_c = item.location) === null || _c === void 0 ? void 0 : _c.latitude) && ((_d = item.location) === null || _d === void 0 ? void 0 : _d.longitude)) {
            lat = item.location.latitude;
            lng = item.location.longitude;
        }
        if (lat && lng) {
            // 0.01ÎèÑ Îã®ÏúÑÎ°ú Í∑∏Î¶¨ÎìúÌôî (ÏïΩ 1km)
            const gridLat = Math.round(lat * 100) / 100;
            const gridLng = Math.round(lng * 100) / 100;
            const key = `${gridLat},${gridLng}`;
            map[key] = (map[key] || 0) + 1;
        }
    });
    return map;
}
/**
 * Ïã¨Í∞ÅÎèÑ Í≥ÑÏÇ∞
 */
function getSeverity(ratio) {
    if (ratio >= 5.0)
        return 'critical'; // 5Î∞∞ Ïù¥ÏÉÅ
    if (ratio >= 3.0)
        return 'high'; // 3Î∞∞ Ïù¥ÏÉÅ
    if (ratio >= 2.0)
        return 'medium'; // 2Î∞∞ Ïù¥ÏÉÅ
    return 'low'; // 1.5Î∞∞ Ïù¥ÏÉÅ
}
/**
 * AI Î∂ÑÏÑù ÏÉùÏÑ±
 */
async function generateAIAnalysis(anomalies) {
    var _a, _b, _c, _d;
    try {
        const openai = new OpenAI({
            apiKey: ((_a = functions.config().openai) === null || _a === void 0 ? void 0 : _a.key) || process.env.OPENAI_API_KEY
        });
        const prompt = `
Îã§ÏùåÏùÄ ÏïºÍ≥† ÎπÑÏÑúÏùò Ïã§ÏãúÍ∞Ñ Ïù¥ÏÉÅ ÌÉêÏßÄ Í≤∞Í≥ºÏûÖÎãàÎã§:

üö® ÌÉêÏßÄÎêú Ïù¥ÏÉÅ ÌòÑÏÉÅ:
${anomalies.map((a, i) => `
${i + 1}. ${a.type} - ÏúÑÏπò: ${a.location}
   - ÏµúÍ∑º 1ÏãúÍ∞Ñ: ${a.recentCount}Í±¥
   - Ï£ºÍ∞Ñ ÌèâÍ∑†: ${a.weekAverage.toFixed(1)}Í±¥
   - Ï¶ùÍ∞ÄÏú®: ${(a.ratio * 100).toFixed(0)}%
   - Ïã¨Í∞ÅÎèÑ: ${a.severity}
`).join('')}

ÏúÑ Îç∞Ïù¥ÌÑ∞Î•º Î∞îÌÉïÏúºÎ°ú Îã§ÏùåÏùÑ Î∂ÑÏÑùÌï¥Ï£ºÏÑ∏Ïöî:

1. Í∞Å ÏßÄÏó≠Î≥ÑÎ°ú Ïñ¥Îñ§ Ïù¥Î≤§Ìä∏Í∞Ä Î∞úÏÉùÌñàÏùÑ Í∞ÄÎä•ÏÑ±Ïù¥ ÏûàÎäîÏßÄ Ï∂îÎ°†
2. ÏãúÍ∞ÑÎåÄÏôÄ ÌôúÎèô Ìå®ÌÑ¥ÏùÑ Í≥†Î†§Ìïú Îß•ÎùΩÏ†Å Ìï¥ÏÑù
3. Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Ï†úÍ≥µÌï† Ïã§Ìñâ Í∞ÄÎä•Ìïú Ïù∏ÏÇ¨Ïù¥Ìä∏
4. ÎπÑÏ¶àÎãàÏä§ Í¥ÄÏ†êÏóêÏÑúÏùò ÏùòÎØ∏

ÏöîÍµ¨ÏÇ¨Ìï≠:
- ÌïúÍµ≠Ïñ¥Î°ú ÏûëÏÑ±
- 200Ïûê Ïù¥ÎÇ¥Î°ú Í∞ÑÍ≤∞ÌïòÍ≤å
- Íµ¨Ï≤¥Ï†ÅÏù¥Í≥† Ïã§Ìñâ Í∞ÄÎä•Ìïú ÎÇ¥Ïö©
- Ï†ÑÎ¨∏Ï†ÅÏù¥Î©¥ÏÑúÎèÑ Ïù¥Ìï¥ÌïòÍ∏∞ ÏâΩÍ≤å

Î∂ÑÏÑù Í≤∞Í≥º:`;
        const completion = await openai.chat.completions.create({
            model: "gpt-4o-mini",
            messages: [
                {
                    role: "system",
                    content: "ÎãπÏã†ÏùÄ ÏïºÍ≥† ÎπÑÏÑúÏùò Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§. Ïù¥ÏÉÅ ÌÉêÏßÄ Í≤∞Í≥ºÎ•º Î∞îÌÉïÏúºÎ°ú Î™ÖÌôïÌïòÍ≥† Ïã§Ìñâ Í∞ÄÎä•Ìïú Ïù∏ÏÇ¨Ïù¥Ìä∏Î•º Ï†úÍ≥µÌï©ÎãàÎã§."
                },
                { role: "user", content: prompt }
            ],
            temperature: 0.7,
            max_tokens: 300
        });
        return ((_d = (_c = (_b = completion.choices[0]) === null || _b === void 0 ? void 0 : _b.message) === null || _c === void 0 ? void 0 : _c.content) === null || _d === void 0 ? void 0 : _d.trim()) || "AI Î∂ÑÏÑù ÏÉùÏÑ± Ïã§Ìå®";
    }
    catch (error) {
        console.error("AI Î∂ÑÏÑù ÏÉùÏÑ± Ïò§Î•ò:", error);
        return "AI Î∂ÑÏÑù ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.";
    }
}
/**
 * Ïù¥ÏÉÅ ÌÉêÏßÄ ÏïåÎ¶º Ï†ÑÏÜ°
 */
async function sendAnomalyAlerts(anomalies, analysis) {
    var _a, _b;
    try {
        // n8n ÏõπÌõÖ Ï†ÑÏÜ°
        const n8nWebhook = (_a = functions.config().n8n) === null || _a === void 0 ? void 0 : _a.webhook_alert;
        if (n8nWebhook) {
            await fetch(n8nWebhook, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    type: "anomaly_detection",
                    title: "üö® ÏïºÍ≥† ÎπÑÏÑú Ïù¥ÏÉÅ ÌÉêÏßÄ ÏïåÎ¶º",
                    message: analysis,
                    anomalies: anomalies.map(a => ({
                        location: a.location,
                        type: a.type,
                        ratio: a.ratio,
                        severity: a.severity,
                        count: a.recentCount
                    })),
                    timestamp: new Date().toISOString(),
                    criticalCount: anomalies.filter(a => a.severity === 'critical').length,
                    totalCount: anomalies.length
                })
            });
        }
        // Firebase FCMÏúºÎ°ú Í¥ÄÎ¶¨Ïûê ÏïåÎ¶º
        await sendFCMAlert(anomalies, analysis);
        // Slack ÏïåÎ¶º (ÏÑ†ÌÉùÏÇ¨Ìï≠)
        const slackWebhook = (_b = functions.config().slack) === null || _b === void 0 ? void 0 : _b.webhook;
        if (slackWebhook) {
            await sendSlackAlert(anomalies, analysis, slackWebhook);
        }
        console.log("üì§ Ïù¥ÏÉÅ ÌÉêÏßÄ ÏïåÎ¶º Ï†ÑÏÜ° ÏôÑÎ£å");
    }
    catch (error) {
        console.error("ÏïåÎ¶º Ï†ÑÏÜ° Ïò§Î•ò:", error);
        throw error;
    }
}
/**
 * FCM Í¥ÄÎ¶¨Ïûê ÏïåÎ¶º
 */
async function sendFCMAlert(anomalies, analysis) {
    try {
        // Í¥ÄÎ¶¨Ïûê ÌÜ†ÌÅ∞ Î™©Î°ù Ï°∞Ìöå
        const adminTokensSnap = await db.collection("adminTokens").get();
        const adminTokens = adminTokensSnap.docs.map(doc => doc.data().fcmToken).filter(Boolean);
        if (adminTokens.length === 0) {
            console.log("Í¥ÄÎ¶¨Ïûê FCM ÌÜ†ÌÅ∞Ïù¥ ÏóÜÏäµÎãàÎã§.");
            return;
        }
        const criticalCount = anomalies.filter(a => a.severity === 'critical').length;
        const title = criticalCount > 0
            ? `üö® Í∏¥Í∏â: ${criticalCount}Í∞ú ÏßÄÏó≠ Ïù¥ÏÉÅ ÌÉêÏßÄ`
            : `‚ö†Ô∏è ${anomalies.length}Í∞ú ÏßÄÏó≠ Ïù¥ÏÉÅ ÌÉêÏßÄ`;
        const message = {
            notification: {
                title,
                body: analysis.length > 100 ? analysis.substring(0, 100) + "..." : analysis,
            },
            data: {
                type: "anomaly_detection",
                anomalyCount: anomalies.length.toString(),
                criticalCount: criticalCount.toString(),
                analysis: analysis
            },
            tokens: adminTokens
        };
        const response = await admin.messaging().sendMulticast(message);
        console.log(`üì± FCM ÏïåÎ¶º Ï†ÑÏÜ°: ${response.successCount}/${adminTokens.length}`);
    }
    catch (error) {
        console.error("FCM ÏïåÎ¶º Ï†ÑÏÜ° Ïò§Î•ò:", error);
    }
}
/**
 * Slack ÏïåÎ¶º Ï†ÑÏÜ°
 */
async function sendSlackAlert(anomalies, analysis, webhookUrl) {
    try {
        const criticalAnomalies = anomalies.filter(a => a.severity === 'critical');
        const color = criticalAnomalies.length > 0 ? 'danger' : 'warning';
        const blocks = [
            {
                type: "header",
                text: {
                    type: "plain_text",
                    text: "üö® ÏïºÍ≥† ÎπÑÏÑú Ïù¥ÏÉÅ ÌÉêÏßÄ"
                }
            },
            {
                type: "section",
                text: {
                    type: "mrkdwn",
                    text: `*ÌÉêÏßÄ ÏãúÍ∞Ñ:* ${new Date().toLocaleString('ko-KR')}\n*Î∂ÑÏÑù Í≤∞Í≥º:* ${analysis}`
                }
            }
        ];
        if (anomalies.length <= 5) {
            // Ï†ÅÏùÄ ÏàòÏùò Ïù¥ÏÉÅÏùÄ ÏÉÅÏÑ∏ ÌëúÏãú
            anomalies.forEach((anomaly, index) => {
                blocks.push({
                    type: "section",
                    text: {
                        type: "mrkdwn",
                        text: `*${index + 1}. ${anomaly.type}* (${anomaly.location})\n‚Ä¢ ÏµúÍ∑º 1ÏãúÍ∞Ñ: ${anomaly.recentCount}Í±¥\n‚Ä¢ Ï¶ùÍ∞ÄÏú®: ${(anomaly.ratio * 100).toFixed(0)}%\n‚Ä¢ Ïã¨Í∞ÅÎèÑ: ${anomaly.severity}`
                    }
                });
            });
        }
        else {
            // ÎßéÏùÄ ÏàòÏùò Ïù¥ÏÉÅÏùÄ ÏöîÏïΩ ÌëúÏãú
            blocks.push({
                type: "section",
                text: {
                    type: "mrkdwn",
                    text: `*ÌÉêÏßÄÎêú Ïù¥ÏÉÅ ÌòÑÏÉÅ:* ${anomalies.length}Í∞ú\n‚Ä¢ Critical: ${criticalAnomalies.length}Í∞ú\n‚Ä¢ High: ${anomalies.filter(a => a.severity === 'high').length}Í∞ú\n‚Ä¢ Medium: ${anomalies.filter(a => a.severity === 'medium').length}Í∞ú`
                }
            });
        }
        await fetch(webhookUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                attachments: [{
                        color,
                        blocks
                    }]
            })
        });
        console.log("üí¨ Slack ÏïåÎ¶º Ï†ÑÏÜ° ÏôÑÎ£å");
    }
    catch (error) {
        console.error("Slack ÏïåÎ¶º Ï†ÑÏÜ° Ïò§Î•ò:", error);
    }
}
/**
 * Ïù¥ÏÉÅ ÌÉêÏßÄ Î°úÍ∑∏ Ï†ÄÏû•
 */
async function saveAnomalyLog(anomalies, analysis) {
    try {
        await db.collection("anomalyLogs").add({
            detectedAt: admin.firestore.FieldValue.serverTimestamp(),
            anomalies: anomalies.map(a => ({
                location: a.location,
                type: a.type,
                recentCount: a.recentCount,
                weekAverage: a.weekAverage,
                ratio: a.ratio,
                severity: a.severity,
                lat: a.lat,
                lng: a.lng
            })),
            analysis,
            summary: {
                totalAnomalies: anomalies.length,
                criticalCount: anomalies.filter(a => a.severity === 'critical').length,
                highCount: anomalies.filter(a => a.severity === 'high').length,
                mediumCount: anomalies.filter(a => a.severity === 'medium').length,
                lowCount: anomalies.filter(a => a.severity === 'low').length
            }
        });
        console.log("üìù Ïù¥ÏÉÅ ÌÉêÏßÄ Î°úÍ∑∏ Ï†ÄÏû• ÏôÑÎ£å");
    }
    catch (error) {
        console.error("Î°úÍ∑∏ Ï†ÄÏû• Ïò§Î•ò:", error);
        throw error;
    }
}
/**
 * ÏàòÎèô Ïù¥ÏÉÅ ÌÉêÏßÄ (ÌÖåÏä§Ìä∏Ïö©)
 */
export const manualAnomalyDetection = functions
    .region("asia-northeast3")
    .https.onRequest(async (req, res) => {
    if (req.method !== "POST") {
        return res.status(405).send("Method Not Allowed");
    }
    try {
        console.log("üîç ÏàòÎèô Ïù¥ÏÉÅ ÌÉêÏßÄ ÏãúÏûë");
        const now = new Date();
        const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
        const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        // Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (ÏúÑÏôÄ ÎèôÏùºÌïú Î°úÏßÅ)
        const [recentVoiceSnap, recentMarketSnap, recentTeamSnap] = await Promise.all([
            db.collection("voiceSessions")
                .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(oneHourAgo))
                .get(),
            db.collection("marketItems")
                .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(oneHourAgo))
                .get(),
            db.collection("teamRecruitments")
                .where("createdAt", ">=", admin.firestore.Timestamp.fromDate(oneHourAgo))
                .get()
        ]);
        const recentData = {
            voice: recentVoiceSnap.docs.map(d => d.data()),
            market: recentMarketSnap.docs.map(d => d.data()),
            team: recentTeamSnap.docs.map(d => d.data())
        };
        // ÏßÄÎÇú 7Ïùº Îç∞Ïù¥ÌÑ∞ÎèÑ ÏàòÏßë...
        const anomalies = await detectAnomaliesInData(recentData, {}); // Í∞ÑÏÜåÌôî
        const analysis = await generateAIAnalysis(anomalies);
        res.json({
            success: true,
            detectedAt: new Date().toISOString(),
            anomalies,
            analysis,
            summary: {
                totalAnomalies: anomalies.length,
                criticalCount: anomalies.filter(a => a.severity === 'critical').length
            }
        });
    }
    catch (error) {
        console.error("ÏàòÎèô Ïù¥ÏÉÅ ÌÉêÏßÄ Ïò§Î•ò:", error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});
/**
 * ÏóêÎü¨ Î°úÍπÖ (Í∏∞Ï°¥ loggingUtilsÏóêÏÑú import)
 */
async function logError(source, error, meta) {
    try {
        await db.collection("errors").add({
            source,
            message: String((error === null || error === void 0 ? void 0 : error.message) || error),
            stack: (error === null || error === void 0 ? void 0 : error.stack) || null,
            meta: meta !== null && meta !== void 0 ? meta : null,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
    }
    catch (logError) {
        console.error("ÏóêÎü¨ Î°úÍπÖ Ïã§Ìå®:", logError);
    }
}
//# sourceMappingURL=anomalyDetect.js.map