"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SLOMonitoring = void 0;
// SLO Î™®ÎãàÌÑ∞ÎßÅ Î™®Îìà
const admin = __importStar(require("firebase-admin"));
const db = admin.firestore();
class SLOMonitoring {
    // SLO Î©îÌä∏Î¶≠ Í∏∞Î°ù
    static async recordMetric(metric) {
        await db.collection('slo_metrics').add({
            ...metric,
            timestamp: admin.firestore.FieldValue.serverTimestamp()
        });
    }
    // SLO ÌÉÄÍ≤ü ÏÑ§Ï†ï
    static async setSLOTarget(target) {
        await db.collection('slo_targets').doc(target.service).set({
            ...target,
            updatedAt: admin.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
    }
    // SLO ÌÉÄÍ≤ü Ï°∞Ìöå
    static async getSLOTarget(service) {
        const doc = await db.collection('slo_targets').doc(service).get();
        if (!doc.exists)
            return null;
        return doc.data();
    }
    // SLO ÏÉÅÌÉú Í≥ÑÏÇ∞
    static async calculateSLOStatus(service, windowHours = 24) {
        const target = await this.getSLOTarget(service);
        if (!target || !target.enabled)
            return null;
        const windowStart = admin.firestore.Timestamp.fromMillis(Date.now() - (windowHours * 60 * 60 * 1000));
        const metricsSnap = await db.collection('slo_metrics')
            .where('service', '==', service)
            .where('timestamp', '>=', windowStart)
            .orderBy('timestamp', 'desc')
            .get();
        if (metricsSnap.empty) {
            return {
                service,
                window: windowHours,
                currentLatencyP99: 0,
                currentErrorRate: 0,
                currentAvailability: 0,
                targetLatencyP99: target.latencyP99,
                targetErrorRate: target.errorRate,
                targetAvailability: target.availability,
                latencySLO: false,
                errorRateSLO: false,
                availabilitySLO: false,
                overallSLO: false,
                lastUpdated: admin.firestore.FieldValue.serverTimestamp()
            };
        }
        const metrics = metricsSnap.docs.map(doc => doc.data());
        // P99 ÏßÄÏó∞ÏãúÍ∞Ñ Í≥ÑÏÇ∞
        const latencies = metrics.map(m => m.latency).sort((a, b) => a - b);
        const p99Index = Math.floor(latencies.length * 0.99);
        const currentLatencyP99 = latencies[p99Index] || 0;
        // ÏóêÎü¨Ïú® Í≥ÑÏÇ∞
        const totalRequests = metrics.length;
        const failedRequests = metrics.filter(m => !m.success).length;
        const currentErrorRate = totalRequests > 0 ? failedRequests / totalRequests : 0;
        // Í∞ÄÏö©ÏÑ± Í≥ÑÏÇ∞ (ÏÑ±Í≥µÌïú ÏöîÏ≤≠ ÎπÑÏú®)
        const currentAvailability = totalRequests > 0 ? (totalRequests - failedRequests) / totalRequests : 0;
        // SLO Îã¨ÏÑ± Ïó¨Î∂Ä
        const latencySLO = currentLatencyP99 <= target.latencyP99;
        const errorRateSLO = currentErrorRate <= target.errorRate;
        const availabilitySLO = currentAvailability >= target.availability;
        const overallSLO = latencySLO && errorRateSLO && availabilitySLO;
        return {
            service,
            window: windowHours,
            currentLatencyP99,
            currentErrorRate,
            currentAvailability,
            targetLatencyP99: target.latencyP99,
            targetErrorRate: target.errorRate,
            targetAvailability: target.availability,
            latencySLO,
            errorRateSLO,
            availabilitySLO,
            overallSLO,
            lastUpdated: admin.firestore.FieldValue.serverTimestamp()
        };
    }
    // SLO ÏÉÅÌÉú Ï†ÄÏû•
    static async saveSLOStatus(status) {
        await db.collection('slo_status').doc(`${status.service}_${status.window}h`).set(status);
    }
    // Î™®Îì† ÏÑúÎπÑÏä§Ïùò SLO ÏÉÅÌÉú Ï°∞Ìöå
    static async getAllSLOStatus(windowHours = 24) {
        const targetsSnap = await db.collection('slo_targets')
            .where('enabled', '==', true)
            .get();
        const statuses = [];
        for (const targetDoc of targetsSnap.docs) {
            const target = targetDoc.data();
            const status = await this.calculateSLOStatus(target.service, windowHours);
            if (status) {
                await this.saveSLOStatus(status);
                statuses.push(status);
            }
        }
        return statuses;
    }
    // SLO ÏúÑÎ∞ò ÏïåÎ¶º
    static async checkSLOViolations() {
        const statuses = await this.getAllSLOStatus();
        const violations = statuses.filter(status => !status.overallSLO);
        const alerts = [];
        for (const violation of violations) {
            const alert = this.generateSLOAlert(violation);
            alerts.push(alert);
        }
        return { violations, alerts };
    }
    // SLO ÏïåÎ¶º ÏÉùÏÑ±
    static generateSLOAlert(status) {
        const issues = [];
        if (!status.latencySLO) {
            issues.push(`ÏßÄÏó∞ÏãúÍ∞Ñ P99: ${status.currentLatencyP99}ms (Î™©Ìëú: ${status.targetLatencyP99}ms)`);
        }
        if (!status.errorRateSLO) {
            issues.push(`ÏóêÎü¨Ïú®: ${(status.currentErrorRate * 100).toFixed(2)}% (Î™©Ìëú: ${(status.targetErrorRate * 100).toFixed(2)}%)`);
        }
        if (!status.availabilitySLO) {
            issues.push(`Í∞ÄÏö©ÏÑ±: ${(status.currentAvailability * 100).toFixed(2)}% (Î™©Ìëú: ${(status.targetAvailability * 100).toFixed(2)}%)`);
        }
        return `üö® SLO ÏúÑÎ∞ò: ${status.service}\n${issues.join('\n')}`;
    }
    // SLO ÎåÄÏãúÎ≥¥Îìú Îç∞Ïù¥ÌÑ∞
    static async getSLODashboard() {
        const statuses = await this.getAllSLOStatus();
        const overallHealth = statuses.length > 0
            ? statuses.filter(s => s.overallSLO).length / statuses.length
            : 1;
        const criticalIssues = statuses.filter(s => !s.overallSLO).length;
        // Ìä∏Î†åÎìú Îç∞Ïù¥ÌÑ∞ (ÏµúÍ∑º 7Ïùº)
        const trends = {};
        for (const status of statuses) {
            const trendData = await this.getSLOTrends(status.service, 7);
            trends[status.service] = trendData;
        }
        return {
            services: statuses,
            overallHealth,
            criticalIssues,
            trends
        };
    }
    // SLO Ìä∏Î†åÎìú Îç∞Ïù¥ÌÑ∞
    static async getSLOTrends(service, days) {
        const windowStart = admin.firestore.Timestamp.fromMillis(Date.now() - (days * 24 * 60 * 60 * 1000));
        const metricsSnap = await db.collection('slo_metrics')
            .where('service', '==', service)
            .where('timestamp', '>=', windowStart)
            .orderBy('timestamp', 'asc')
            .get();
        const metrics = metricsSnap.docs.map(doc => doc.data());
        // ÏãúÍ∞ÑÎ≥Ñ ÏßëÍ≥Ñ (1ÏãúÍ∞Ñ Îã®ÏúÑ)
        const hourlyData = new Map();
        metrics.forEach(metric => {
            const hour = metric.timestamp.toDate().toISOString().substring(0, 13);
            if (!hourlyData.has(hour)) {
                hourlyData.set(hour, { latencies: [], errors: 0, total: 0 });
            }
            const data = hourlyData.get(hour);
            data.latencies.push(metric.latency);
            data.total++;
            if (!metric.success)
                data.errors++;
        });
        const timestamps = [];
        const latency = [];
        const errorRate = [];
        const availability = [];
        for (const [hour, data] of hourlyData) {
            timestamps.push(hour);
            // P95 ÏßÄÏó∞ÏãúÍ∞Ñ
            const sortedLatencies = data.latencies.sort((a, b) => a - b);
            const p95Index = Math.floor(sortedLatencies.length * 0.95);
            latency.push(sortedLatencies[p95Index] || 0);
            // ÏóêÎü¨Ïú®
            errorRate.push(data.total > 0 ? data.errors / data.total : 0);
            // Í∞ÄÏö©ÏÑ±
            availability.push(data.total > 0 ? (data.total - data.errors) / data.total : 0);
        }
        return { latency, errorRate, availability, timestamps };
    }
    // SLO Î©îÌä∏Î¶≠ Ï†ïÎ¶¨ (Ïò§ÎûòÎêú Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú)
    static async cleanupOldMetrics(daysToKeep = 30) {
        const cutoffTime = admin.firestore.Timestamp.fromMillis(Date.now() - (daysToKeep * 24 * 60 * 60 * 1000));
        const oldMetricsSnap = await db.collection('slo_metrics')
            .where('timestamp', '<', cutoffTime)
            .limit(1000) // Î∞∞Ïπò ÌÅ¨Í∏∞ Ï†úÌïú
            .get();
        if (oldMetricsSnap.empty)
            return 0;
        const batch = db.batch();
        let deleted = 0;
        oldMetricsSnap.docs.forEach(doc => {
            batch.delete(doc.ref);
            deleted++;
        });
        await batch.commit();
        return deleted;
    }
    // SLO Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
    static async generateSLOReport(service, days = 7) {
        const status = await this.calculateSLOStatus(service, 24);
        const trends = await this.getSLOTrends(service, days);
        if (!status) {
            throw new Error(`No SLO data found for service: ${service}`);
        }
        const avgLatency = trends.latency.reduce((sum, val) => sum + val, 0) / trends.latency.length;
        const p99Latency = Math.max(...trends.latency);
        const avgErrorRate = trends.errorRate.reduce((sum, val) => sum + val, 0) / trends.errorRate.length;
        const avgAvailability = trends.availability.reduce((sum, val) => sum + val, 0) / trends.availability.length;
        const dailyBreakdown = trends.timestamps.map((timestamp, index) => ({
            date: timestamp,
            latency: trends.latency[index],
            errorRate: trends.errorRate[index],
            availability: trends.availability[index]
        }));
        const recommendations = [];
        if (!status.latencySLO) {
            recommendations.push('ÏßÄÏó∞ÏãúÍ∞Ñ ÏµúÏ†ÅÌôîÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨ÎÇò Ïô∏Î∂Ä API Ìò∏Ï∂úÏùÑ Í≤ÄÌÜ†ÌïòÏÑ∏Ïöî.');
        }
        if (!status.errorRateSLO) {
            recommendations.push('ÏóêÎü¨Ïú®Ïù¥ ÎÜíÏäµÎãàÎã§. ÏóêÎü¨ Î°úÍ∑∏Î•º Î∂ÑÏÑùÌïòÍ≥† ÏòàÏô∏ Ï≤òÎ¶¨Î•º Í∞ïÌôîÌïòÏÑ∏Ïöî.');
        }
        if (!status.availabilitySLO) {
            recommendations.push('Í∞ÄÏö©ÏÑ±Ïù¥ Î™©ÌëúÏπòÏóê ÎØ∏Îã¨Ìï©ÎãàÎã§. ÏÑúÎπÑÏä§ ÏïàÏ†ïÏÑ±ÏùÑ Í∞úÏÑ†ÌïòÏÑ∏Ïöî.');
        }
        return {
            service,
            period: `${days} days`,
            summary: {
                avgLatency,
                p99Latency,
                errorRate: avgErrorRate,
                availability: avgAvailability
            },
            dailyBreakdown,
            recommendations
        };
    }
}
exports.SLOMonitoring = SLOMonitoring;
exports.default = {
    SLOMonitoring
};
