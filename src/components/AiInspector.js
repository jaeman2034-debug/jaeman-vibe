import "@tensorflow/tfjs-backend-webgl";
import { useState } from "react";
export default function AiInspector({ file, onSuggest }) { const [model, setModel] = useState(null); } // ???�질 계산 ?�틸리티  function toGray(img: HTMLImageElement) {    const c = document.createElement("canvas");    const w = (c.width = img.naturalWidth || img.width);    const h = (c.height = img.naturalHeight || img.height);    const g = c.getContext("2d")!;    g.drawImage(img, 0, 0, w, h);    const { data } = g.getImageData(0, 0, w, h);    const gray = new Float32Array(w*h);    for (let i=0,j=0; i<data.length; i+=4, j++) {      gray[j] = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];    }    return { gray, w, h };  }  // ???�명?? Variance of Laplacian  function sharpnessVoL(gray: Float32Array, w:number, h:number) {    const lap = new Float32Array(w*h);    for (let y=1; y<h-1; y++) for (let x=1; x<w-1; x++) {      const i = y*w + x;      lap[i] = 4*gray[i] - gray[i-1] - gray[i+1] - gray[i-w] - gray[i+w];    }    let sum=0, sum2=0, n=(w-2)*(h-2);    for (let i=w+1; i<w*(h-1)-1; i++) { const v = lap[i]; sum+=v; sum2+=v*v; }    const varLap = (sum2/n) - (sum/n)**2;    return { score: Math.max(0, Math.min(1, varLap/1200)), lap };  }  // ??복잡?? ?��? 밀??  function clutterFromEdges(lap: Float32Array, w:number, h:number) {    let acc=0, n=(w-2)*(h-2);    for (let i=w+1; i<w*(h-1)-1; i++) acc += Math.abs(lap[i]);    const meanEdge = acc/n;    return Math.max(0, Math.min(1, meanEdge/50));  }  // ??밝기: ?�균 V 근사  function brightnessMean(gray: Float32Array) {    let sum=0; for (let i=0;i<gray.length;i++) sum += gray[i];    return Math.max(0, Math.min(1, (sum/gray.length)/255));  }  // ???�합 ?�질 분석 ?�수  function analyzeQuality(img: HTMLImageElement) {    const { gray, w, h } = toGray(img);    const { score: sharpness, lap } = sharpnessVoL(gray, w, h);    const clutter = clutterFromEdges(lap, w, h);    const brightness = brightnessMean(gray);    return { sharpness, brightness, clutter };  }  useEffect(() => {    let mounted = true;    (async () => {      try {        await tf.setBackend("webgl");     // ?�는 "cpu"        await tf.ready();        // ???�적 import (번들/SSR/HMR ?�슈 방�?)        const mobilenet = await import("@tensorflow-models/mobilenet");        const m = await mobilenet.load({ version: 2, alpha: 1.0 });        if (mounted) setModel(m);      } catch (error) {        console.error("TensorFlow.js 모델 로딩 ?�패:", error);        if (mounted) {          // ?�백: CPU 백엔???�도          try {            await tf.setBackend("cpu");            await tf.ready();            const mobilenet = await import("@tensorflow-models/mobilenet");            const m = await mobilenet.load({ version: 2, alpha: 1.0 });            if (mounted) setModel(m);          } catch (fallbackError) {            console.error("CPU 백엔?�도 ?�패:", fallbackError);          }        }      }    })();    return () => { mounted = false; };  }, []);  useEffect(() => {    if (!file || !model) return;        let mounted = true;    const analyzeImage = async () => {      try {        const url = URL.createObjectURL(file);        const img = new Image();                img.onload = async () => {          if (!mounted) {            URL.revokeObjectURL(url);            return;          }          try {            // 1) ?�벨 추출            const preds = await model.classify(img);            const labels = preds.map((p: any) => p.className).slice(0, 3);            // 2) ?�질 분석 (?�로???�틸리티 ?�용)            const q = analyzeQuality(img);            // 3) 카테고리/?�목 ?�안            const category = guessCategory(labels);            const title = makeTitle(labels, category);            // ??가�?범위 추천 (카테고리가 ?�을 ?�만)            let priceRange = undefined;            if (category && category !== "기�?") {              try {                priceRange = await suggestPriceRange(category);              } catch (error) {                console.warn("가�?범위 추천 ?�패:", error);              }            }            // ??개선????로직            const tips: string[] = [];            if (q.sharpness < 0.35) tips.push("?�진???�려?? ?�떨�??�이 ?�시 촬영?�보?�요.");            if (q.brightness < 0.40) tips.push("조명???�두?�요. 창�?/조명 ?�래?�서 촬영?�보?�요.");            if (q.brightness > 0.85) tips.push("?�간 과노출입?�다. ?�출????��보세??");            if (q.clutter > 0.65) tips.push("배경??복잡?�요. ?�색 배경?�서 촬영?�면 좋아??");            if (mounted) {              onSuggest({                labels,                category,                title,                quality: q,                tips,                priceRange,              });            }          } catch (error) {            console.error("?��?지 분석 ?�패:", error);          } finally {            URL.revokeObjectURL(url);          }        };                img.src = url;      } catch (error) {        console.error("?��?지 로딩 ?�패:", error);      }    };    analyzeImage();    return () => { mounted = false; };  }, [file, model, onSuggest]);  return null;}// ??강화??카테고리 매핑 - ?�의???�전 + 가중치const RULES: Record<string, string[]> = {  "축구": ["soccer", "football", "cleat", "shin guard", "goalkeeper", "futsal", "boot", "stud"],  "?�구": ["basketball", "hoop", "jersey", "court", "dunk", "rebound"],  "?�구": ["baseball", "bat", "glove", "catcher", "helmet", "pitcher", "diamond"],  "?�닝": ["running", "sneaker", "trainer", "sports shoe", "athletic", "jogging"],  "?�니??: ["tennis", "racket", "court", "serve", "volley"],  "골프": ["golf", "club", "putter", "driver", "course"],  "?�영": ["swimming", "pool", "goggles", "swimsuit", "cap"],  "가�?: ["backpack", "rucksack", "knapsack", "duffel", "bag", "purse", "tote"],  "?�류": ["jersey", "uniform", "shirt", "pants", "jacket", "hoodie"],  "보호?�비": ["helmet", "pad", "guard", "protector", "gear"],};function mapLabelsToCategory(labels: string[]) {  const t = labels.join(" ").toLowerCase();  let best: { cat?: string, score: number } = { score: 0 };    for (const [cat, keys] of Object.entries(RULES)) {    let s = 0;    for (const k of keys) {      if (t.includes(k)) s += 1;    }    if (s > best.score) best = { cat, score: s };  }    return best.cat ?? "기�?";}// ??개선??카테고리 추천function guessCategory(labels: string[]) {  return mapLabelsToCategory(labels);}function makeTitle(labels: string[], category?: string) {  const main = (labels[0] || "?�포츠용??).split(",")[0];  return `${category ?? "?�포�?} ${main}`.trim();}
