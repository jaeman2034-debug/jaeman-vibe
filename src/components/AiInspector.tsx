import * as tf from "@tensorflow/tfjs";import "@tensorflow/tfjs-backend-webgl";import { useEffect, useState } from "react";import { suggestPriceRange } from "@/lib/priceSuggest";export default function AiInspector({ file, onSuggest }: {  file?: File | null,  onSuggest: (s: {    labels: string[],    category?: string,    title?: string,    tips: string[],    quality: { sharpness: number, brightness: number, clutter: number },    priceRange?: any  }) => void}) {  const [model, setModel] = useState<any>(null);  // ???ˆì§ˆ ê³„ì‚° ? í‹¸ë¦¬í‹°  function toGray(img: HTMLImageElement) {    const c = document.createElement("canvas");    const w = (c.width = img.naturalWidth || img.width);    const h = (c.height = img.naturalHeight || img.height);    const g = c.getContext("2d")!;    g.drawImage(img, 0, 0, w, h);    const { data } = g.getImageData(0, 0, w, h);    const gray = new Float32Array(w*h);    for (let i=0,j=0; i<data.length; i+=4, j++) {      gray[j] = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];    }    return { gray, w, h };  }  // ??? ëª…?? Variance of Laplacian  function sharpnessVoL(gray: Float32Array, w:number, h:number) {    const lap = new Float32Array(w*h);    for (let y=1; y<h-1; y++) for (let x=1; x<w-1; x++) {      const i = y*w + x;      lap[i] = 4*gray[i] - gray[i-1] - gray[i+1] - gray[i-w] - gray[i+w];    }    let sum=0, sum2=0, n=(w-2)*(h-2);    for (let i=w+1; i<w*(h-1)-1; i++) { const v = lap[i]; sum+=v; sum2+=v*v; }    const varLap = (sum2/n) - (sum/n)**2;    return { score: Math.max(0, Math.min(1, varLap/1200)), lap };  }  // ??ë³µì¡?? ?ì? ë°€??  function clutterFromEdges(lap: Float32Array, w:number, h:number) {    let acc=0, n=(w-2)*(h-2);    for (let i=w+1; i<w*(h-1)-1; i++) acc += Math.abs(lap[i]);    const meanEdge = acc/n;    return Math.max(0, Math.min(1, meanEdge/50));  }  // ??ë°ê¸°: ?‰ê·  V ê·¼ì‚¬  function brightnessMean(gray: Float32Array) {    let sum=0; for (let i=0;i<gray.length;i++) sum += gray[i];    return Math.max(0, Math.min(1, (sum/gray.length)/255));  }  // ???µí•© ?ˆì§ˆ ë¶„ì„ ?¨ìˆ˜  function analyzeQuality(img: HTMLImageElement) {    const { gray, w, h } = toGray(img);    const { score: sharpness, lap } = sharpnessVoL(gray, w, h);    const clutter = clutterFromEdges(lap, w, h);    const brightness = brightnessMean(gray);    return { sharpness, brightness, clutter };  }  useEffect(() => {    let mounted = true;    (async () => {      try {        await tf.setBackend("webgl");     // ?ëŠ” "cpu"        await tf.ready();        // ???™ì  import (ë²ˆë“¤/SSR/HMR ?´ìŠˆ ë°©ì?)        const mobilenet = await import("@tensorflow-models/mobilenet");        const m = await mobilenet.load({ version: 2, alpha: 1.0 });        if (mounted) setModel(m);      } catch (error) {        console.error("TensorFlow.js ëª¨ë¸ ë¡œë”© ?¤íŒ¨:", error);        if (mounted) {          // ?´ë°±: CPU ë°±ì—”???œë„          try {            await tf.setBackend("cpu");            await tf.ready();            const mobilenet = await import("@tensorflow-models/mobilenet");            const m = await mobilenet.load({ version: 2, alpha: 1.0 });            if (mounted) setModel(m);          } catch (fallbackError) {            console.error("CPU ë°±ì—”?œë„ ?¤íŒ¨:", fallbackError);          }        }      }    })();    return () => { mounted = false; };  }, []);  useEffect(() => {    if (!file || !model) return;        let mounted = true;    const analyzeImage = async () => {      try {        const url = URL.createObjectURL(file);        const img = new Image();                img.onload = async () => {          if (!mounted) {            URL.revokeObjectURL(url);            return;          }          try {            // 1) ?¼ë²¨ ì¶”ì¶œ            const preds = await model.classify(img);            const labels = preds.map((p: any) => p.className).slice(0, 3);            // 2) ?ˆì§ˆ ë¶„ì„ (?ˆë¡œ??? í‹¸ë¦¬í‹° ?¬ìš©)            const q = analyzeQuality(img);            // 3) ì¹´í…Œê³ ë¦¬/?œëª© ?œì•ˆ            const category = guessCategory(labels);            const title = makeTitle(labels, category);            // ??ê°€ê²?ë²”ìœ„ ì¶”ì²œ (ì¹´í…Œê³ ë¦¬ê°€ ?ˆì„ ?Œë§Œ)            let priceRange = undefined;            if (category && category !== "ê¸°í?") {              try {                priceRange = await suggestPriceRange(category);              } catch (error) {                console.warn("ê°€ê²?ë²”ìœ„ ì¶”ì²œ ?¤íŒ¨:", error);              }            }            // ??ê°œì„ ????ë¡œì§            const tips: string[] = [];            if (q.sharpness < 0.35) tips.push("?¬ì§„???ë ¤?? ?ë–¨ë¦??†ì´ ?¤ì‹œ ì´¬ì˜?´ë³´?¸ìš”.");            if (q.brightness < 0.40) tips.push("ì¡°ëª…???´ë‘?Œìš”. ì°½ê?/ì¡°ëª… ?„ë˜?ì„œ ì´¬ì˜?´ë³´?¸ìš”.");            if (q.brightness > 0.85) tips.push("?½ê°„ ê³¼ë…¸ì¶œì…?ˆë‹¤. ?¸ì¶œ????¶°ë³´ì„¸??");            if (q.clutter > 0.65) tips.push("ë°°ê²½??ë³µì¡?´ìš”. ?¨ìƒ‰ ë°°ê²½?ì„œ ì´¬ì˜?˜ë©´ ì¢‹ì•„??");            if (mounted) {              onSuggest({                labels,                category,                title,                quality: q,                tips,                priceRange,              });            }          } catch (error) {            console.error("?´ë?ì§€ ë¶„ì„ ?¤íŒ¨:", error);          } finally {            URL.revokeObjectURL(url);          }        };                img.src = url;      } catch (error) {        console.error("?´ë?ì§€ ë¡œë”© ?¤íŒ¨:", error);      }    };    analyzeImage();    return () => { mounted = false; };  }, [file, model, onSuggest]);  return null;}// ??ê°•í™”??ì¹´í…Œê³ ë¦¬ ë§¤í•‘ - ?™ì˜???¬ì „ + ê°€ì¤‘ì¹˜const RULES: Record<string, string[]> = {  "ì¶•êµ¬": ["soccer", "football", "cleat", "shin guard", "goalkeeper", "futsal", "boot", "stud"],  "?êµ¬": ["basketball", "hoop", "jersey", "court", "dunk", "rebound"],  "?¼êµ¬": ["baseball", "bat", "glove", "catcher", "helmet", "pitcher", "diamond"],  "?¬ë‹": ["running", "sneaker", "trainer", "sports shoe", "athletic", "jogging"],  "?Œë‹ˆ??: ["tennis", "racket", "court", "serve", "volley"],  "ê³¨í”„": ["golf", "club", "putter", "driver", "course"],  "?˜ì˜": ["swimming", "pool", "goggles", "swimsuit", "cap"],  "ê°€ë°?: ["backpack", "rucksack", "knapsack", "duffel", "bag", "purse", "tote"],  "?˜ë¥˜": ["jersey", "uniform", "shirt", "pants", "jacket", "hoodie"],  "ë³´í˜¸?¥ë¹„": ["helmet", "pad", "guard", "protector", "gear"],};function mapLabelsToCategory(labels: string[]) {  const t = labels.join(" ").toLowerCase();  let best: { cat?: string, score: number } = { score: 0 };    for (const [cat, keys] of Object.entries(RULES)) {    let s = 0;    for (const k of keys) {      if (t.includes(k)) s += 1;    }    if (s > best.score) best = { cat, score: s };  }    return best.cat ?? "ê¸°í?";}// ??ê°œì„ ??ì¹´í…Œê³ ë¦¬ ì¶”ì²œfunction guessCategory(labels: string[]) {  return mapLabelsToCategory(labels);}function makeTitle(labels: string[], category?: string) {  const main = (labels[0] || "?¤í¬ì¸ ìš©??).split(",")[0];  return `${category ?? "?¤í¬ì¸?} ${main}`.trim();}