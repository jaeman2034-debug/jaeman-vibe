import React, { useState, useCallback, useRef, useImperativeHandle } from 'react';import {  removeBackgroundAndResize,  calculateImageQuality,  resizeImage,} from '../../lib/backgroundRemovalUtils';import QualityScoreToast from '../ui/QualityScoreToast';interface AdvancedImageUploadProps {  onImagesSelected: (files: File[]) => void;  maxFiles?: number;  maxFileSize?: number; // MB  enableBackgroundRemoval?: boolean;  enableQualityCheck?: boolean;  qualityThreshold?: number; // 70% ë¯¸ë§Œ ???¤ì‹œ ì´¬ì˜ ê¶Œì¥  className?: string;}const AdvancedImageUpload = React.forwardRef<{  handleCameraCapture: (dataUrl: string) => void;}, Omit<AdvancedImageUploadProps, 'onCameraCapture'>>(({  onImagesSelected,  maxFiles = 5,  maxFileSize = 10, // 10MB  enableBackgroundRemoval = true,  enableQualityCheck = true,  qualityThreshold = 70,  className = ''}, ref) => {  const [isProcessing, setIsProcessing] = useState(false);  const [processingProgress, setProcessingProgress] = useState(0);  const [showQualityToast, setShowQualityToast] = useState(false);  const [qualityScore, setQualityScore] = useState(0);  const [currentFile, setCurrentFile] = useState<File | null>(null);  const [backgroundRemovalEnabled, setBackgroundRemovalEnabled] = useState(enableBackgroundRemoval);  const [backgroundRemovalQuality, setBackgroundRemovalQuality] = useState<'fast' | 'balanced' | 'high'>('balanced');  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);  const [failedUploads, setFailedUploads] = useState<{file: File, error: string}[]>([]);    const fileInputRef = useRef<HTMLInputElement>(null);  const dropZoneRef = useRef<HTMLDivElement>(null);  // ?¸ë??ì„œ ?‘ê·¼?????ˆëŠ” ?¨ìˆ˜??  useImperativeHandle(ref, () => ({    handleCameraCapture: handleCameraCapture  }), []);  // ?Œì¼ ? íš¨??ê²€??  const validateFile = (file: File): string | null => {    // ?Œì¼ ?¬ê¸° ê²€??    if (file.size > maxFileSize * 1024 * 1024) {      return `?Œì¼ ?¬ê¸°ê°€ ${maxFileSize}MBë¥?ì´ˆê³¼?©ë‹ˆ??`;    }    // ?Œì¼ ?€??ê²€??    if (!file.type.startsWith('image/')) {      return '?´ë?ì§€ ?Œì¼ë§??…ë¡œ?œí•  ???ˆìŠµ?ˆë‹¤.';    }    return null;  };  // ?´ë?ì§€ ?ˆì§ˆ ì²´í¬  const checkImageQuality = async (file: File): Promise<number> => {    if (!enableQualityCheck) return 100;        try {      const score = await calculateImageQuality(file);      setQualityScore(score);            // ?ˆì§ˆ???„ê³„ê°?ë¯¸ë§Œ?´ë©´ ? ìŠ¤???œì‹œ      if (score < qualityThreshold) {        setCurrentFile(file);        setShowQualityToast(true);      }            return score;    } catch (error) {      console.error('?ˆì§ˆ ?ìˆ˜ ê³„ì‚° ?¤íŒ¨:', error);      return 100; // ?ëŸ¬ ??ê¸°ë³¸ê°?    }  };  // ?´ë?ì§€ ?¬ë§· ë³€??(ê°„ë‹¨??ë¦¬ì‚¬?´ì¦ˆë¡??€ì²?  const convertImageFormatHandler = async (file: File): Promise<File> => {    try {      // ?¬ë§· ë³€???€??ë¦¬ì‚¬?´ì¦ˆë§??¤í–‰      return await resizeImage(file, 1600, 1600, 0.9);    } catch (error) {      console.error('?´ë?ì§€ ì²˜ë¦¬ ?¤íŒ¨:', error);      return file; // ?¤íŒ¨ ???ë³¸ ë°˜í™˜    }  };  // ë°°ê²½ ?œê±° ?¤í–‰  const processWithBackgroundRemoval = async (file: File): Promise<File> => {    if (!backgroundRemovalEnabled) {      return file;    }    try {      setProcessingProgress(25);            const result = await removeBackgroundAndResize(file, {}, {        maxWidth: 1600,        maxHeight: 1600,        quality: 0.86      });      if (!result.success || !result.blob) {        throw new Error(result.error || 'ë°°ê²½ ?œê±°???¤íŒ¨?ˆìŠµ?ˆë‹¤.');      }      setProcessingProgress(75);      // Blob??Fileë¡?ë³€??      const processedFile = new File([result.blob], file.name.replace(/\.[^/.]+$/, '.webp'), {        type: 'image/webp'      });      setProcessingProgress(100);      return processedFile;    } catch (error) {      console.error('ë°°ê²½ ?œê±° ì²˜ë¦¬ ?¤íŒ¨:', error);      // ë°°ê²½ ?œê±° ?¤íŒ¨ ???ë³¸ ?Œì¼ ë°˜í™˜      return file;    }  };  // ?´ë?ì§€ ë¦¬ì‚¬?´ì¦ˆ  const resizeImageFile = async (file: File): Promise<File> => {    try {      return await resizeImage(file, 1600, 1600, 0.86);    } catch (error) {      console.error('?´ë?ì§€ ë¦¬ì‚¬?´ì¦ˆ ?¤íŒ¨:', error);      return file;    }  };  // ?Œì¼ ì²˜ë¦¬ ?Œì´?„ë¼??  const processFile = async (file: File): Promise<File> => {    // 1. ?ˆì§ˆ ì²´í¬    await checkImageQuality(file);        // 2. ë°°ê²½ ?œê±° (? íƒ?¬í•­)    let processedFile = await processWithBackgroundRemoval(file);        // 3. ë¦¬ì‚¬?´ì¦ˆ    processedFile = await resizeImageFile(processedFile);        return processedFile;  };  // ?…ë¡œ??ë¡¤ë°± ?¨ìˆ˜  const rollbackUploads = async () => {    try {      // ?…ë¡œ?œëœ ?Œì¼???•ë¦¬      for (const file of uploadedFiles) {        // ë©”ëª¨ë¦¬ì—???Œì¼ ê°ì²´ ?´ì œ        if (file instanceof File && 'revokeObjectURL' in URL) {          URL.revokeObjectURL(URL.createObjectURL(file));        }      }            // ?íƒœ ì´ˆê¸°??      setUploadedFiles([]);      setFailedUploads([]);            console.log('?…ë¡œ??ë¡¤ë°± ?„ë£Œ');    } catch (error) {      console.error('ë¡¤ë°± ì¤??¤ë¥˜:', error);    }  };  // ?Œì¼ ? íƒ ì²˜ë¦¬  const handleFileSelect = useCallback(async (files: FileList) => {    if (files.length === 0) return;    setIsProcessing(true);    setProcessingProgress(0);    try {      const validFiles: File[] = [];      const errors: {file: File, error: string}[] = [];      // ?Œì¼ ? íš¨??ê²€??      for (let i = 0; i < Math.min(files.length, maxFiles); i++) {        const file = files[i];        const error = validateFile(file);                if (error) {          errors.push({file, error});        } else {          validFiles.push(file);        }      }      if (errors.length > 0) {        setFailedUploads(prev => [...prev, ...errors]);        console.error('?Œì¼ ê²€ì¦??¤ë¥˜:', errors);      }      if (validFiles.length === 0) {        setIsProcessing(false);        return;      }      // ?Œì¼ ì²˜ë¦¬      const processedFiles = await Promise.all(        validFiles.map(async (file) => {          try {            return await processFile(file);          } catch (error) {            errors.push({file, error: `ì²˜ë¦¬ ?¤íŒ¨: ${error}`});            return null;          }        })      );      // ?±ê³µ???Œì¼?¤ë§Œ ?„í„°ë§?      const successfulFiles = processedFiles.filter(Boolean) as File[];            if (successfulFiles.length > 0) {        setUploadedFiles(prev => [...prev, ...successfulFiles]);        onImagesSelected(successfulFiles);      }      // ?¤íŒ¨???Œì¼??ì²˜ë¦¬      if (errors.length > 0) {        setFailedUploads(prev => [...prev, ...errors]);        console.error('?Œì¼ ì²˜ë¦¬ ?¤ë¥˜:', errors);                // ëª¨ë“  ?Œì¼???¤íŒ¨??ê²½ìš° ë¡¤ë°±        if (successfulFiles.length === 0) {          await rollbackUploads();        }      }    } catch (error) {      console.error('?Œì¼ ì²˜ë¦¬ ?¤íŒ¨:', error);      // ?„ì²´ ?¤íŒ¨ ??ë¡¤ë°±      await rollbackUploads();    } finally {      setIsProcessing(false);      setProcessingProgress(0);    }  }, [maxFiles, maxFileSize, onImagesSelected, enableQualityCheck, qualityThreshold, uploadedFiles]);  // ?Œì¼ ?…ë ¥ ë³€ê²?  const handleFileInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {    const files = event.target.files;    if (files) {      handleFileSelect(files);    }  };  // ?œë˜ê·????œë¡­ ì²˜ë¦¬  const handleDragOver = useCallback((e: React.DragEvent) => {    e.preventDefault();    e.stopPropagation();    if (dropZoneRef.current) {      dropZoneRef.current.classList.add('border-blue-500', 'bg-blue-50');    }  }, []);  const handleDragLeave = useCallback((e: React.DragEvent) => {    e.preventDefault();    e.stopPropagation();    if (dropZoneRef.current) {      dropZoneRef.current.classList.remove('border-blue-500', 'bg-blue-50');    }  }, []);  const handleDrop = useCallback((e: React.DragEvent) => {    e.preventDefault();    e.stopPropagation();        if (dropZoneRef.current) {      dropZoneRef.current.classList.remove('border-blue-500', 'bg-blue-50');    }    const files = e.dataTransfer.files;    if (files.length > 0) {      handleFileSelect(files);    }  }, [handleFileSelect]);  // ?¤ì‹œ ì´¬ì˜ ì²˜ë¦¬  const handleRetake = () => {    if (fileInputRef.current) {      fileInputRef.current.click();    }    setShowQualityToast(false);  };  // ì¹´ë©”??ì´¬ì˜ ì²˜ë¦¬ (?¸ë??ì„œ ?¸ì¶œ)  const handleCameraCapture = useCallback(async (dataUrl: string) => {    try {      // dataURL??Blob?¼ë¡œ ë³€??      const response = await fetch(dataUrl);      const blob = await response.blob();            // Blob??Fileë¡?ë³€??      const file = new File([blob], `camera-${Date.now()}.jpg`, { type: 'image/jpeg' });            // ?Œì¼ ì²˜ë¦¬      const dataTransfer = new DataTransfer();      dataTransfer.items.add(file);      handleFileSelect(dataTransfer.files);          } catch (error) {      console.error('ì¹´ë©”??ì´¬ì˜ ì²˜ë¦¬ ?¤íŒ¨:', error);      alert('ì¹´ë©”??ì´¬ì˜ ì²˜ë¦¬ ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.');    }  }, [handleFileSelect]);  return (    <div className={className}>      {/* ë°°ê²½ ?œê±° ?¤ì • */}      {enableBackgroundRemoval && (        <div className="mb-4 p-3 bg-gray-50 rounded-lg">          <div className="flex items-center justify-between mb-2">            <label className="flex items-center gap-2 text-sm font-medium text-gray-700">              <input                type="checkbox"                checked={backgroundRemovalEnabled}                onChange={(e) => setBackgroundRemovalEnabled(e.target.checked)}                className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"              />              ?¨ ë°°ê²½ ?œê±° ?¬ìš©            </label>          </div>                    {backgroundRemovalEnabled && (            <div className="ml-6">              <label className="block text-xs text-gray-600 mb-1">?ˆì§ˆ ?¤ì •:</label>              <select                value={backgroundRemovalQuality}                onChange={(e) => setBackgroundRemovalQuality(e.target.value as any)}                className="text-xs border border-gray-300 rounded px-2 py-1"              >                <option value="fast">ë¹ ë¦„ (??? ?ˆì§ˆ)</option>                <option value="balanced">ê· í˜• (ë³´í†µ ?ˆì§ˆ)</option>                <option value="high">?’ìŒ (ìµœê³  ?ˆì§ˆ)</option>              </select>            </div>          )}                  </div>      )}      {/* ?œë˜ê·????œë¡­ ?ì—­ */}      <div        ref={dropZoneRef}        className={`border-2 border-dashed border-gray-300 rounded-lg p-6 text-center transition-all duration-200 ${          isProcessing ? 'opacity-50 cursor-not-allowed' : 'hover:border-gray-400 hover:bg-gray-50'        }`}        onDragOver={handleDragOver}        onDragLeave={handleDragLeave}        onDrop={handleDrop}      >        {isProcessing ? (          <div className="space-y-3">            <div className="w-8 h-8 border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin mx-auto"></div>            <p className="text-sm text-gray-600">?´ë?ì§€ ì²˜ë¦¬ ì¤?..</p>            <div className="w-full bg-gray-200 rounded-full h-2">              <div                className="bg-blue-600 h-2 rounded-full transition-all duration-300"                style={{ width: `${processingProgress}%` }}              />            </div>            <p className="text-xs text-gray-500">{processingProgress}%</p>          </div>        ) : (          <div className="space-y-3">            <div className="text-4xl">?“¸</div>            <div>              <p className="text-sm font-medium text-gray-700">                ?´ë?ì§€ë¥??œë˜ê·¸í•˜ê±°ë‚˜ ?´ë¦­?˜ì—¬ ? íƒ              </p>              <p className="text-xs text-gray-500 mt-1">                ìµœë? {maxFiles}ê°? ê°?{maxFileSize}MB ?´í•˜              </p>            </div>                        <button              onClick={() => fileInputRef.current?.click()}              disabled={isProcessing}              className="px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"            >              ?´ë?ì§€ ? íƒ            </button>                        <p className="text-xs text-gray-400">              JPG, PNG, WebP ì§€??              {enableBackgroundRemoval && backgroundRemovalEnabled && ' ??ë°°ê²½ ?œê±° ?¬í•¨'}            </p>          </div>        )}      </div>      {/* ?¨ê²¨ì§??Œì¼ ?…ë ¥ */}      <input        ref={fileInputRef}        type="file"        multiple        accept="image/*"        onChange={handleFileInputChange}        className="hidden"        disabled={isProcessing}      />      {/* ?ˆì§ˆ ?ìˆ˜ ? ìŠ¤??*/}      <QualityScoreToast        qualityScore={qualityScore}        isVisible={showQualityToast}        onClose={() => setShowQualityToast(false)}        onRetake={handleRetake}        autoHide={false}      />      {/* ?¤íŒ¨???…ë¡œ???œì‹œ */}      {failedUploads.length > 0 && (        <div className="mt-4 p-3 bg-red-50 border border-red-200 rounded-lg">          <div className="flex items-center gap-2 text-sm text-red-800 mb-2">            <span>? ï¸ ?…ë¡œ???¤íŒ¨ ({failedUploads.length}ê°?</span>          </div>          <div className="space-y-2">            {failedUploads.map((item, index) => (              <div key={index} className="flex items-center justify-between text-xs">                <span className="text-red-700 truncate">{item.file.name}</span>                <span className="text-red-600">{item.error}</span>              </div>            ))}          </div>          <button            onClick={rollbackUploads}            className="mt-2 px-3 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700 transition-colors"          >            ?¤íŒ¨???Œì¼ ?•ë¦¬          </button>        </div>      )}      {/* ì²˜ë¦¬ ?íƒœ ?œì‹œ */}      {isProcessing && (        <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">          <div className="flex items-center gap-2 text-sm text-blue-800">            <div className="w-4 h-4 border-2 border-blue-200 border-t-blue-600 rounded-full animate-spin"></div>            <span>?´ë?ì§€ ì²˜ë¦¬ ì¤?..</span>          </div>          <div className="mt-2 text-xs text-blue-600">            {backgroundRemovalEnabled && 'ë°°ê²½ ?œê±° ??'}ë¦¬ì‚¬?´ì¦ˆ ??ìµœì ??          </div>        </div>      )}    </div>  );});export default AdvancedImageUpload; 
