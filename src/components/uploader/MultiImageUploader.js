"use strict";
// src/components/uploader/MultiImageUploader.tsximport React, { useEffect, useState } from 'react';import {  DndContext,  closestCenter,  PointerSensor,  useSensor,  useSensors,} from '@dnd-kit/core';import {  arrayMove,  SortableContext,  useSortable,  verticalListSortingStrategy,} from '@dnd-kit/sortable';import { CSS } from '@dnd-kit/utilities';export type PendingImage = { id: string; file: File; url: string };function SortableRow({  item,  onRemove,}: {  item: PendingImage;  onRemove?: (id: string) => void;}) {  const { attributes, listeners, setNodeRef, transform, transition } =    useSortable({ id: item.id });  const style: React.CSSProperties = {    transform: CSS.Transform.toString(transform),    transition,    display: 'grid',    gridTemplateColumns: '80px 1fr 70px',    gap: 8,    alignItems: 'center',    padding: '8px',    border: '1px solid #e5e7eb',    borderRadius: 8,    background: '#fff',  };  return (    <div ref={setNodeRef} style={style} {...attributes} {...listeners}>      <img        src={item.url}        alt=""        style={{ width: 80, height: 80, objectFit: 'cover', borderRadius: 6 }}      />      <div style={{ fontSize: 12, opacity: 0.8, wordBreak: 'break-all' }}>        {item.file.name}      </div>      <button        type="button"        onClick={() => onRemove?.(item.id)}        style={{ padding: '6px 8px' }}      >        ??��      </button>    </div>  );}export default function MultiImageUploader({  max = 6,  onChange,}: {  max?: number;  onChange: (files: File[]) => void;}) {  const [items, setItems] = useState<PendingImage[]>([]);  const sensors = useSensors(    useSensor(PointerSensor, { activationConstraint: { distance: 5 } })  );  useEffect(() => {    onChange(items.map((i) => i.file));  }, [items, onChange]);  function remove(id: string) {    setItems((prev) => prev.filter((x) => x.id !== id));  }  function removeAll() {    setItems([]);  }  async function onPick(e: React.ChangeEvent<HTMLInputElement>) {    const files = Array.from(e.target.files || []);    if (!files.length) return;    const add = files      .slice(0, Math.max(0, max - items.length))      .map((f) => ({        id: crypto.randomUUID(),        file: f,        url: URL.createObjectURL(f),      }));    setItems((prev) => [...prev, ...add]);    e.currentTarget.value = '';  }  function onDragEnd(event: any) {    const { active, over } = event;    if (!over || active.id === over.id) return;    const oldIdx = items.findIndex((i) => i.id === active.id);    const newIdx = items.findIndex((i) => i.id === over.id);    setItems((prev) => arrayMove(prev, oldIdx, newIdx));  }  return (    <div style={{ display: 'grid', gap: 8 }}>      <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>        <input type="file" accept="image/*" multiple onChange={onPick} />        <button type="button" onClick={removeAll} style={{ padding: '6px 10px' }}>          모두 ?�거        </button>        <span style={{ fontSize: 12, opacity: 0.7 }}>          최�? {max}??· ?�래그로 ?�서 변�?(1�??�네??        </span>      </div>      <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={onDragEnd}>        <SortableContext items={items.map((i) => i.id)} strategy={verticalListSortingStrategy}>          <div style={{ display: 'grid', gap: 8 }}>            {items.map((it) => (              <SortableRow key={it.id} item={it} onRemove={remove} />            ))}          </div>        </SortableContext>      </DndContext>    </div>  );}
