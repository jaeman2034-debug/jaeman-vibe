"use strict";
// ?�� ?�국???�화번호 ?�싱 ?�틸리티// ?�성 ?�식 결과?�서 ?�자?� ?�이?�을 추출?�여 ?�규?�된 ?�화번호�?변??/** ?�국???�자 ?�어 ???�자 매핑 */const KOREAN_NUMBER_MAP: Record<string, string> = {  // 0  '??: '0', '�?: '0', '?�로': '0', '�?: '0',    // 1  '??: '1', '?�나': '1', 'one': '1',    // 2  '??: '2', '??: '2', 'two': '2', '??: '2',    // 3  '??: '3', '??: '3', 'three': '3', '?�리': '3',    // 4  '??: '4', '??: '4', 'four': '4', '??: '4',    // 5  '??: '5', '?�섯': '5', 'five': '5', '?�이�?: '5',    // 6  '??: '6', '?�섯': '6', 'six': '6', '?�스': '6',    // 7  '�?: '7', '?�곱': '7', 'seven': '7', '?�븐': '7',    // 8  '??: '8', '?�덟': '8', 'eight': '8', '?�잇': '8',    // 9  '�?: '9', '?�홉': '9', 'nine': '9', '?�인': '9',};/** ?�이??관???�어 ???�이??매핑 */const HYPHEN_WORDS = [  '?�??, '?�이??, '빼기', 'dash', 'hyphen', 'minus'];/** ?�국 ?��???번호 ?�턴 (010-xxxx-xxxx) */const KR_PHONE_PATTERN = /^010[-\s]?(\d{4})[-\s]?(\d{4})$/;/** * ?�성 ?�식 결과?�서 ?�화번호 추출 �??�규?? * @param text ?�성 ?�식 결과 ?�스?? * @returns { digits: string, formatted: string } ?�규?�된 ?�화번호 */export function extractPhoneKO(text: string): { digits: string; formatted: string } {  if (!text || typeof text !== 'string') {    return { digits: '', formatted: '' };  }  let normalized = text.toLowerCase().trim();    // 1️⃣ ?�국???�자 ?�어 ???�자 변??  Object.entries(KOREAN_NUMBER_MAP).forEach(([korean, digit]) => {    const regex = new RegExp(korean, 'gi');    normalized = normalized.replace(regex, digit);  });    // 2️⃣ ?�이??관???�어 ???�이??변??  HYPHEN_WORDS.forEach(hyphenWord => {    const regex = new RegExp(hyphenWord, 'gi');    normalized = normalized.replace(regex, '-');  });    // 3️⃣ ?�자?� ?�이?�만 ?�기�?  let digits = normalized.replace(/[^\d-]/g, '');    // 4️⃣ ?�속???�이???�리  digits = digits.replace(/-{2,}/g, '-');    // 5️⃣ ?�뒤 ?�이???�거  digits = digits.replace(/^-+|-+$/g, '');    // 6️⃣ ?�국 ?��???번호 ?�선 추출 (010?�로 ?�작?�는 11?�리)  if (digits.includes('010')) {    const startIndex = digits.indexOf('010');    const potentialPhone = digits.slice(startIndex, startIndex + 11);        if (potentialPhone.length === 11 && /^\d{11}$/.test(potentialPhone)) {      const formatted = formatKR(potentialPhone);      return { digits: potentialPhone, formatted };    }  }    // 7️⃣ ?�반?�인 ?�자 ?�퀀?�에??11?�리 추출  const cleanDigits = digits.replace(/[^\d]/g, '');  if (cleanDigits.length >= 11) {    const phoneDigits = cleanDigits.slice(0, 11);    const formatted = formatKR(phoneDigits);    return { digits: phoneDigits, formatted };  }    // 8️⃣ 11?�리 미만??경우 그�?�?반환  if (cleanDigits.length > 0) {    return { digits: cleanDigits, formatted: cleanDigits };  }    return { digits: '', formatted: '' };}/** * 11?�리 ?�자�??�국 ?�화번호 ?�식?�로 ?�맷?? * @param digits 11?�리 ?�자 문자?? * @returns 010-xxxx-xxxx ?�식???�화번호 */export function formatKR(digits: string): string {  if (!digits || digits.length !== 11 || !/^\d{11}$/.test(digits)) {    return digits;  }    return `${digits.slice(0, 3)}-${digits.slice(3, 7)}-${digits.slice(7)}`;}/** * ?�화번호 ?�효??검?? * @param phone ?�화번호 문자?? * @returns ?�효???�국 ?��???번호?��? ?��? */export function isValidKRPhone(phone: string): boolean {  if (!phone) return false;    // ?�이???�거 ??11?�리 ?�자?��? ?�인  const clean = phone.replace(/[^\d]/g, '');  if (clean.length !== 11) return false;    // 010?�로 ?�작?�는지 ?�인  if (!clean.startsWith('010')) return false;    return true;}/** * ?�성 ?�식 결과?�서 ?�자�?추출 (?�화번호 ???�도) * @param text ?�성 ?�식 결과 ?�스?? * @returns ?�자�??�함??문자?? */export function extractDigits(text: string): string {  if (!text || typeof text !== 'string') return '';    let normalized = text.toLowerCase();    // ?�국???�자 ?�어 ???�자 변??  Object.entries(KOREAN_NUMBER_MAP).forEach(([korean, digit]) => {    const regex = new RegExp(korean, 'gi');    normalized = normalized.replace(regex, digit);  });    // ?�자�?추출  return normalized.replace(/[^\d]/g, '');} 
