"use strict";
// useSpeech.tsimport { useCallback, useEffect, useRef, useState } from "react";import { startSimpleVAD } from "./simple-vad";import { detectSttSupport } from "./sttSupport";// ???�동 ?��? 금�?const AUTO_STT = false;// VAD ?�성???��? (PTT�????�는 false�??�정)const ENABLE_VAD = false; // VAD ?�전 비활?�화// (?�션) ?�러 컴포?�트?�서 useSpeech()�??�도 VAD가 ?�나�??�도�?모듈 ?�벨 ?��???let VAD_SINGLETON: null | { stop: () => void } = null;// 1) ?�단 near imports ?�래???�태 ?�언 추�?type Thresholds = { noise: number; start: number; stop: number };type Meter = { rms: number; db: number };export function useSpeech() {  const [isListening, setIsListening] = useState(false);  // ??추�?: ?�계�?미터 ?�태  const [thresholds, setThresholds] = useState<Thresholds | null>(null);  const [meter, setMeter] = useState<Meter>({ rms: 0, db: -Infinity });  // STT 지???��?  const [sttSupport, setSttSupport] = useState<{ok:boolean; reason?:string}>({ ok: true });  // 버튼 ?��????�일 진실??  const isListeningRef = useRef(false);  // Web Speech API ?�스?�스  const recogRef = useRef<SpeechRecognition | null>(null);  // PTT ?�용 ?�성 ?�식 ?�스?�스 ref  const recRef = useRef<SpeechRecognition | null>(null);  // VAD ?�들(?????��??�서 참조??  const vadRef = useRef<null | { stop: () => void }>(null);  // ?��??�서 ?�레?�마???�데?�트?�는 ?�벨??ref�?받았?��? 100ms마다 state�?반영  const levelRef = useRef(0);  // PTT ?�동 ?�시??관??refs  const pressedRef = useRef(false);  const busyRef = useRef(false);  const restartTimer = useRef<ReturnType<typeof setTimeout> | null>(null);  // ??추�?: 100ms 간격?�로 미터 ?�시 ?�데?�트  useEffect(() => {    const id = setInterval(() => {      const rms = levelRef.current;      const db = rms > 0 ? 20 * Math.log10(rms) : -Infinity;      setMeter({ rms, db });    }, 100);    return () => clearInterval(id);  }, []);  // 초기 ??번만 체크  useEffect(() => {    setSttSupport(detectSttSupport());  }, []);  // --- Web Speech 준�?  const makeRecognizer = useCallback((): SpeechRecognition => {    const SR: any =      (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;    if (!SR) {      console.warn("Web Speech API not supported in this browser.");      throw new Error("Web Speech API not supported");    }    const r: SpeechRecognition = new SR();    r.lang = "ko-KR";        // ?�요 ?�어�?변�?    r.continuous = true;     // 길게 ?�기    r.interimResults = true; // 중간 결과 ?�요 ?�으�?false    r.maxAlternatives = 1;    r.onresult = (ev: SpeechRecognitionEvent) => {      const last = ev.results[ev.results.length - 1];      const text = last[0]?.transcript ?? "";      // TODO: ?�기??text�??�서/?�태�??�기?�요.      console.log("[STT] text:", text);    };    const restart = () => {      if (!pressedRef.current) return;      if (busyRef.current) return;      if (restartTimer.current) clearTimeout(restartTimer.current);      restartTimer.current = setTimeout(() => {        try { r.start(); } catch {}      }, 120); // 짧�? backoff    };    r.onerror = (e: any) => {      // 'no-speech'???�시???�??      if (e?.error === "no-speech") restart();    };    r.onend = () => {      // ?�용?��? ?�전???�르�??�으�??�시??      restart();    };    r.onstart = () => {      // console.log("[STT] onstart");    };    return r;  }, []);  const ensureRecognition = useCallback(() => {    if (recogRef.current) return;    try {      recogRef.current = makeRecognizer();    } catch (e) {      console.warn("Failed to create recognizer:", e);    }  }, [makeRecognizer]);  // --- STT ?�어  const startSTT = useCallback(async () => {    if (!sttSupport.ok) {      console.warn("[STT] not supported:", sttSupport.reason);      return;    }    if (isListeningRef.current) return;    ensureRecognition();    if (!recogRef.current) return;    console.log("starting STT...");    try {      recogRef.current.start();      isListeningRef.current = true;      setIsListening(true);    } catch (e) {      console.warn("STT start failed:", e);    }  }, [ensureRecognition, sttSupport]);  const stopSTT = useCallback(async () => {    if (!isListeningRef.current) return;    if (!recogRef.current) return;    console.log("stopping STT...");    try {      recogRef.current.stop();    } catch (e) {      console.warn("STT stop failed:", e);    }    isListeningRef.current = false;    setIsListening(false);  }, []);  // PTT ?�용 ?�수??  const startPTT = useCallback(() => {    if (busyRef.current) return;    busyRef.current = true;    pressedRef.current = true;    if (!recRef.current) {      try {        recRef.current = makeRecognizer();      } catch (e) {        console.warn("Failed to create recognizer for PTT:", e);        busyRef.current = false;        return;      }    }        try {       recRef.current.start();       isListeningRef.current = true;      setIsListening(true);    } catch (e) {      console.warn("PTT start failed:", e);    } finally {       busyRef.current = false;     }  }, [makeRecognizer]);  const stopPTT = useCallback(() => {    if (busyRef.current) return;    busyRef.current = true;    pressedRef.current = false;        if (!recRef.current) {      console.warn('[PTT] stop ignored (no active rec)');      busyRef.current = false;      isListeningRef.current = false;      setIsListening(false);      return;    }        try {       recRef.current.stop();    } catch (e) {      console.warn('[PTT] stop failed', e);    } finally {       recRef.current = null;      busyRef.current = false;     }        if (restartTimer.current) {       clearTimeout(restartTimer.current);       restartTimer.current = null;     }        isListeningRef.current = false;    setIsListening(false);  }, []);  const onMicClick = useCallback(() => {    if (isListeningRef.current) stopSTT();    else startSTT();  }, [startSTT, stopSTT]);  // --- VAD 초기???�말 ??번만)  useEffect(() => {    // VAD가 비활?�화?�어 ?�으�?초기?�하지 ?�음    if (!ENABLE_VAD) {      console.log("[VAD] Disabled - PTT mode only");      return;    }    // ?��? ?�른 컴포?�트?�서 만든 ?��??�이 ?�으�?그�?�??�사??    if (VAD_SINGLETON) {      vadRef.current = VAD_SINGLETON;      return;    }    let cancelled = false;    startSimpleVAD({      onRms: (r) => { levelRef.current = r; },           // ??추�?: ?�벨�?ref�?축적      onReady: (info) => setThresholds(info),            // ??추�?: ?�계�??�신      onSpeechStart: () => {        console.log("[VAD] Speech detected");        if (!AUTO_STT) return;              // ?�동 모드        if (!isListeningRef.current) startSTT();      },      onSpeechEnd: () => {        console.log("[VAD] Speech ended");        if (!AUTO_STT) return;        if (isListeningRef.current) stopSTT();      },    }).then((v) => {      if (!cancelled) {        vadRef.current = v;        VAD_SINGLETON = v; // 모듈 ?�벨 ?��???보�?      }    });    return () => {      cancelled = true;      // ?��??�이므�??�기??stop()???�출?��? ?�음      // (???�역?�서 VAD ?�나�??��?; ?�요?�면 Provider ?�턴 권장)    };  }, [startSTT, stopSTT]);  // cleanup: 컴포?�트 ?�마?�트 ???�리  useEffect(() => {    return () => {      try {         recRef.current?.stop();         recogRef.current?.stop();      } catch {}      recRef.current = null;      recogRef.current = null;    };  }, []);  // ??추�?: thresholds, meter�??�께 반환  return { isListening, onMicClick, startSTT, stopSTT, startPTT, stopPTT, thresholds, meter, sttSupport };} 
