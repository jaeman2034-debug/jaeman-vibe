import { useState, useCallback } from 'react';import {   analyzeProductImage,   analyzeMultipleImages,  validateImageFile,  getErrorMessage,  type AIAnalysis } from '../services/aiService';export interface AIAnalysisResult extends AIAnalysis {}export interface AIAnalysisError {  error: string;  message: string;}export const useAIFeatures = () => {  const [isAnalyzing, setIsAnalyzing] = useState(false);  const [lastAnalysis, setLastAnalysis] = useState<AIAnalysisResult | null>(null);  const [lastError, setLastError] = useState<AIAnalysisError | null>(null);  const [analysisProgress, setAnalysisProgress] = useState(0);  const [currentFile, setCurrentFile] = useState<File | null>(null);  const analyzeProductImageWithHook = useCallback(async (    file: File,     prompt?: string  ): Promise<AIAnalysisResult | null> => {    setIsAnalyzing(true);    setLastError(null);    setAnalysisProgress(0);    setCurrentFile(file);    try {      // 1. ?Œì¼ ? íš¨??ê²€??      const validation = validateImageFile(file);      if (!validation.valid) {        throw new Error(validation.error || 'invalid-file');      }      // 2. ì§„í–‰ë¥??œë??ˆì´??(?¬ìš©??ê²½í—˜ ?¥ìƒ)      const progressInterval = setInterval(() => {        setAnalysisProgress(prev => {          if (prev >= 90) return prev;          return prev + Math.random() * 10;        });      }, 200);      // 3. AI ë¶„ì„ ?¤í–‰      const result = await analyzeProductImage(file, prompt);            // 4. ì§„í–‰ë¥??„ë£Œ      clearInterval(progressInterval);      setAnalysisProgress(100);      // 5. ê²°ê³¼ ?€??      setLastAnalysis(result);      return result;    } catch (error) {      const errorMessage = error instanceof Error ? error.message : 'unknown-error';      const userMessage = getErrorMessage(errorMessage);            const aiError: AIAnalysisError = {        error: errorMessage,        message: userMessage      };            setLastError(aiError);      console.error('[AI_ANALYZE] ë¶„ì„ ?¤íŒ¨:', error);      return null;    } finally {      setIsAnalyzing(false);      setCurrentFile(null);      // ì§„í–‰ë¥?ì´ˆê¸°?”ëŠ” ?½ê°„??ì§€????      setTimeout(() => setAnalysisProgress(0), 1000);    }  }, []);  const analyzeMultipleImagesWithHook = useCallback(async (    files: File[],     prompt?: string  ): Promise<AIAnalysisResult[]> => {    setIsAnalyzing(true);    setLastError(null);    setAnalysisProgress(0);    try {      // 1. ëª¨ë“  ?Œì¼ ? íš¨??ê²€??      const validations = files.map(file => validateImageFile(file));      const invalidFiles = validations.filter(v => !v.valid);            if (invalidFiles.length > 0) {        const firstError = invalidFiles[0].error || 'invalid-file';        throw new Error(firstError);      }      // 2. ì§„í–‰ë¥??œë??ˆì´??      const progressInterval = setInterval(() => {        setAnalysisProgress(prev => {          if (prev >= 90) return prev;          return prev + Math.random() * 5;        });      }, 300);      // 3. ?¤ì¤‘ ?´ë?ì§€ ë¶„ì„      const results = await analyzeMultipleImages(files, prompt);            // 4. ì§„í–‰ë¥??„ë£Œ      clearInterval(progressInterval);      setAnalysisProgress(100);      // 5. ì²?ë²ˆì§¸ ê²°ê³¼ë¥?ë§ˆì?ë§?ë¶„ì„?¼ë¡œ ?¤ì •      if (results.length > 0 && !results[0].error) {        setLastAnalysis(results[0]);      }      return results;    } catch (error) {      const errorMessage = error instanceof Error ? error.message : 'unknown-error';      const userMessage = getErrorMessage(errorMessage);            const aiError: AIAnalysisError = {        error: errorMessage,        message: userMessage      };            setLastError(aiError);      console.error('[AI_ANALYZE] ?¤ì¤‘ ?´ë?ì§€ ë¶„ì„ ?¤íŒ¨:', error);      return [];    } finally {      setIsAnalyzing(false);      setTimeout(() => setAnalysisProgress(0), 1000);    }  }, []);  const clearAnalysis = useCallback(() => {    setLastAnalysis(null);    setLastError(null);    setAnalysisProgress(0);    setCurrentFile(null);  }, []);  const getAnalysisStatus = useCallback(() => {    if (isAnalyzing) return 'analyzing';    if (lastError) return 'error';    if (lastAnalysis) return 'success';    return 'idle';  }, [isAnalyzing, lastError, lastAnalysis]);  const retryAnalysis = useCallback(async () => {    if (currentFile) {      return await analyzeProductImageWithHook(currentFile);    }    return null;  }, [currentFile, analyzeProductImageWithHook]);  return {    // ?íƒœ    isAnalyzing,    lastAnalysis,    lastError,    analysisStatus: getAnalysisStatus(),    analysisProgress,    currentFile,        // ?¡ì…˜    analyzeProductImage: analyzeProductImageWithHook,    analyzeMultipleImages: analyzeMultipleImagesWithHook,    clearAnalysis,    retryAnalysis,        // ? í‹¸ë¦¬í‹°    hasAnalysis: !!lastAnalysis,    hasError: !!lastError,    canRetry: !!currentFile && !isAnalyzing,        // ì§„í–‰ë¥??•ë³´    progressPercentage: Math.round(analysisProgress),    isProgressComplete: analysisProgress >= 100,  };}; 