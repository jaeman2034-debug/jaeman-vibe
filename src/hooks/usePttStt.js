"use strict";
// usePttStt.ts - PTT ?�용 STT ??(no-speech ?�동 ?�시???�장)import { useEffect, useMemo, useRef, useState } from "react";function getSR(): any {  return (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;}export function usePttStt(lang = "ko-KR", onResult?: (text: string) => void) {  const [ok, setOk] = useState<boolean>(!!getSR());  const [listening, setListening] = useState(false);  const [partial, setPartial] = useState("");  const [finalText, setFinalText] = useState("");  const pressedRef = useRef(false);  const busyRef = useRef(false);  const recRef = useRef<SpeechRecognition | null>(null);  const restartTimer = useRef<ReturnType<typeof setTimeout> | null>(null);  const micOkRef = useRef(false);  // ???�션 ?�적 버퍼 추�?  const finalPiecesRef = useRef<string[]>([]);  const lastAlternativesRef = useRef<string[]>([]);  const lastPartialRef = useRef("");  useEffect(() => setOk(!!getSR()), []);  // ??버퍼 초기???�수  function resetBuffers() {     finalPiecesRef.current = [];     lastAlternativesRef.current = [];   }  async function ensureMic() {    if (micOkRef.current) return;    try {      await navigator.mediaDevices.getUserMedia({ audio: true });      micOkRef.current = true;    } catch (e) {      alert("마이??권한???�용??주세??");      throw e;    }  }  const makeRec = () => {    const SR: any = getSR();    if (!SR) return null;    const r: SpeechRecognition = new SR();        // ???�식�??�정 강화    r.lang = lang;    r.continuous = true;          // PTT?� ?�께 ?�용    r.interimResults = true;      // ?�시�??�막    r.maxAlternatives = 5;        // ???�?�결과까지 받기(?�락 보정???�용)    r.onresult = (ev: SpeechRecognitionEvent) => {      const res = ev.results[ev.results.length - 1];      const best = res[0]?.transcript?.trim() || "";      const alts: string[] = [];            // ???�??결과 ?�집      for (let i = 0; i < Math.min(res.length, 5); i++) {        const t = res[i]?.transcript?.trim();        if (t) alts.push(t);      }      lastAlternativesRef.current = alts;                // ??마�?�?N-best ?�??      if (res.isFinal) {        if (best) finalPiecesRef.current.push(best);     // ??최종 조각 ?�적        setPartial("");        setFinalText(finalPiecesRef.current.join(" "));      } else {        lastPartialRef.current = best;        setPartial(best);      }      // ?�버�?로그(권장)      console.log("[STT] result:", best, "alternatives:", alts);    };    const restart = () => {      if (!pressedRef.current) return;      if (busyRef.current) return;      if (restartTimer.current) clearTimeout(restartTimer.current);      restartTimer.current = setTimeout(() => {        try { r.start(); } catch {}       }, 120);    };    r.onerror = (e: any) => {       console.warn("[STT] onerror:", e?.error||e);       if (e?.error === "no-speech" || e?.error === "aborted" || e?.error === "invalid-state") restart();     };    r.onend = () => {       setListening(false);       console.log("[STT] onend");       restart();     };    r.onstart = () => {       setListening(true);       console.log("[STT] onstart");     };    return r;  };  const start = () => {    if (!ok || busyRef.current || listening) return;    busyRef.current = true;    pressedRef.current = true;        // ??start() ?�출 ??버퍼 초기??    resetBuffers();        if (!recRef.current) recRef.current = makeRec();    try { recRef.current?.start(); } catch {}     finally { busyRef.current = false; }  };  const stop = () => {    if (busyRef.current) return;    busyRef.current = true;    pressedRef.current = false;    try { recRef.current?.stop(); } catch {}     finally { busyRef.current = false; }    if (restartTimer.current) { clearTimeout(restartTimer.current); restartTimer.current = null; }  };  // ??stop() 직후 ?�시 최종????�� ?�는 기기 ?��? 120ms 지?????�냅??  function snapshotAfterStop(): { final: string; partial: string; alts: string[] } {    return {       final: finalPiecesRef.current.join(" "),       partial: lastPartialRef.current || "",       alts: lastAlternativesRef.current     };  }  const handlers = useMemo(() => {    const onDown = async (e: any) => {      e.preventDefault();      e.stopPropagation();      // 길게?�르�??�래�?방�?: 버튼?�서 ?��? 처리?��?�???�????�전�?      (e.currentTarget as HTMLElement).setPointerCapture?.(e.pointerId);      try { await ensureMic(); } catch { return; }  // ??권한 먼�?      start();      console.log("[PTT] pointerdown");      // ?�역 pointerup?�로�?멈춤 (?�전 메시지??global-up 방식 그�?�??��?)      const target = e.currentTarget as HTMLElement;      const id = e.pointerId;      const onGlobalUp = () => {        console.log("[PTT] global pointerup");        stop();        try { target.releasePointerCapture?.(id); } catch {}         window.removeEventListener("pointerup", onGlobalUp, true);        window.removeEventListener("pointercancel", onGlobalUp, true);        window.removeEventListener("blur", onGlobalUp, true);        document.removeEventListener("visibilitychange", onHide, true);      };      const onHide = () => onGlobalUp();      window.addEventListener("pointerup", onGlobalUp, true);      window.addEventListener("pointercancel", onGlobalUp, true);      window.addEventListener("blur", onGlobalUp, true);      document.addEventListener("visibilitychange", onHide, true);    };    return {      onPointerDown: onDown,      onClick: (e: any) => e.preventDefault(), // click�??�기??�?방�?    };  }, [start, stop]);  return {     ok,     listening,     partial,     finalText,     setFinalText,     handlers,     start,     stop,    snapshotAfterStop  // start/stop�??�께 ?�냅???�수 ?�공  };} 
