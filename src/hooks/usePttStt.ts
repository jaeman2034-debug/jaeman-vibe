// usePttStt.ts - PTT ?„ìš© STT ??(no-speech ?ë™ ?¬ì‹œ???´ì¥)import { useEffect, useMemo, useRef, useState } from "react";function getSR(): any {  return (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;}export function usePttStt(lang = "ko-KR", onResult?: (text: string) => void) {  const [ok, setOk] = useState<boolean>(!!getSR());  const [listening, setListening] = useState(false);  const [partial, setPartial] = useState("");  const [finalText, setFinalText] = useState("");  const pressedRef = useRef(false);  const busyRef = useRef(false);  const recRef = useRef<SpeechRecognition | null>(null);  const restartTimer = useRef<ReturnType<typeof setTimeout> | null>(null);  const micOkRef = useRef(false);  // ???¸ì…˜ ?„ì  ë²„í¼ ì¶”ê?  const finalPiecesRef = useRef<string[]>([]);  const lastAlternativesRef = useRef<string[]>([]);  const lastPartialRef = useRef("");  useEffect(() => setOk(!!getSR()), []);  // ??ë²„í¼ ì´ˆê¸°???¨ìˆ˜  function resetBuffers() {     finalPiecesRef.current = [];     lastAlternativesRef.current = [];   }  async function ensureMic() {    if (micOkRef.current) return;    try {      await navigator.mediaDevices.getUserMedia({ audio: true });      micOkRef.current = true;    } catch (e) {      alert("ë§ˆì´??ê¶Œí•œ???ˆìš©??ì£¼ì„¸??");      throw e;    }  }  const makeRec = () => {    const SR: any = getSR();    if (!SR) return null;    const r: SpeechRecognition = new SR();        // ???¸ì‹ê¸??¤ì • ê°•í™”    r.lang = lang;    r.continuous = true;          // PTT?€ ?¨ê»˜ ?¬ìš©    r.interimResults = true;      // ?¤ì‹œê°??ë§‰    r.maxAlternatives = 5;        // ???€?ˆê²°ê³¼ê¹Œì§€ ë°›ê¸°(?„ë½ ë³´ì •???¬ìš©)    r.onresult = (ev: SpeechRecognitionEvent) => {      const res = ev.results[ev.results.length - 1];      const best = res[0]?.transcript?.trim() || "";      const alts: string[] = [];            // ???€??ê²°ê³¼ ?˜ì§‘      for (let i = 0; i < Math.min(res.length, 5); i++) {        const t = res[i]?.transcript?.trim();        if (t) alts.push(t);      }      lastAlternativesRef.current = alts;                // ??ë§ˆì?ë§?N-best ?€??      if (res.isFinal) {        if (best) finalPiecesRef.current.push(best);     // ??ìµœì¢… ì¡°ê° ?„ì         setPartial("");        setFinalText(finalPiecesRef.current.join(" "));      } else {        lastPartialRef.current = best;        setPartial(best);      }      // ?”ë²„ê·?ë¡œê·¸(ê¶Œì¥)      console.log("[STT] result:", best, "alternatives:", alts);    };    const restart = () => {      if (!pressedRef.current) return;      if (busyRef.current) return;      if (restartTimer.current) clearTimeout(restartTimer.current);      restartTimer.current = setTimeout(() => {        try { r.start(); } catch {}       }, 120);    };    r.onerror = (e: any) => {       console.warn("[STT] onerror:", e?.error||e);       if (e?.error === "no-speech" || e?.error === "aborted" || e?.error === "invalid-state") restart();     };    r.onend = () => {       setListening(false);       console.log("[STT] onend");       restart();     };    r.onstart = () => {       setListening(true);       console.log("[STT] onstart");     };    return r;  };  const start = () => {    if (!ok || busyRef.current || listening) return;    busyRef.current = true;    pressedRef.current = true;        // ??start() ?¸ì¶œ ??ë²„í¼ ì´ˆê¸°??    resetBuffers();        if (!recRef.current) recRef.current = makeRec();    try { recRef.current?.start(); } catch {}     finally { busyRef.current = false; }  };  const stop = () => {    if (busyRef.current) return;    busyRef.current = true;    pressedRef.current = false;    try { recRef.current?.stop(); } catch {}     finally { busyRef.current = false; }    if (restartTimer.current) { clearTimeout(restartTimer.current); restartTimer.current = null; }  };  // ??stop() ì§í›„ ?¹ì‹œ ìµœì¢…????²Œ ?¤ëŠ” ê¸°ê¸° ?€ë¹? 120ms ì§€?????¤ëƒ…??  function snapshotAfterStop(): { final: string; partial: string; alts: string[] } {    return {       final: finalPiecesRef.current.join(" "),       partial: lastPartialRef.current || "",       alts: lastAlternativesRef.current     };  }  const handlers = useMemo(() => {    const onDown = async (e: any) => {      e.preventDefault();      e.stopPropagation();      // ê¸¸ê²Œ?„ë¥´ê¸??œë˜ê·?ë°©ì?: ë²„íŠ¼?ì„œ ?´ë? ì²˜ë¦¬?ˆì?ë§???ë²????ˆì „ë§?      (e.currentTarget as HTMLElement).setPointerCapture?.(e.pointerId);      try { await ensureMic(); } catch { return; }  // ??ê¶Œí•œ ë¨¼ì?      start();      console.log("[PTT] pointerdown");      // ?„ì—­ pointerup?¼ë¡œë§?ë©ˆì¶¤ (?´ì „ ë©”ì‹œì§€??global-up ë°©ì‹ ê·¸ë?ë¡?? ì?)      const target = e.currentTarget as HTMLElement;      const id = e.pointerId;      const onGlobalUp = () => {        console.log("[PTT] global pointerup");        stop();        try { target.releasePointerCapture?.(id); } catch {}         window.removeEventListener("pointerup", onGlobalUp, true);        window.removeEventListener("pointercancel", onGlobalUp, true);        window.removeEventListener("blur", onGlobalUp, true);        document.removeEventListener("visibilitychange", onHide, true);      };      const onHide = () => onGlobalUp();      window.addEventListener("pointerup", onGlobalUp, true);      window.addEventListener("pointercancel", onGlobalUp, true);      window.addEventListener("blur", onGlobalUp, true);      document.addEventListener("visibilitychange", onHide, true);    };    return {      onPointerDown: onDown,      onClick: (e: any) => e.preventDefault(), // clickë¡??Šê¸°??ê²?ë°©ì?    };  }, [start, stop]);  return {     ok,     listening,     partial,     finalText,     setFinalText,     handlers,     start,     stop,    snapshotAfterStop  // start/stopê³??¨ê»˜ ?¤ëƒ…???¨ìˆ˜ ?œê³µ  };} 