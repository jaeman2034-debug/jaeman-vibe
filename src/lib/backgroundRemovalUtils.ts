// src/lib/backgroundRemovalUtils.ts// Î∞∞Í≤Ω ?úÍ±∞(?µÏÖò) + Î¶¨ÏÇ¨?¥Ï¶à + Í∞ÑÎã® ?àÏßà ?êÏàòexport type BackgroundRemovalOptions = {  quality?: number;  outputFormat?: string;};export type BackgroundRemovalResult = {  success: boolean;  blob?: Blob;  error?: string;};type ResizeOpts = { maxW?: number; maxH?: number; quality?: number };function makeCanvas(w: number, h: number): OffscreenCanvas | HTMLCanvasElement {  if (typeof OffscreenCanvas !== 'undefined') return new OffscreenCanvas(w, h);  const c = document.createElement('canvas');  c.width = w; c.height = h;  return c;}async function canvasToFile(  canvas: OffscreenCanvas | HTMLCanvasElement,  name: string,  type: string,  quality = 0.9): Promise<File> {  if ('convertToBlob' in canvas) {    const blob = await (canvas as OffscreenCanvas).convertToBlob({ type, quality });    return new File([blob], name, { type });  }  return new Promise<File>((resolve) => {    (canvas as HTMLCanvasElement).toBlob((blob) => {      resolve(new File([blob!], name, { type }));    }, type, quality);  });}async function fileToImage(file: File): Promise<HTMLImageElement> {  const url = URL.createObjectURL(file);  try {    const img = new Image();    img.decoding = 'async';    img.src = url;    await img.decode();    return img;  } finally {    // revoke??Í∑∏Î¶¨Í∏??¥ÌõÑ???¥ÎèÑ Î¨¥Î∞©  }}/** (?†ÌÉù) Î∞∞Í≤Ω ?úÍ±∞. ?ºÏù¥Î∏åÎü¨Î¶??ÜÏúºÎ©??êÎ≥∏??Í∑∏Î?Î°??¨Ïö© */async function tryRemoveBackground(file: File): Promise<ImageBitmap | HTMLImageElement> {  try {    // ?®ÌÇ§ÏßÄÎ•??§Ïπò?àÎã§Î©??ôÏûë?©Îãà??    //   npm i @imgly/background-removal    //   (?êÎäî onnxruntime-web Í∏∞Î∞ò ?§Î•∏ Íµ¨ÌòÑ)    // ?? createWorker ??worker.removeBackground(image)    const mod: any = await import('@imgly/background-removal');    const worker = await (mod.createWorker ? mod.createWorker() : null);    if (worker?.removeBackground) {      const img = await fileToImage(file);      const blob: Blob = await worker.removeBackground(img);      return await createImageBitmap(await blob.arrayBuffer().then((b)=>new Blob([b])));    }  } catch {    /* ?ºÏù¥Î∏åÎü¨Î¶??ÜÏúºÎ©?Î¨¥Ïãú?òÍ≥† ?êÎ≥∏ ?¨Ïö© */  }  // fallback: ?êÎ≥∏ ?¥Î?ÏßÄ  const img = await fileToImage(file);  return img;}/** Î∞∞Í≤Ω ?úÍ±∞(Í∞Ä?•ÌïòÎ©? ??Î¶¨ÏÇ¨?¥Ï¶à+?πÌîÑ Î≥Ä??*/export async function removeBackgroundAndResize(  file: File,  opts: ResizeOpts = {},  resizeOptions?: { maxWidth: number; maxHeight: number; quality: number }): Promise<BackgroundRemovalResult> {  try {    const maxW = resizeOptions?.maxWidth ?? opts.maxW ?? 1600;    const maxH = resizeOptions?.maxHeight ?? opts.maxH ?? 1600;    const q = resizeOptions?.quality ?? opts.quality ?? 0.86;    const img = await tryRemoveBackground(file);    const w = (img as any).width, h = (img as any).height;    const scale = Math.min(maxW / w, maxH / h, 1);    const nw = Math.round(w * scale), nh = Math.round(h * scale);    const canvas = makeCanvas(nw, nh);    const ctx = (canvas as any).getContext('2d') as CanvasRenderingContext2D;    ctx.clearRect(0, 0, nw, nh);    ctx.drawImage(img as any, 0, 0, nw, nh);    const name = file.name.replace(/\.\w+$/, '.webp');    const resultFile = await canvasToFile(canvas, name, 'image/webp', q);        return {      success: true,      blob: resultFile    };  } catch (error) {    return {      success: false,      error: error instanceof Error ? error.message : '?????ÜÎäî ?§Î•ò'    };  }}/** Í∞ÑÎã® ?àÏßà ?êÏàò(0~1): Î∞ùÍ∏∞ ?ÅÏ†ï + ?ÄÎπ??†Î™Ö??Í∑ºÏÇ¨ */export async function calculateImageQuality(file: File): Promise<number> {  try {    const img = await fileToImage(file);    const w = 256, h = Math.max(1, Math.round((img.height / img.width) * 256));    const canvas = makeCanvas(w, h);    const ctx = (canvas as any).getContext('2d') as CanvasRenderingContext2D;    ctx.drawImage(img, 0, 0, w, h);    const data = ctx.getImageData(0, 0, w, h).data;    let sum = 0, sumSq = 0;    for (let i = 0; i < data.length; i += 4) {      const lum = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];      sum += lum; sumSq += lum * lum;    }    const n = data.length / 4;    const mean = sum / n;                   // 0..255    const variance = Math.max(0, sumSq / n - mean * mean); // ?ÄÎπ??†Î™Ö??Í∑ºÏÇ¨    // ?∏Ï∂ú ?êÏàò: 128 Í∑ºÏ≤òÍ∞Ä ÏµúÍ≥†    const exposure = 1 - Math.min(1, Math.abs(mean - 128) / 128);    // ?†Î™Ö???êÏàò: 50~2000 Î≤îÏúÑ ?§Ï??ºÎßÅ (Í≤ΩÌóòÍ∞?    const sharp = Math.max(0, Math.min(1, (variance - 50) / 1950));    return Math.max(0, Math.min(1, (exposure * 0.5 + sharp * 0.5)));  } catch (error) {    console.error('?¥Î?ÏßÄ ?àÏßà Í≥ÑÏÇ∞ ?§Ìå®:', error);    return 0.5; // Í∏∞Î≥∏Í∞?  }}/** (?µÏÖò) ?®Ïàú Î¶¨ÏÇ¨?¥Ï¶àÎß??ÑÏöî????*/export async function resizeImage(  file: File, maxW = 1600, maxH = 1600, q = 0.86): Promise<File> {  const img = await fileToImage(file);  const scale = Math.min(maxW / img.width, maxH / img.height, 1);  const nw = Math.round(img.width * scale), nh = Math.round(img.height * scale);  const canvas = makeCanvas(nw, nh);  const ctx = (canvas as any).getContext('2d') as CanvasRenderingContext2D;  ctx.drawImage(img, 0, 0, nw, nh);  const name = file.name.replace(/\.\w+$/, '.webp');  return canvasToFile(canvas, name, 'image/webp', q);}/** ?¥Î?ÏßÄ ?¨Îß∑ Î≥Ä??(WebP, AVIF ÏßÄ?? */export async function convertImageFormat(  file: File,  format: 'webp' | 'avif' | 'jpeg' | 'png',  quality = 0.9): Promise<File> {  const img = await fileToImage(file);  const canvas = makeCanvas(img.width, img.height);  const ctx = (canvas as any).getContext('2d') as CanvasRenderingContext2D;    ctx.drawImage(img, 0, 0);    let mimeType: string;  switch (format) {    case 'webp':      mimeType = 'image/webp';      break;    case 'avif':      mimeType = 'image/avif';      break;    case 'jpeg':      mimeType = 'image/jpeg';      break;    case 'png':      mimeType = 'image/png';      quality = 1; // PNG???àÏßà ?§Ï†ï Î∂àÍ?      break;    default:      mimeType = 'image/webp';  }    const name = file.name.replace(/\.\w+$/, `.${format}`);  return canvasToFile(canvas, name, mimeType, quality);}/** ?¥Î?ÏßÄ Î©îÌ??∞Ïù¥??Ï∂îÏ∂ú */export async function extractImageMetadata(file: File): Promise<{  width: number;  height: number;  size: number;  type: string;  lastModified: number;}> {  const img = await fileToImage(file);    return {    width: img.naturalWidth,    height: img.naturalHeight,    size: file.size,    type: file.type,    lastModified: file.lastModified  };} 
