export type AdminAddress = {  sido: string;      // ?œìš¸?¹ë³„??  sigungu: string;   // ê°•ë‚¨êµ?  dong: string;      // ??‚¼1??  full: string;      // ?œìš¸?¹ë³„??ê°•ë‚¨êµ???‚¼1??};export async function reverseGeocodeDong(lat: number, lng: number): Promise<AdminAddress> {  const key = import.meta.env.VITE_KAKAO_REST_KEY;        // Kakao REST API Key  const r = await fetch(`/kakao/v2/local/geo/coord2regioncode.json?x=${lng}&y=${lat}`, {    headers: { Authorization: `KakaoAK ${key}` },  });  if (!r.ok) throw new Error('Kakao reverse geocode failed');  const { documents } = await r.json();  const dongDoc = documents.find((d: any) => d.region_type === 'H') ?? documents[0];  const { region_1depth_name: sido, region_2depth_name: sigungu, region_3depth_name: dong } = dongDoc || {};  return { sido, sigungu, dong, full: `${sido} ${sigungu} ${dong}` };}// ê±°ë¦¬ ê³„ì‚°/?œì‹œ ? í‹¸(?•í™•Â·ê°„ê²°)export function distanceMeters(a:{lat:number; lng:number}, b:{lat:number; lng:number}) {  const R=6371000, toRad=(x:number)=>x*Math.PI/180;  const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);  const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);  const A=s1*s1+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;  return 2*R*Math.asin(Math.sqrt(A));}export function formatDistanceKm(m:number) {  if (m < 1000) return `${Math.round(m/10)*10}m`;  const km = m/1000;  return `${km.toFixed(km<10?1:0)}km`;}