import { geohashQueryBounds, distanceBetween } from 'geofire-common';import { collection, getDocs, orderBy, query, startAt, endAt, limit } from 'firebase/firestore';import { db } from '@/lib/firebase';import type { MarketItem } from '@/features/market/types';export interface NearbySearchResult extends MarketItem {  _dist: number; // 거리 (m ?�위)}/** * ?�정 ?�치 기�??�로 반경 ???�품 검?? * @param lat ?�도 * @param lng 경도 * @param radiusInM 반경 (미터 ?�위, 기본�? 5000m = 5km) * @returns 거리?�으�??�렬???�품 목록 */export async function searchNearby(  lat: number,   lng: number,   radiusInM: number = 5000): Promise<NearbySearchResult[]> {  // geohash 기반 쿼리 범위 계산  const bounds = geohashQueryBounds([lat, lng], radiusInM);  const col = collection(db, 'market');  const results: any[] = [];  // geohash 범위�?쿼리 ???�치�?  await Promise.all(bounds.map(async (b) => {    try {      const q = query(        col,         orderBy('geo.geohash'),         startAt(b[0]),         endAt(b[1]),         limit(50)      );      const snap = await getDocs(q);      snap.docs.forEach(d => {        const data = d.data();        // geo ?�드가 ?�는 ?�품�??�함        if (data.geo && data.geo.lat && data.geo.lng) {          results.push({ id: d.id, ...data });        }      });    } catch (error) {      console.warn('geohash 쿼리 ?�패:', error);      // 개별 쿼리 ?�패 ??계속 진행    }  }));  // ??�??�거 + 거리 계산/?�렬  return results    .map(r => ({      ...r,      _dist: distanceBetween([lat, lng], [r.geo?.lat, r.geo?.lng]) * 1000 // km -> m 변??    }))    .filter(r => isFinite(r._dist) && r._dist <= radiusInM) // 반경 ???�품�??�터�?    .sort((a, b) => a._dist - b._dist); // 거리???�렬}/** * ?�정 카테고리 ?�에??반경 검?? */export async function searchNearbyByCategory(  lat: number,  lng: number,  category: string,  radiusInM: number = 5000): Promise<NearbySearchResult[]> {  const allResults = await searchNearby(lat, lng, radiusInM);  return allResults.filter(item => item.category === category);}/** * 가�?범위 ?�에??반경 검?? */export async function searchNearbyByPrice(  lat: number,  lng: number,  minPrice: number,  maxPrice: number,  radiusInM: number = 5000): Promise<NearbySearchResult[]> {  const allResults = await searchNearby(lat, lng, radiusInM);  return allResults.filter(item =>     item.price >= minPrice && item.price <= maxPrice  );}/** * 복합 조건?�로 반경 검?? */export async function searchNearbyAdvanced(  lat: number,  lng: number,  options: {    radiusInM?: number;    category?: string;    minPrice?: number;    maxPrice?: number;    status?: 'active' | 'reserved' | 'sold';    maxResults?: number;  } = {}): Promise<NearbySearchResult[]> {  const {    radiusInM = 5000,    category,    minPrice,    maxPrice,    status = 'active',    maxResults = 100  } = options;  let results = await searchNearby(lat, lng, radiusInM);  // 카테고리 ?�터�?  if (category) {    results = results.filter(item => item.category === category);  }  // 가�?범위 ?�터�?  if (minPrice !== undefined || maxPrice !== undefined) {    results = results.filter(item => {      if (minPrice !== undefined && item.price < minPrice) return false;      if (maxPrice !== undefined && item.price > maxPrice) return false;      return true;    });  }  // ?�태 ?�터�?  if (status) {    results = results.filter(item => item.status === status);  }  // 결과 ???�한  if (maxResults) {    results = results.slice(0, maxResults);  }  return results;}// 추�? ?�틸리티 ?�수??export function calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {  return distanceBetween([lat1, lng1], [lat2, lng2]) * 1000; // 미터 ?�위�?변??}export function formatDistance(meters: number): string {  if (meters < 1000) {    return `${Math.round(meters)}m`;  } else {    return `${(meters / 1000).toFixed(1)}km`;  }}export function getCurrentLocation(): Promise<{ lat: number; lng: number }> {  return new Promise((resolve, reject) => {    if (!navigator.geolocation) {      reject(new Error('Geolocation is not supported'));      return;    }    navigator.geolocation.getCurrentPosition(      (position) => {        resolve({          lat: position.coords.latitude,          lng: position.coords.longitude        });      },      (error) => {        reject(error);      },      {        enableHighAccuracy: true,        timeout: 10000,        maximumAge: 60000      }    );  });} 
