import { geohashQueryBounds, distanceBetween } from 'geofire-common';import { collection, getDocs, orderBy, query, startAt, endAt, limit } from 'firebase/firestore';import { db } from '@/lib/firebase';import type { MarketItem } from '@/features/market/types';export interface NearbySearchResult extends MarketItem {  _dist: number; // ê±°ë¦¬ (m ?¨ìœ„)}/** * ?¹ì • ?„ì¹˜ ê¸°ì??¼ë¡œ ë°˜ê²½ ???í’ˆ ê²€?? * @param lat ?„ë„ * @param lng ê²½ë„ * @param radiusInM ë°˜ê²½ (ë¯¸í„° ?¨ìœ„, ê¸°ë³¸ê°? 5000m = 5km) * @returns ê±°ë¦¬?œìœ¼ë¡??•ë ¬???í’ˆ ëª©ë¡ */export async function searchNearby(  lat: number,   lng: number,   radiusInM: number = 5000): Promise<NearbySearchResult[]> {  // geohash ê¸°ë°˜ ì¿¼ë¦¬ ë²”ìœ„ ê³„ì‚°  const bounds = geohashQueryBounds([lat, lng], radiusInM);  const col = collection(db, 'market_items');  const results: any[] = [];  // geohash ë²”ìœ„ë³?ì¿¼ë¦¬ ???©ì¹˜ê¸?  await Promise.all(bounds.map(async (b) => {    try {      const q = query(        col,         orderBy('geo.geohash'),         startAt(b[0]),         endAt(b[1]),         limit(50)      );      const snap = await getDocs(q);      snap.docs.forEach(d => {        const data = d.data();        // geo ?„ë“œê°€ ?ˆëŠ” ?í’ˆë§??¬í•¨        if (data.geo && data.geo.lat && data.geo.lng) {          results.push({ id: d.id, ...data });        }      });    } catch (error) {      console.warn('geohash ì¿¼ë¦¬ ?¤íŒ¨:', error);      // ê°œë³„ ì¿¼ë¦¬ ?¤íŒ¨ ??ê³„ì† ì§„í–‰    }  }));  // ??ë°??œê±° + ê±°ë¦¬ ê³„ì‚°/?•ë ¬  return results    .map(r => ({      ...r,      _dist: distanceBetween([lat, lng], [r.geo?.lat, r.geo?.lng]) * 1000 // km -> m ë³€??    }))    .filter(r => isFinite(r._dist) && r._dist <= radiusInM) // ë°˜ê²½ ???í’ˆë§??„í„°ë§?    .sort((a, b) => a._dist - b._dist); // ê±°ë¦¬???•ë ¬}/** * ?¹ì • ì¹´í…Œê³ ë¦¬ ?´ì—??ë°˜ê²½ ê²€?? */export async function searchNearbyByCategory(  lat: number,  lng: number,  category: string,  radiusInM: number = 5000): Promise<NearbySearchResult[]> {  const allResults = await searchNearby(lat, lng, radiusInM);  return allResults.filter(item => item.category === category);}/** * ê°€ê²?ë²”ìœ„ ?´ì—??ë°˜ê²½ ê²€?? */export async function searchNearbyByPrice(  lat: number,  lng: number,  minPrice: number,  maxPrice: number,  radiusInM: number = 5000): Promise<NearbySearchResult[]> {  const allResults = await searchNearby(lat, lng, radiusInM);  return allResults.filter(item =>     item.price >= minPrice && item.price <= maxPrice  );}/** * ë³µí•© ì¡°ê±´?¼ë¡œ ë°˜ê²½ ê²€?? */export async function searchNearbyAdvanced(  lat: number,  lng: number,  options: {    radiusInM?: number;    category?: string;    minPrice?: number;    maxPrice?: number;    status?: 'active' | 'reserved' | 'sold';    maxResults?: number;  } = {}): Promise<NearbySearchResult[]> {  const {    radiusInM = 5000,    category,    minPrice,    maxPrice,    status = 'active',    maxResults = 100  } = options;  let results = await searchNearby(lat, lng, radiusInM);  // ì¹´í…Œê³ ë¦¬ ?„í„°ë§?  if (category) {    results = results.filter(item => item.category === category);  }  // ê°€ê²?ë²”ìœ„ ?„í„°ë§?  if (minPrice !== undefined || maxPrice !== undefined) {    results = results.filter(item => {      if (minPrice !== undefined && item.price < minPrice) return false;      if (maxPrice !== undefined && item.price > maxPrice) return false;      return true;    });  }  // ?íƒœ ?„í„°ë§?  if (status) {    results = results.filter(item => item.status === status);  }  // ê²°ê³¼ ???œí•œ  if (maxResults) {    results = results.slice(0, maxResults);  }  return results;}// ì¶”ê? ? í‹¸ë¦¬í‹° ?¨ìˆ˜??export function calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {  return distanceBetween([lat1, lng1], [lat2, lng2]) * 1000; // ë¯¸í„° ?¨ìœ„ë¡?ë³€??}export function formatDistance(meters: number): string {  if (meters < 1000) {    return `${Math.round(meters)}m`;  } else {    return `${(meters / 1000).toFixed(1)}km`;  }}export function getCurrentLocation(): Promise<{ lat: number; lng: number }> {  return new Promise((resolve, reject) => {    if (!navigator.geolocation) {      reject(new Error('Geolocation is not supported'));      return;    }    navigator.geolocation.getCurrentPosition(      (position) => {        resolve({          lat: position.coords.latitude,          lng: position.coords.longitude        });      },      (error) => {        reject(error);      },      {        enableHighAccuracy: true,        timeout: 10000,        maximumAge: 60000      }    );  });} 