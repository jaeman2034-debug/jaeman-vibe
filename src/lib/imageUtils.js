/** * ?��?지 ?�처�??�틸리티 * 리사?�즈, ?�축, WebP 변???�을 지?�합?�다. */ /** * ?��?지 리사?�즈 �??�축 * @param file ?�본 ?��?지 ?�일 * @param maxW 최�? ?�비 (기본�? 1600px) * @param maxH 최�? ?�이 (기본�? 1600px) * @param q ?�질 (0.0 ~ 1.0, 기본�? 0.86) * @returns 처리??WebP ?��?지 ?�일 */ export async function resizeImage(file, maxW = 1600, maxH = 1600, q = 0.86) { try { }
finally { } } // ImageBitmap ?�성    const img = await createImageBitmap(file);        // ?��???계산 (?�본보다 ?�게 ?��? ?�음)    const scale = Math.min(maxW / img.width, maxH / img.height, 1);    const w = Math.round(img.width * scale);    const h = Math.round(img.height * scale);        // OffscreenCanvas ?�용 (메인 ?�레??블로??방�?)    const canvas = new OffscreenCanvas(w, h);    const ctx = canvas.getContext('2d')!;        // ?��?지 그리�?    ctx.drawImage(img, 0, 0, w, h);        // WebP�?변??�??�축    const blob = await canvas.convertToBlob({       type: 'image/webp',       quality: q     });        // ?�일명을 .webp�?변�?    const newFileName = file.name.replace(/\.\w+$/, '.webp');        return new File([blob], newFileName, { type: 'image/webp' });      } catch (error) {    console.error('?��?지 리사?�즈 ?�패:', error);    throw new Error('?��?지 처리 �??�류가 발생?�습?�다.');  }}/** * ?��?지 ?�질 체크 (Laplacian variance 기반) * @param file ?��?지 ?�일 * @returns ?�질 ?�수 (0.0 ~ 1.0) */export async function checkImageQuality(file: File): Promise<number> {  try {    const img = await createImageBitmap(file);    const canvas = new OffscreenCanvas(img.width, img.height);    const ctx = canvas.getContext('2d')!;        // ?��?지�?캔버?�에 그리�?    ctx.drawImage(img, 0, 0);        // ?��?지 ?�이??추출    const imageData = ctx.getImageData(0, 0, img.width, img.height);    const data = imageData.data;        // 그레?�스케??변??�?Laplacian ?�터 ?�용    let variance = 0;    let count = 0;        for (let y = 1; y < img.height - 1; y++) {      for (let x = 1; x < img.width - 1; x++) {        const idx = (y * img.width + x) * 4;                // 그레?�스케??�?계산        const gray = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;                // Laplacian ?�터 ?�용        const laplacian = Math.abs(          gray -           (data[idx - 4] * 0.299 + data[idx - 3] * 0.587 + data[idx - 2] * 0.114) -          (data[idx + 4] * 0.299 + data[idx + 3] * 0.587 + data[idx + 2] * 0.114) -          (data[(y - 1) * img.width * 4 + x * 4] * 0.299 +            data[(y - 1) * img.width * 4 + x * 4 + 1] * 0.587 +            data[(y - 1) * img.width * 4 + x * 4 + 2] * 0.114) -          (data[(y + 1) * img.width * 4 + x * 4] * 0.299 +            data[(y + 1) * img.width * 4 + x * 4 + 1] * 0.587 +            data[(y + 1) * img.width * 4 + x * 4 + 2] * 0.114)        );                variance += laplacian * laplacian;        count++;      }    }        // ?�균 분산 계산    const avgVariance = variance / count;        // ?�질 ?�수 ?�규??(0.0 ~ 1.0)    // ?��? 분산 = ?�명???��?지 = ?��? ?�질    const quality = Math.min(avgVariance / 1000, 1.0);        return quality;      } catch (error) {    console.error('?��?지 ?�질 체크 ?�패:', error);    return 0.5; // 기본�?  }}/** * ?��?지 메�??�이??추출 * @param file ?��?지 ?�일 * @returns ?��?지 메�??�이?? */export async function getImageMetadata(file: File): Promise<{  width: number;  height: number;  aspectRatio: number;  fileSize: number;  type: string;}> {  try {    const img = await createImageBitmap(file);        return {      width: img.width,      height: img.height,      aspectRatio: img.width / img.height,      fileSize: file.size,      type: file.type    };      } catch (error) {    console.error('?��?지 메�??�이??추출 ?�패:', error);    throw new Error('?��?지 ?�보�??�을 ???�습?�다.');  }}/** * ?��?지 배경 ?�거 (간단???��??�이?? * @param file ?��?지 ?�일 * @returns 배경???�거???��?지 ?�일 */export async function removeBackground(file: File): Promise<File> {  try {    // ?�제로는 AI 모델???�용?�야 ?��?�? ?�기?�는 ?��??�이??    const img = await createImageBitmap(file);    const canvas = new OffscreenCanvas(img.width, img.height);    const ctx = canvas.getContext('2d')!;        // ?�본 ?��?지 그리�?    ctx.drawImage(img, 0, 0);        // 간단??배경 ?�거 ?��??�이??(?�제로는 AI 모델 ?�용)    // ?�기?�는 ?�명?�만 조정    const imageData = ctx.getImageData(0, 0, img.width, img.height);    const data = imageData.data;        for (let i = 0; i < data.length; i += 4) {      // 밝�? ?��????�명?�게 만들�?(간단???��??�이??      const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;      if (brightness > 240) {        data[i + 3] = 0; // ?�명??0      }    }        ctx.putImageData(imageData, 0, 0);        // PNG�?변??(?�명??지??    const blob = await canvas.convertToBlob({       type: 'image/png'    });        const newFileName = file.name.replace(/\.\w+$/, '.png');    return new File([blob], newFileName, { type: 'image/png' });      } catch (error) {    console.error('배경 ?�거 ?�패:', error);    throw new Error('배경 ?�거 �??�류가 발생?�습?�다.');  }}/** * ?��?지 ?�터 ?�용 * @param file ?��?지 ?�일 * @param filter ?�터 ?�?? * @returns ?�터가 ?�용???��?지 ?�일 */export async function applyImageFilter(  file: File,   filter: 'grayscale' | 'sepia' | 'blur' | 'sharpen'): Promise<File> {  try {    const img = await createImageBitmap(file);    const canvas = new OffscreenCanvas(img.width, img.height);    const ctx = canvas.getContext('2d')!;        // ?�본 ?��?지 그리�?    ctx.drawImage(img, 0, 0);        // ?�터 ?�용    switch (filter) {      case 'grayscale':        ctx.filter = 'grayscale(100%)';        break;      case 'sepia':        ctx.filter = 'sepia(100%)';        break;      case 'blur':        ctx.filter = 'blur(2px)';        break;      case 'sharpen':        ctx.filter = 'contrast(150%) saturate(150%)';        break;    }        // ?�터 ?�용???��?지 ?�시 그리�?    ctx.drawImage(canvas, 0, 0);        // WebP�?변??    const blob = await canvas.convertToBlob({       type: 'image/webp',       quality: 0.9     });        const newFileName = file.name.replace(/\.\w+$/, `-${filter}.webp`);    return new File([blob], newFileName, { type: 'image/webp' });      } catch (error) {    console.error('?��?지 ?�터 ?�용 ?�패:', error);    throw new Error('?�터 ?�용 �??�류가 발생?�습?�다.');  }}/** * ?��?지 ?�롭 * @param file ?��?지 ?�일 * @param x ?�작 X 좌표 * @param y ?�작 Y 좌표 * @param width ?�롭???�비 * @param height ?�롭???�이 * @returns ?�롭???��?지 ?�일 */export async function cropImage(  file: File,  x: number,  y: number,  width: number,  height: number): Promise<File> {  try {    const img = await createImageBitmap(file);    const canvas = new OffscreenCanvas(width, height);    const ctx = canvas.getContext('2d')!;        // 지?�된 ?�역�?그리�?    ctx.drawImage(img, x, y, width, height, 0, 0, width, height);        // WebP�?변??    const blob = await canvas.convertToBlob({       type: 'image/webp',       quality: 0.9     });        const newFileName = file.name.replace(/\.\w+$/, '-cropped.webp');    return new File([blob], newFileName, { type: 'image/webp' });      } catch (error) {    console.error('?��?지 ?�롭 ?�패:', error);    throw new Error('?��?지 ?�롭 �??�류가 발생?�습?�다.');  }}/** * ?��?지 ?�축�?계산 * @param originalSize ?�본 ?�일 ?�기 (bytes) * @param compressedSize ?�축???�일 ?�기 (bytes) * @returns ?�축�?(0.0 ~ 1.0) */export function calculateCompressionRatio(originalSize: number, compressedSize: number): number {  if (originalSize === 0) return 0;  return (originalSize - compressedSize) / originalSize;}/** * ?�일 ?�기 ?�맷?? * @param bytes 바이???�위 ?�기 * @returns ?�맷???�기 문자?? */export function formatFileSize(bytes: number): string {  if (bytes === 0) return '0 Bytes';    const k = 1024;  const sizes = ['Bytes', 'KB', 'MB', 'GB'];  const i = Math.floor(Math.log(bytes) / Math.log(k));    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];} 
