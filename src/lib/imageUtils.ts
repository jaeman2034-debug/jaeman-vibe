/** * ?´ë?ì§€ ?„ì²˜ë¦?? í‹¸ë¦¬í‹° * ë¦¬ì‚¬?´ì¦ˆ, ?•ì¶•, WebP ë³€???±ì„ ì§€?í•©?ˆë‹¤. *//** * ?´ë?ì§€ ë¦¬ì‚¬?´ì¦ˆ ë°??•ì¶• * @param file ?ë³¸ ?´ë?ì§€ ?Œì¼ * @param maxW ìµœë? ?ˆë¹„ (ê¸°ë³¸ê°? 1600px) * @param maxH ìµœë? ?’ì´ (ê¸°ë³¸ê°? 1600px) * @param q ?ˆì§ˆ (0.0 ~ 1.0, ê¸°ë³¸ê°? 0.86) * @returns ì²˜ë¦¬??WebP ?´ë?ì§€ ?Œì¼ */export async function resizeImage(  file: File,   maxW: number = 1600,   maxH: number = 1600,   q: number = 0.86): Promise<File> {  try {    // ImageBitmap ?ì„±    const img = await createImageBitmap(file);        // ?¤ì???ê³„ì‚° (?ë³¸ë³´ë‹¤ ?¬ê²Œ ?˜ì? ?ŠìŒ)    const scale = Math.min(maxW / img.width, maxH / img.height, 1);    const w = Math.round(img.width * scale);    const h = Math.round(img.height * scale);        // OffscreenCanvas ?¬ìš© (ë©”ì¸ ?¤ë ˆ??ë¸”ë¡œ??ë°©ì?)    const canvas = new OffscreenCanvas(w, h);    const ctx = canvas.getContext('2d')!;        // ?´ë?ì§€ ê·¸ë¦¬ê¸?    ctx.drawImage(img, 0, 0, w, h);        // WebPë¡?ë³€??ë°??•ì¶•    const blob = await canvas.convertToBlob({       type: 'image/webp',       quality: q     });        // ?Œì¼ëª…ì„ .webpë¡?ë³€ê²?    const newFileName = file.name.replace(/\.\w+$/, '.webp');        return new File([blob], newFileName, { type: 'image/webp' });      } catch (error) {    console.error('?´ë?ì§€ ë¦¬ì‚¬?´ì¦ˆ ?¤íŒ¨:', error);    throw new Error('?´ë?ì§€ ì²˜ë¦¬ ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.');  }}/** * ?´ë?ì§€ ?ˆì§ˆ ì²´í¬ (Laplacian variance ê¸°ë°˜) * @param file ?´ë?ì§€ ?Œì¼ * @returns ?ˆì§ˆ ?ìˆ˜ (0.0 ~ 1.0) */export async function checkImageQuality(file: File): Promise<number> {  try {    const img = await createImageBitmap(file);    const canvas = new OffscreenCanvas(img.width, img.height);    const ctx = canvas.getContext('2d')!;        // ?´ë?ì§€ë¥?ìº”ë²„?¤ì— ê·¸ë¦¬ê¸?    ctx.drawImage(img, 0, 0);        // ?´ë?ì§€ ?°ì´??ì¶”ì¶œ    const imageData = ctx.getImageData(0, 0, img.width, img.height);    const data = imageData.data;        // ê·¸ë ˆ?´ìŠ¤ì¼€??ë³€??ë°?Laplacian ?„í„° ?ìš©    let variance = 0;    let count = 0;        for (let y = 1; y < img.height - 1; y++) {      for (let x = 1; x < img.width - 1; x++) {        const idx = (y * img.width + x) * 4;                // ê·¸ë ˆ?´ìŠ¤ì¼€??ê°?ê³„ì‚°        const gray = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;                // Laplacian ?„í„° ?ìš©        const laplacian = Math.abs(          gray -           (data[idx - 4] * 0.299 + data[idx - 3] * 0.587 + data[idx - 2] * 0.114) -          (data[idx + 4] * 0.299 + data[idx + 3] * 0.587 + data[idx + 2] * 0.114) -          (data[(y - 1) * img.width * 4 + x * 4] * 0.299 +            data[(y - 1) * img.width * 4 + x * 4 + 1] * 0.587 +            data[(y - 1) * img.width * 4 + x * 4 + 2] * 0.114) -          (data[(y + 1) * img.width * 4 + x * 4] * 0.299 +            data[(y + 1) * img.width * 4 + x * 4 + 1] * 0.587 +            data[(y + 1) * img.width * 4 + x * 4 + 2] * 0.114)        );                variance += laplacian * laplacian;        count++;      }    }        // ?‰ê·  ë¶„ì‚° ê³„ì‚°    const avgVariance = variance / count;        // ?ˆì§ˆ ?ìˆ˜ ?•ê·œ??(0.0 ~ 1.0)    // ?’ì? ë¶„ì‚° = ? ëª…???´ë?ì§€ = ?’ì? ?ˆì§ˆ    const quality = Math.min(avgVariance / 1000, 1.0);        return quality;      } catch (error) {    console.error('?´ë?ì§€ ?ˆì§ˆ ì²´í¬ ?¤íŒ¨:', error);    return 0.5; // ê¸°ë³¸ê°?  }}/** * ?´ë?ì§€ ë©”í??°ì´??ì¶”ì¶œ * @param file ?´ë?ì§€ ?Œì¼ * @returns ?´ë?ì§€ ë©”í??°ì´?? */export async function getImageMetadata(file: File): Promise<{  width: number;  height: number;  aspectRatio: number;  fileSize: number;  type: string;}> {  try {    const img = await createImageBitmap(file);        return {      width: img.width,      height: img.height,      aspectRatio: img.width / img.height,      fileSize: file.size,      type: file.type    };      } catch (error) {    console.error('?´ë?ì§€ ë©”í??°ì´??ì¶”ì¶œ ?¤íŒ¨:', error);    throw new Error('?´ë?ì§€ ?•ë³´ë¥??½ì„ ???†ìŠµ?ˆë‹¤.');  }}/** * ?´ë?ì§€ ë°°ê²½ ?œê±° (ê°„ë‹¨???œë??ˆì´?? * @param file ?´ë?ì§€ ?Œì¼ * @returns ë°°ê²½???œê±°???´ë?ì§€ ?Œì¼ */export async function removeBackground(file: File): Promise<File> {  try {    // ?¤ì œë¡œëŠ” AI ëª¨ë¸???¬ìš©?´ì•¼ ?˜ì?ë§? ?¬ê¸°?œëŠ” ?œë??ˆì´??    const img = await createImageBitmap(file);    const canvas = new OffscreenCanvas(img.width, img.height);    const ctx = canvas.getContext('2d')!;        // ?ë³¸ ?´ë?ì§€ ê·¸ë¦¬ê¸?    ctx.drawImage(img, 0, 0);        // ê°„ë‹¨??ë°°ê²½ ?œê±° ?œë??ˆì´??(?¤ì œë¡œëŠ” AI ëª¨ë¸ ?¬ìš©)    // ?¬ê¸°?œëŠ” ?¬ëª…?„ë§Œ ì¡°ì •    const imageData = ctx.getImageData(0, 0, img.width, img.height);    const data = imageData.data;        for (let i = 0; i < data.length; i += 4) {      // ë°ì? ?½ì????¬ëª…?˜ê²Œ ë§Œë“¤ê¸?(ê°„ë‹¨???œë??ˆì´??      const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;      if (brightness > 240) {        data[i + 3] = 0; // ?¬ëª…??0      }    }        ctx.putImageData(imageData, 0, 0);        // PNGë¡?ë³€??(?¬ëª…??ì§€??    const blob = await canvas.convertToBlob({       type: 'image/png'    });        const newFileName = file.name.replace(/\.\w+$/, '.png');    return new File([blob], newFileName, { type: 'image/png' });      } catch (error) {    console.error('ë°°ê²½ ?œê±° ?¤íŒ¨:', error);    throw new Error('ë°°ê²½ ?œê±° ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.');  }}/** * ?´ë?ì§€ ?„í„° ?ìš© * @param file ?´ë?ì§€ ?Œì¼ * @param filter ?„í„° ?€?? * @returns ?„í„°ê°€ ?ìš©???´ë?ì§€ ?Œì¼ */export async function applyImageFilter(  file: File,   filter: 'grayscale' | 'sepia' | 'blur' | 'sharpen'): Promise<File> {  try {    const img = await createImageBitmap(file);    const canvas = new OffscreenCanvas(img.width, img.height);    const ctx = canvas.getContext('2d')!;        // ?ë³¸ ?´ë?ì§€ ê·¸ë¦¬ê¸?    ctx.drawImage(img, 0, 0);        // ?„í„° ?ìš©    switch (filter) {      case 'grayscale':        ctx.filter = 'grayscale(100%)';        break;      case 'sepia':        ctx.filter = 'sepia(100%)';        break;      case 'blur':        ctx.filter = 'blur(2px)';        break;      case 'sharpen':        ctx.filter = 'contrast(150%) saturate(150%)';        break;    }        // ?„í„° ?ìš©???´ë?ì§€ ?¤ì‹œ ê·¸ë¦¬ê¸?    ctx.drawImage(canvas, 0, 0);        // WebPë¡?ë³€??    const blob = await canvas.convertToBlob({       type: 'image/webp',       quality: 0.9     });        const newFileName = file.name.replace(/\.\w+$/, `-${filter}.webp`);    return new File([blob], newFileName, { type: 'image/webp' });      } catch (error) {    console.error('?´ë?ì§€ ?„í„° ?ìš© ?¤íŒ¨:', error);    throw new Error('?„í„° ?ìš© ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.');  }}/** * ?´ë?ì§€ ?¬ë¡­ * @param file ?´ë?ì§€ ?Œì¼ * @param x ?œì‘ X ì¢Œí‘œ * @param y ?œì‘ Y ì¢Œí‘œ * @param width ?¬ë¡­???ˆë¹„ * @param height ?¬ë¡­???’ì´ * @returns ?¬ë¡­???´ë?ì§€ ?Œì¼ */export async function cropImage(  file: File,  x: number,  y: number,  width: number,  height: number): Promise<File> {  try {    const img = await createImageBitmap(file);    const canvas = new OffscreenCanvas(width, height);    const ctx = canvas.getContext('2d')!;        // ì§€?•ëœ ?ì—­ë§?ê·¸ë¦¬ê¸?    ctx.drawImage(img, x, y, width, height, 0, 0, width, height);        // WebPë¡?ë³€??    const blob = await canvas.convertToBlob({       type: 'image/webp',       quality: 0.9     });        const newFileName = file.name.replace(/\.\w+$/, '-cropped.webp');    return new File([blob], newFileName, { type: 'image/webp' });      } catch (error) {    console.error('?´ë?ì§€ ?¬ë¡­ ?¤íŒ¨:', error);    throw new Error('?´ë?ì§€ ?¬ë¡­ ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.');  }}/** * ?´ë?ì§€ ?•ì¶•ë¥?ê³„ì‚° * @param originalSize ?ë³¸ ?Œì¼ ?¬ê¸° (bytes) * @param compressedSize ?•ì¶•???Œì¼ ?¬ê¸° (bytes) * @returns ?•ì¶•ë¥?(0.0 ~ 1.0) */export function calculateCompressionRatio(originalSize: number, compressedSize: number): number {  if (originalSize === 0) return 0;  return (originalSize - compressedSize) / originalSize;}/** * ?Œì¼ ?¬ê¸° ?¬ë§·?? * @param bytes ë°”ì´???¨ìœ„ ?¬ê¸° * @returns ?¬ë§·???¬ê¸° ë¬¸ì?? */export function formatFileSize(bytes: number): string {  if (bytes === 0) return '0 Bytes';    const k = 1024;  const sizes = ['Bytes', 'KB', 'MB', 'GB'];  const i = Math.floor(Math.log(bytes) / Math.log(k));    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];} 
