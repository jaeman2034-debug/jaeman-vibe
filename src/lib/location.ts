import { geohashForLocation, distanceBetween } from 'geofire-common';import type { Geo } from '@/features/market/types';/** * ?„ì¬ ?„ì¹˜ ê°€?¸ì˜¤ê¸? */export function getCurrentPosition(opts: PositionOptions = {  enableHighAccuracy: true,   timeout: 8000,  maximumAge: 60000 // 1ë¶?ìºì‹œ}): Promise<GeolocationPosition> {  return new Promise((res, rej) =>    navigator.geolocation.getCurrentPosition(res, rej, opts)  );}/** * ?„ì¬ ?„ì¹˜ë¥?Geo ?€?…ìœ¼ë¡?ë³€?? */export async function getCurrentGeo(): Promise<Geo> {  const p = await getCurrentPosition();  const lat = p.coords.latitude;  const lng = p.coords.longitude;    return {    lat,     lng,    geohash: geohashForLocation([lat, lng]),    accuracy: p.coords.accuracy,    ts: Date.now(),  };}/** * ??ì§€??ê°„ì˜ ê±°ë¦¬ ê³„ì‚° (Haversine ê³µì‹) */export function calculateDistance(  lat1: number,   lng1: number,   lat2: number,   lng2: number): number {  const R = 6371; // ì§€êµ?ë°˜ì?ë¦?(km)  const dLat = (lat2 - lat1) * Math.PI / 180;  const dLng = (lng2 - lng1) * Math.PI / 180;  const a =     Math.sin(dLat/2) * Math.sin(dLat/2) +    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *     Math.sin(dLng/2) * Math.sin(dLng/2);  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));  return R * c; // km ?¨ìœ„}/** * ê±°ë¦¬ë¥??¬ìš©??ì¹œí™”?ì¸ ?ìŠ¤?¸ë¡œ ë³€?? */export function formatDistance(distance: number): string {  if (distance < 1) {    return `${Math.round(distance * 1000)}m`;  } else if (distance < 10) {    return `${distance.toFixed(1)}km`;  } else {    return `${Math.round(distance)}km`;  }}/** * ?¹ì • ?„ì¹˜?ì„œ??ê±°ë¦¬ë¥??¬ìš©??ì¹œí™”?ìœ¼ë¡??œì‹œ * @param lat ?€???„ë„ * @param lng ?€??ê²½ë„ * @param me ?¬ìš©???„ì¹˜ {lat, lng} * @returns "1.2km" ?ëŠ” "800m" ?•íƒœ??ë¬¸ì?? */export function formatDistanceFrom(  lat: number,   lng: number,   me: { lat: number; lng: number }): string {  const m = distanceBetween([lat, lng], [me.lat, me.lng]) * 1000;  return m >= 1000 ? `${(m/1000).toFixed(1)}km` : `${m|0}m`;}/** * ?„ì¹˜ ê¶Œí•œ ?íƒœ ?•ì¸ */export async function checkLocationPermission(): Promise<PermissionState> {  if (!navigator.permissions) {    return 'granted'; // ê¶Œí•œ APIë¥?ì§€?í•˜ì§€ ?ŠëŠ” ê²½ìš°  }    try {    const result = await navigator.permissions.query({ name: 'geolocation' as PermissionName });    return result.state;  } catch {    return 'granted'; // ê¶Œí•œ API ?¤ë¥˜ ??ê¸°ë³¸ê°?  }}/** * ?„ì¹˜ ê¶Œí•œ ?”ì²­ */export async function requestLocationPermission(): Promise<boolean> {  try {    const geo = await getCurrentGeo();    return !!geo;  } catch (error) {    console.error('?„ì¹˜ ê¶Œí•œ ?”ì²­ ?¤íŒ¨:', error);    return false;  }}/** * localStorage?ì„œ ?¬ìš©???„ì¹˜ ê°€?¸ì˜¤ê¸? */export function getUserLocationFromStorage(): { lat: number; lng: number } | null {  try {    const stored = localStorage.getItem('userLocation');    if (stored) {      const location = JSON.parse(stored);      // ?€?¥ëœ ?„ì¹˜ê°€ 24?œê°„ ?´ë‚´?¸ì? ?•ì¸      if (location.ts && Date.now() - location.ts < 24 * 60 * 60 * 1000) {        return { lat: location.lat, lng: location.lng };      }    }  } catch (error) {    console.warn('?€?¥ëœ ?„ì¹˜ ?•ë³´ ?Œì‹± ?¤íŒ¨:', error);  }  return null;}/** * ?¬ìš©???„ì¹˜ë¥?localStorage???€?? */export function saveUserLocationToStorage(lat: number, lng: number): void {  try {    const location = { lat, lng, ts: Date.now() };    localStorage.setItem('userLocation', JSON.stringify(location));  } catch (error) {    console.warn('?„ì¹˜ ?•ë³´ ?€???¤íŒ¨:', error);  }}/** * ?¬ìš©???„ì¹˜ ê°€?¸ì˜¤ê¸?(?€?¥ëœ ?„ì¹˜ ?°ì„ , ?†ìœ¼ë©??ˆë¡œ ?”ì²­) */export async function getUserLocation(): Promise<{ lat: number; lng: number } | null> {  // ë¨¼ì? ?€?¥ëœ ?„ì¹˜ ?•ì¸  const stored = getUserLocationFromStorage();  if (stored) {    return stored;  }  // ?€?¥ëœ ?„ì¹˜ê°€ ?†ìœ¼ë©??ˆë¡œ ?”ì²­  try {    const geo = await getCurrentGeo();    saveUserLocationToStorage(geo.lat, geo.lng);    return { lat: geo.lat, lng: geo.lng };  } catch (error) {    console.warn('?„ì¹˜ ?•ë³´ ê°€?¸ì˜¤ê¸??¤íŒ¨:', error);    return null;  }} 
