"use strict";
// src/lib/parse.ts// ===== ?�자 ?�서 (?�큰 기반) =====const DIGIT_MAP: Record<string,string> = {  "0":"0","1":"1","2":"2","3":"3","4":"4","5":"5","6":"6","7":"7","8":"8","9":"9",  "�?:"0","??:"0","�?:"0",  "??:"1","??:"2","??:"3","??:"4","??:"5","??:"6","�?:"6","�?:"7","??:"8","�?:"9",};const MULTI_REPL: [RegExp,string][] = [  [/?�섯/g, "6"], [/?�곱/g, "7"], [/?�덟/g, "8"], [/?�홉/g, "9"],  [/?�이???�잇/g, "8"],  // ?�어 발음 보정];function tokenToDigits(tok: string): string {  // ?�수 ?�자�?그�?�?  if (/^\d+$/.test(tok)) return tok;  // ???��??�면�?변???�도  if (!/^[가-??+$/.test(tok)) return "";  // 복합 ?�절 먼�? 치환  for (const [re, rep] of MULTI_REPL) tok = tok.replace(re, rep);  // ?�용 문자로만 구성??경우?�만 1:1 매핑  for (const ch of tok) {    if (!(ch in DIGIT_MAP)) return "";  }  return [...tok].map(ch => DIGIT_MAP[ch]).join("");}export function digitsFromSpeech(text: string) {  let s = text.normalize("NFC").toLowerCase();  // 구두??구분?��? 공백?�로  s = s.replace(/\b(?�이??빼기|?�??dash|??dot|?�표|콤마|comma|마침???�화번호??|번호??)\b/g, " ");  s = s.replace(/[~_=+.,/\\(){}[\]:;'"`!?@#%^&*<>|]/g, " ");  s = s.replace(/\s+/g, " ").trim();  const tokens = s.split(" ");  let out = "";  for (const t of tokens) out += tokenToDigits(t);  return out;}function pick01xBlock(ds: string): string | null {  const full = ds.match(/01[016789]\d{7,8}/);  if (full) return full[0];  const near = ds.match(/01[016789]\d{6,8}/); // ???�리 모자???�용  return near?.[0] ?? null;}export function extractPhone(text: string) {  const ds = digitsFromSpeech(text);  const all = pick01xBlock(ds);  if (!all) return null;  const head = all.slice(0, 3);  const remain = all.slice(3);  let midLen = (all.length === 10) ? 3 : 4; // 010-3-4 ?�는 010-4-4  if (all.length === 9) midLen = Math.max(2, remain.length - 4); // 모자???�시?�기  const mid = remain.slice(0, midLen);  const tail = remain.slice(midLen);  return { digits: head + remain, display: `${head}-${mid}-${tail}` };}export function extractName(raw: string) {  // ?�처�? 공백/구두???�리 + ?�어�??�름 붙이�?????�????�재�?  let t = raw    .normalize("NFC")    .replace(/[.,!?;:]/g, " ")    .replace(/\s+/g, " ")    .trim()    .replace(/([가-??)\s(?=[가-??(?:\s[가-??)?)/g, "$1");  // ?�름 ?�에 ?????�는 종결/?�환 ?�워??  const END  = String.raw`(?:?�니????s*?????�에????s*??s*???�요|??s*????`;  const NEXT = String.raw`(?:?�화|?�화번호|?�화\s*번호|?�락�??�드???��???번호)`;  // ?�름처럼 보여???��? ?�름???�닌 ?�어  const STOP = /^(?�화번호|?�화|?�락�?번호|?�름|?�함)$/;  const clean = (s: string) =>    s.replace(/\s+/g, "").replace(/(??�?�???$/u, "").replace(/(?�생??|????�???$/u, "");  const tryPick = (re: RegExp) => {    const m = t.match(re);    if (!m?.[1]) return null;    const name = clean(m[1]);    if (STOP.test(name)) return null;    return name.length >= 2 && name.length <= 4 ? name : null;  };  // ??"?????�름?� ?�재�?(??"  const p1 = new RegExp(String.raw`(?:????\s*?�름(?:?�|:)?\s*([가-??{2,4})(?=\s*(?:${END}|${NEXT}|[^가-??|$))`, "u");  // ??"?�름?� ?�재�?(??"  ?????�로 추�?: '???? ?�이??매칭  const p1b = new RegExp(String.raw`?�름(?:?�|:)?\s*([가-??{2,4})(?=\s*(?:${END}|${NEXT}|[^가-??|$))`, "u");  // ??"?�???�는 ?�재�?(??"  const p2 = new RegExp(String.raw`(?:?�???�는)\s*([가-??{2,4})(?=\s*(?:${END}|${NEXT}|[^가-??|$))`, "u");  // ???�인 보정: ?�름+??�??�이 붙�? 경우(?�재만입/?�재만름)  const p3 = new RegExp(String.raw`([가-??{2,4})(?=\s*(?:??�?�?�?????\b)`, "u");  // ???�반: 종결?��? ?�에 붙는 경우?�만(문장 ???�함)  const p4 = new RegExp(String.raw`([가-??{2,4})(?=\s*${END}\b|$)`, "u");  return tryPick(p1) ?? tryPick(p1b) ?? tryPick(p2) ?? tryPick(p3) ?? tryPick(p4);} 
