"use strict";
// --- src/lib/telemetry.ts ---// HMAC-SHA256 (브라?��? Web Crypto ?�용)async function hmacHex(key: string, msg: string) {    const enc = new TextEncoder();    const cryptoKey = await crypto.subtle.importKey(      "raw",      enc.encode(key),      { name: "HMAC", hash: "SHA-256" },      false,      ["sign"]    );    const sig = await crypto.subtle.sign("HMAC", cryptoKey, enc.encode(msg));    return [...new Uint8Array(sig)].map(b => b.toString(16).padStart(2, "0")).join("");  }    // ====== PII 마스???�틸 ======  export const EMAIL_RE = /([A-Za-z0-9._%+\-]+)@([A-Za-z0-9.\-]+\.[A-Za-z]{2,})/gi;  export const PHONE_RE = /0[1-9][0-9\- ]{7,12}[0-9]/g;    const DOMAIN_ALLOW = new Set([    "gmail.com","naver.com","daum.net","kakao.com","hotmail.com","outlook.com"  ]);    export async function maskEmailForLogs(email: string, salt: string) {    const m = email.match(EMAIL_RE);    if (!m) return null;    const [local, domain] = m[0].toLowerCase().split("@");    const localHash = await hmacHex(salt, local);    const safeDomain = DOMAIN_ALLOW.has(domain) ? domain : await hmacHex(salt, domain);    return `<EMAIL:${localHash.slice(0,12)}@${safeDomain}>`;  }    export async function sanitizeRawForLogs(text: string, salt: string) {    let t = text;      // ?�메??마스??    for (const m of t.matchAll(EMAIL_RE)) {      const masked = await maskEmailForLogs(m[0], salt);      if (masked) t = t.replace(m[0], masked);    }      // ?�화 마스?? ??2?�리�??��?    t = t.replace(PHONE_RE, (m) => {      const digits = m.replace(/\D/g, "");      if (digits.length < 8) return "<PHONE:short>";      return `<PHONE:***REMOVED***${digits.slice(-2)}>`;    });      // 비�?번호 구간 ?�거(최�? 20??    t = t.replace(      /(�?s*밀\s*�?s*??�?s*�?�?s*�??�호|password|pass\s*word|pw)[:\s]*.{0,20}/gi,      "$1:<REDACTED>"    );      return t;  }    // ====== ?�레메트�???======  type TelemetryEvent =    | { type: "stt_result"; data: any }    | { type: "parse_result"; data: any }    | { type: "submit"; data: any };    export class Telemetry {    private queue: TelemetryEvent[] = [];    // ???�위 salt(복원 불�? ?�명??    private salt = new Date().toISOString().slice(0,10);      constructor(private endpoint = "/api/telemetry") {}      getSalt() { return this.salt; }      push(ev: TelemetryEvent) {      this.queue.push(ev);    }      async flush() {      if (!this.queue.length) return;            // ?�레메트�?envelope 추�?      const sessionId = (crypto as any).randomUUID ? (crypto as any).randomUUID() : String(Date.now());      const body = JSON.stringify({        schema: 1,        parserVersion: '1.1.0',        sessionId,        events: this.queue,        ts: Date.now()      });            this.queue = [];      try {        await fetch(this.endpoint, {          method: "POST",          headers: { "Content-Type": "application/json" },          body        });      } catch {        // ?�트?�크 ?�패 ??그냥 ?�랍(간단 ?�영). ?�요?�면 localStorage ?�시??로직 추�?.      }    }  }  // ====== 간단 ?�레메트�??�틸 ======export async function sendTelemetry(evt: string, data: any = {}) {  const payload = JSON.stringify({ evt, ...data });    // ?�이지가 ?�날 ?�도 ?�전?�게 ?�송  if (navigator.sendBeacon) {    const blob = new Blob([payload], { type: "application/json" });    navigator.sendBeacon("/api/telemetry", blob);    return;  }    try {    await fetch("/api/telemetry", {      method: "POST",      headers: { "Content-Type": "application/json" },      body: payload,      keepalive: true,    });  } catch {    /* ?�패?�도 ???�름 방해 X */  }}  
