// --- src/lib/telemetry.ts ---// HMAC-SHA256 (ë¸Œë¼?°ì? Web Crypto ?¬ìš©)async function hmacHex(key: string, msg: string) {    const enc = new TextEncoder();    const cryptoKey = await crypto.subtle.importKey(      "raw",      enc.encode(key),      { name: "HMAC", hash: "SHA-256" },      false,      ["sign"]    );    const sig = await crypto.subtle.sign("HMAC", cryptoKey, enc.encode(msg));    return [...new Uint8Array(sig)].map(b => b.toString(16).padStart(2, "0")).join("");  }    // ====== PII ë§ˆìŠ¤??? í‹¸ ======  export const EMAIL_RE = /([A-Za-z0-9._%+\-]+)@([A-Za-z0-9.\-]+\.[A-Za-z]{2,})/gi;  export const PHONE_RE = /0[1-9][0-9\- ]{7,12}[0-9]/g;    const DOMAIN_ALLOW = new Set([    "gmail.com","naver.com","daum.net","kakao.com","hotmail.com","outlook.com"  ]);    export async function maskEmailForLogs(email: string, salt: string) {    const m = email.match(EMAIL_RE);    if (!m) return null;    const [local, domain] = m[0].toLowerCase().split("@");    const localHash = await hmacHex(salt, local);    const safeDomain = DOMAIN_ALLOW.has(domain) ? domain : await hmacHex(salt, domain);    return `<EMAIL:${localHash.slice(0,12)}@${safeDomain}>`;  }    export async function sanitizeRawForLogs(text: string, salt: string) {    let t = text;      // ?´ë©”??ë§ˆìŠ¤??    for (const m of t.matchAll(EMAIL_RE)) {      const masked = await maskEmailForLogs(m[0], salt);      if (masked) t = t.replace(m[0], masked);    }      // ?„í™” ë§ˆìŠ¤?? ??2?ë¦¬ë§??¨ê?    t = t.replace(PHONE_RE, (m) => {      const digits = m.replace(/\D/g, "");      if (digits.length < 8) return "<PHONE:short>";      return `<PHONE:***REMOVED***${digits.slice(-2)}>`;    });      // ë¹„ë?ë²ˆí˜¸ êµ¬ê°„ ?œê±°(ìµœë? 20??    t = t.replace(      /(ë¹?s*ë°€\s*ë²?s*??ë¹?s*ë²?ë¹?s*ë³??”í˜¸|password|pass\s*word|pw)[:\s]*.{0,20}/gi,      "$1:<REDACTED>"    );      return t;  }    // ====== ?”ë ˆë©”íŠ¸ë¦???======  type TelemetryEvent =    | { type: "stt_result"; data: any }    | { type: "parse_result"; data: any }    | { type: "submit"; data: any };    export class Telemetry {    private queue: TelemetryEvent[] = [];    // ???¨ìœ„ salt(ë³µì› ë¶ˆê? ?µëª…??    private salt = new Date().toISOString().slice(0,10);      constructor(private endpoint = "/api/telemetry") {}      getSalt() { return this.salt; }      push(ev: TelemetryEvent) {      this.queue.push(ev);    }      async flush() {      if (!this.queue.length) return;            // ?”ë ˆë©”íŠ¸ë¦?envelope ì¶”ê?      const sessionId = (crypto as any).randomUUID ? (crypto as any).randomUUID() : String(Date.now());      const body = JSON.stringify({        schema: 1,        parserVersion: '1.1.0',        sessionId,        events: this.queue,        ts: Date.now()      });            this.queue = [];      try {        await fetch(this.endpoint, {          method: "POST",          headers: { "Content-Type": "application/json" },          body        });      } catch {        // ?¤íŠ¸?Œí¬ ?¤íŒ¨ ??ê·¸ëƒ¥ ?œë(ê°„ë‹¨ ?´ì˜). ?„ìš”?˜ë©´ localStorage ?¬ì‹œ??ë¡œì§ ì¶”ê?.      }    }  }  // ====== ê°„ë‹¨ ?”ë ˆë©”íŠ¸ë¦?? í‹¸ ======export async function sendTelemetry(evt: string, data: any = {}) {  const payload = JSON.stringify({ evt, ...data });    // ?˜ì´ì§€ê°€ ? ë‚  ?Œë„ ?ˆì „?˜ê²Œ ?„ì†¡  if (navigator.sendBeacon) {    const blob = new Blob([payload], { type: "application/json" });    navigator.sendBeacon("/api/telemetry", blob);    return;  }    try {    await fetch("/api/telemetry", {      method: "POST",      headers: { "Content-Type": "application/json" },      body: payload,      keepalive: true,    });  } catch {    /* ?¤íŒ¨?´ë„ ???ë¦„ ë°©í•´ X */  }}  