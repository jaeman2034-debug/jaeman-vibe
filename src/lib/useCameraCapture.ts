import { useEffect, useRef, useState } from 'react';type UseCamera = {  videoRef: React.RefObject<HTMLVideoElement | null>;  canvasRef: React.RefObject<HTMLCanvasElement | null>;  start: () => Promise<void>;  stop: () => void;  takeShot: () => string | null; // dataURL ë°˜í™˜  quality: number; // 0~1 (ê°„ë‹¨ ?ˆì§ˆ ?¤ì½”??  setQuality: (score: number) => void; // ?¸ë??ì„œ ?ˆì§ˆ ?ìˆ˜ ?¤ì •  getAvailableCameras: () => Promise<MediaDeviceInfo[]>; // ?¬ìš© ê°€?¥í•œ ì¹´ë©”??ëª©ë¡  switchCamera: (deviceId: string) => Promise<void>; // ì¹´ë©”???„í™˜};export function useCameraCapture(): UseCamera {  const videoRef = useRef<HTMLVideoElement>(null);  const canvasRef = useRef<HTMLCanvasElement>(null);  const streamRef = useRef<MediaStream | null>(null);  const [quality, setQuality] = useState(0);  useEffect(() => () => streamRef.current?.getTracks().forEach(t => t.stop()), []);  // util  async function tryGetUserMedia(constraints: MediaStreamConstraints) {    try { return await navigator.mediaDevices.getUserMedia(constraints); }    catch { return null; }  }  const start = async () => {    // 1) ?€?¥ëœ deviceId ?°ì„     const savedId = localStorage.getItem('cameraDeviceId') || undefined;    let stream =      (savedId && await tryGetUserMedia({ video: { deviceId: { exact: savedId }}, audio:false })) ||      // 2) ?„ë©´ ì¹´ë©”??? í˜¸      await tryGetUserMedia({ video: { facingMode: { ideal: 'environment' }}, audio:false }) ||      // 3) ë§ˆì?ë§‰ìœ¼ë¡??„ë¬´ ë¹„ë””?¤ë‚˜      await tryGetUserMedia({ video: true, audio: false });    if (!stream) {      // ??êµ¬ì²´?ì¸ ?ëŸ¬ ë©”ì‹œì§€ ?œê³µ      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {        throw new Error('??ë¸Œë¼?°ì???ì¹´ë©”?¼ë? ì§€?í•˜ì§€ ?ŠìŠµ?ˆë‹¤. Chrome, Firefox, Safarië¥??¬ìš©?´ì£¼?¸ìš”.');      }            // ê¶Œí•œ ê´€???ëŸ¬ ?•ì¸      try {        await navigator.permissions.query({ name: 'camera' as PermissionName });      } catch {        // ê¶Œí•œ APIë¥?ì§€?í•˜ì§€ ?ŠëŠ” ê²½ìš°      }            throw new Error('ì¹´ë©”?¼ì— ?‘ê·¼?????†ìŠµ?ˆë‹¤. ë¸Œë¼?°ì? ê¶Œí•œê³??œìŠ¤???¤ì •???•ì¸?´ì£¼?¸ìš”.');    }    // ? íƒ???¥ì¹˜ id ?€??    const track = stream.getVideoTracks()[0];    const settings = track.getSettings();    if (settings.deviceId) localStorage.setItem('cameraDeviceId', settings.deviceId);    const v = videoRef.current!;    v.srcObject = stream;    v.setAttribute('playsinline', 'true'); // iOS    (v as any).muted = true;    await v.play();    streamRef.current = stream;  };  const getAvailableCameras = async (): Promise<MediaDeviceInfo[]> => {    try {      const devices = await navigator.mediaDevices.enumerateDevices();      return devices.filter(d => d.kind === 'videoinput');    } catch (error) {      console.error('ì¹´ë©”??ëª©ë¡ ì¡°íšŒ ?¤íŒ¨:', error);      return [];    }  };  const switchCamera = async (deviceId: string) => {    try {      // ê¸°ì¡´ ?¤íŠ¸ë¦??•ì?      stop();            // ??ì¹´ë©”?¼ë¡œ ?œì‘      const stream = await tryGetUserMedia({         video: { deviceId: { exact: deviceId }},         audio: false       });            if (!stream) {        throw new Error(`? íƒ??ì¹´ë©”??${deviceId.slice(0, 8)}...)ë¥??¬ìš©?????†ìŠµ?ˆë‹¤. ?¤ë¥¸ ì¹´ë©”?¼ë? ? íƒ?´ì£¼?¸ìš”.`);      }      // ???¤íŠ¸ë¦??¤ì •      const v = videoRef.current!;      v.srcObject = stream;      v.setAttribute('playsinline', 'true');      (v as any).muted = true;      await v.play();            // deviceId ?€??      localStorage.setItem('cameraDeviceId', deviceId);      streamRef.current = stream;          } catch (error) {      console.error('ì¹´ë©”???„í™˜ ?¤íŒ¨:', error);      // ?¤íŒ¨ ??ê¸°ë³¸ ì¹´ë©”?¼ë¡œ ?¬ì‹œ??      await start();    }  };  const stop = () => {    streamRef.current?.getTracks().forEach(t => t.stop());    streamRef.current = null;  };  const takeShot = () => {    const v = videoRef.current, c = canvasRef.current;    if (!v || !c) return null;    const w = v.videoWidth, h = v.videoHeight;    c.width = w; c.height = h;    const ctx = c.getContext('2d')!;    ctx.drawImage(v, 0, 0, w, h);    // --- ?”ë? ?ˆì§ˆ ?¤ì½”?? ì¤‘ì•™ ë°ê¸°/?€ë¹?ê°„ì´ ì¸¡ì •    const cx = Math.floor(w/2), cy = Math.floor(h/2);    const data = ctx.getImageData(cx-32, cy-32, 64, 64).data;    let lum = 0;    for (let i=0;i<data.length;i+=4) lum += (0.2126*data[i] + 0.7152*data[i+1] + 0.0722*data[i+2]);    lum /= (data.length/4); // 0~255    const score = Math.max(0, Math.min(1, (lum-40)/140)); // 40~180 ?¬ì´ë¥?0~1ë¡?    setQuality(score);    return c.toDataURL('image/jpeg', 0.92);  };  return { videoRef, canvasRef, start, stop, takeShot, quality, setQuality, getAvailableCameras, switchCamera };} 
