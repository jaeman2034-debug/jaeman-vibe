/** * ê³µí†µ ? í‹¸ë¦¬í‹° ?¨ìˆ˜?? *//** * ?´ë?ì§€ URL ë°±í•„ ? í‹¸ë¦¬í‹° (ê¸°ë³¸) * ê¸°ì¡´ Firestore ë¬¸ì„œ???´ë?ì§€ ?„ë“œë¥??ˆë¡œ??êµ¬ì¡°ë¡??…ë°?´íŠ¸ */export async function backfillImageUrls() {  console.log('[ë°±í•„] ?´ë?ì§€ URL ë°±í•„ ?œì‘...');    try {    const { db } = await import('@/lib/firebase');            const { collection, getDocs, updateDoc, doc } = await import('firebase/firestore');        const snapshot = await getDocs(collection(db, 'products'));    let updatedCount = 0;    let errorCount = 0;    for (const docSnapshot of snapshot.docs) {      const data = docSnapshot.data();            try {        // ?´ë?ì§€ ?„ë“œê°€ ?ˆê³  ì²?ë²ˆì§¸ ?´ë?ì§€ê°€ ?¨ìˆœ URL ë¬¸ì?´ì¸ ê²½ìš°        if (Array.isArray(data.images) && data.images.length > 0) {          const firstImage = data.images[0];                    if (typeof firstImage === 'string') {            // ???¨ìˆœ URL ë°°ì—´??êµ¬ì¡°?”ëœ ?´ë?ì§€ ?°ì´?°ë¡œ ë³€??            const imageData = data.images.map((url: string, index: number) => ({              url,              path: `products/${data.sellerId || 'unknown'}/${docSnapshot.id}_${index}.jpg`,              filename: `image_${index}.jpg`,              size: 0,              type: 'image/jpeg',              uploadedAt: new Date()            }));            // ??ë¬¸ì„œ ?…ë°?´íŠ¸            await updateDoc(doc(db, 'products', docSnapshot.id), {              images: imageData,              imageUrls: data.images,  // ê¸°ì¡´ ?¸í™˜??? ì?              thumbnail: data.images[0], // ì²?ë²ˆì§¸ ?´ë?ì§€ë¥??¸ë„¤?¼ë¡œ              updatedAt: new Date()            });            updatedCount++;            console.log(`[ë°±í•„] ${docSnapshot.id} ?…ë°?´íŠ¸ ?„ë£Œ`);          }        }        // ??thumbnail?´ë‚˜ imageUrlsê°€ ?†ëŠ” ê²½ìš° ê¸°ë³¸ê°??¤ì •        else if (!data.thumbnail && !data.imageUrls) {          await updateDoc(doc(db, 'products', docSnapshot.id), {            images: [],            imageUrls: [],            thumbnail: "",            updatedAt: new Date()          });                    updatedCount++;          console.log(`[ë°±í•„] ${docSnapshot.id} ê¸°ë³¸ê°??¤ì • ?„ë£Œ`);        }      } catch (error) {        console.error(`[ë°±í•„] ${docSnapshot.id} ?…ë°?´íŠ¸ ?¤íŒ¨:`, error);        errorCount++;      }    }    console.log(`[ë°±í•„] ?„ë£Œ: ${updatedCount}ê°?ë¬¸ì„œ ?…ë°?´íŠ¸, ${errorCount}ê°??¤íŒ¨`);        if (updatedCount > 0) {      alert(`ë°±í•„ ?„ë£Œ!\n${updatedCount}ê°?ë¬¸ì„œ ?…ë°?´íŠ¸??n${errorCount}ê°??¤íŒ¨`);    } else {      alert('?…ë°?´íŠ¸??ë¬¸ì„œê°€ ?†ìŠµ?ˆë‹¤.');    }      } catch (error) {    console.error('[ë°±í•„] ë°±í•„ ?¤íŒ¨:', error);    alert('ë°±í•„ ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.');  }}/** * ê¸°ì¡´ ë¬¸ì„œ ë°±í•„ (?´ë?ì§€ URL ?†ëŠ” ë¬¸ì„œ ë³´ì •) * imagePath, storagePathë¥??¬ìš©?˜ì—¬ ?¤ì œ ?¤ìš´ë¡œë“œ URL ?ì„± * ??ë²ˆë§Œ ?¤í–‰?˜ì—¬ ë¹?ë¬¸ì„œ?¤ì— URL??ì±„ì›Œ ?£ëŠ” ?¨ìˆ˜ */export async function backfillProductImages() {  console.log('[ë°±í•„] ê¸°ì¡´ ë¬¸ì„œ ?´ë?ì§€ URL ë°±í•„ ?œì‘...');    try {    const { db } = await import('@/lib/firebase');    const { storage } = await import('@/lib/firebase');    const { collection, getDocs, doc, updateDoc } = await import('firebase/firestore');    const { ref, getDownloadURL } = await import('firebase/storage');    const snap = await getDocs(collection(db, "products"));    let updatedCount = 0;    let skippedCount = 0;    let errorCount = 0;    for (const d of snap.docs) {      const data = d.data() as any;      // ???´ë? ?•ìƒ êµ¬ì¡°ë©??¤í‚µ      if (Array.isArray(data.images) && data.images[0]?.url) {        skippedCount++;        continue;      }      // ??ê³¼ê±°???¨ê²¨??path ?¤ê? ?ˆë‹¤ë©?ê·¸ê±¸ ?¬ìš©      const path = data.imagePath || data.storagePath || data.path;      if (!path) {        skippedCount++;        continue;      }      try {        // ??Storage?ì„œ ?¤ì œ ?¤ìš´ë¡œë“œ URL ?ì„±        const url = await getDownloadURL(ref(storage, path));                // ??ë¬¸ì„œ ?…ë°?´íŠ¸        await updateDoc(doc(db, "products", d.id), {          images: [{             url,             path,            filename: path.split('/').pop() || 'image.jpg',            size: 0,            type: 'image/jpeg',            uploadedAt: new Date()          }],          imageUrls: [url],  // ê¸°ì¡´ ?¸í™˜??? ì?          thumbnail: url,    // ì²?ë²ˆì§¸ ?´ë?ì§€ë¥??¸ë„¤?¼ë¡œ          updatedAt: new Date()        });                updatedCount++;        console.log(`??fixed: ${d.id} (${path})`);      } catch (e) {        console.warn(`? ï¸ skip ${d.id}:`, e);        errorCount++;      }    }    console.log(`[ë°±í•„] ?„ë£Œ: ${updatedCount}ê°??˜ì •, ${skippedCount}ê°??¤í‚µ, ${errorCount}ê°??¤íŒ¨`);        if (updatedCount > 0) {      alert(`ë°±í•„ ?„ë£Œ!\n??${updatedCount}ê°?ë¬¸ì„œ ?˜ì •??n??¸ ${skippedCount}ê°??¤í‚µ??n??${errorCount}ê°??¤íŒ¨`);    } else {      alert('?˜ì •??ë¬¸ì„œê°€ ?†ìŠµ?ˆë‹¤.');    }      } catch (error) {    console.error('[ë°±í•„] ë°±í•„ ?¤íŒ¨:', error);    alert('ë°±í•„ ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.');  }}/** * ?´ë?ì§€ URL ? íš¨??ê²€?? * @param url ?´ë?ì§€ URL * @returns ? íš¨??URL?¸ì? ?¬ë? */export function isValidImageUrl(url: string): boolean {  if (!url) return false;    // gs:// URL?€ ? íš¨?˜ì? ?ŠìŒ (getDownloadURL ?„ìš”)  if (url.startsWith('gs://')) return false;    // https:// URLë§?? íš¨  if (url.startsWith('https://')) return true;    // ?ë? ê²½ë¡œ???ˆìš© (ë¡œì»¬ ê°œë°œ??  if (url.startsWith('/') || url.startsWith('./')) return true;    return false;}/** * ?´ë?ì§€ ?„ë“œ ?•ê·œ?? * @param images ?´ë?ì§€ ?°ì´??(?¤ì–‘???•íƒœ ì§€?? * @returns ?•ê·œ?”ëœ ?´ë?ì§€ URL ë°°ì—´ */export function normalizeImageUrls(images: any): string[] {  if (!images) return [];    if (Array.isArray(images)) {    return images.map(img => {      if (typeof img === 'string') return img;      if (typeof img === 'object' && img?.url) return img.url;      return null;    }).filter(Boolean);  }    return [];}/** * ë§ˆì´ê·¸ë ˆ?´ì…˜: market ??products ì»¬ë ‰???´ë™ * market??ëª¨ë“  ë¬¸ì„œë¥?productsë¡?ë³µì‚¬?˜ê³  ë¹ ì§„ ?„ë“œ ì±„ìš°ê¸? */export async function migrateMarketToProducts() {  console.log('[ë§ˆì´ê·¸ë ˆ?´ì…˜] market ??products ?œì‘...');    try {    const { db } = await import('@/lib/firebase');    const { storage } = await import('@/lib/firebase');    const { collection, getDocs, addDoc, serverTimestamp } = await import('firebase/firestore');    const { ref, getDownloadURL } = await import('firebase/storage');    const snap = await getDocs(collection(db, "market"));    let migratedCount = 0;    let errorCount = 0;    for (const d of snap.docs) {      try {        const x = d.data() as any;                // ???´ë?ì§€ URL/ê²½ë¡œ ì¶”ì¶œ        const path = x?.images?.[0]?.path || x?.imagePath || null;        let url = x?.images?.[0]?.url || x?.imageUrl || null;                // ??ê²½ë¡œê°€ ?ˆì?ë§?URL???†ìœ¼ë©?Storage?ì„œ ?¤ìš´ë¡œë“œ URL ?ì„±        if (!url && path) {          try {             url = await getDownloadURL(ref(storage, path));           } catch (e) {            console.warn(`[ë§ˆì´ê·¸ë ˆ?´ì…˜] ${d.id} ?´ë?ì§€ URL ?ì„± ?¤íŒ¨:`, e);          }        }        // ??products ì»¬ë ‰?˜ì— ??ë¬¸ì„œ ?ì„±        await addDoc(collection(db, "products"), {          title: x.title ?? "",          category: x.category ?? "ê¸°í?",          description: x.description ?? "",          price: typeof x.price === "number" ? x.price : Number(x.price ?? 0),          images: url ? [{             url,             path: path ?? null,            filename: path?.split('/').pop() || 'image.jpg',            size: 0,            type: 'image/jpeg',            uploadedAt: new Date()          }] : [],          imageUrls: url ? [url] : [],          thumbnail: url || "",          status: x.status ?? "?ë§¤ì¤?,          sellerId: x.sellerId || x.sellerUid || "unknown",          location: x.location || x.geo,          address: x.address,          sellerStats: x.sellerStats,          chatCount: x.chatCount ?? 0,          likeCount: x.likeCount ?? 0,          viewCount: x.viewCount ?? 0,          createdAt: x.createdAt ?? serverTimestamp(),          updatedAt: serverTimestamp(),          migratedFrom: 'market',          originalId: d.id        });        migratedCount++;        console.log(`??ë§ˆì´ê·¸ë ˆ?´ì…˜ ?„ë£Œ: ${d.id} ??products`);              } catch (error) {        console.error(`??ë§ˆì´ê·¸ë ˆ?´ì…˜ ?¤íŒ¨: ${d.id}`, error);        errorCount++;      }    }    console.log(`[ë§ˆì´ê·¸ë ˆ?´ì…˜] ?„ë£Œ: ${migratedCount}ê°??´ë™, ${errorCount}ê°??¤íŒ¨`);        if (migratedCount > 0) {      alert(`ë§ˆì´ê·¸ë ˆ?´ì…˜ ?„ë£Œ!\n??${migratedCount}ê°?ë¬¸ì„œ ?´ë™??n??${errorCount}ê°??¤íŒ¨`);    } else {      alert('ë§ˆì´ê·¸ë ˆ?´ì…˜??ë¬¸ì„œê°€ ?†ìŠµ?ˆë‹¤.');    }      } catch (error) {    console.error('[ë§ˆì´ê·¸ë ˆ?´ì…˜] ë§ˆì´ê·¸ë ˆ?´ì…˜ ?¤íŒ¨:', error);    alert('ë§ˆì´ê·¸ë ˆ?´ì…˜ ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.');  }}// ê°œë°œ ?˜ê²½?ì„œ ?„ì—­ ?¨ìˆ˜ë¡??±ë¡if (import.meta.env.DEV) {  (window as any).backfillImageUrls = backfillImageUrls;  (window as any).backfillProductImages = backfillProductImages;  (window as any).migrateMarketToProducts = migrateMarketToProducts;  console.log('[ë°±í•„/ë§ˆì´ê·¸ë ˆ?´ì…˜] ?„ì—­ ?¨ìˆ˜ ?±ë¡??');  console.log('  - window.backfillImageUrls() : ê¸°ë³¸ ë°±í•„');  console.log('  - window.backfillProductImages() : ê¸°ì¡´ ë¬¸ì„œ ?´ë?ì§€ URL ë°±í•„');  console.log('  - window.migrateMarketToProducts() : market ??products ë§ˆì´ê·¸ë ˆ?´ì…˜');}