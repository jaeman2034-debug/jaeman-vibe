"use strict";
// Mock API for development - simulates backend endpoints// This replaces the need for actual Cloud Functions during developmentexport interface AnalysisRequest {  imageUrl: string;  productId: string;}export interface AnalysisResponse {  category: string;  condition: 'new' | 'good' | 'fair' | 'poor';  priceEstimate: { low: number; high: number; currency: 'KRW' };  authenticityScore: number;  riskFlags: string[];  tags: string[];}// Mock analyze function that simulates AI analysisexport async function callMockAnalyzeAPI(request: AnalysisRequest): Promise<AnalysisResponse> {  // Simulate API delay  await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));    // Generate mock data based on the image URL (for variety)  const urlHash = request.imageUrl.split('/').pop()?.charCodeAt(0) || 0;  const randomSeed = (urlHash + request.productId.length) % 4;    const mockCategories = ['가�?, '?�동??, '?�류', '?�자?�품', '?�포츠용??];  const mockConditions = ['new', 'good', 'fair', 'poor'] as const;  const mockTags = {    '가�?: ['가�?, '블랙', '캐주??, '백팩', '?�더�?],    '?�동??: ['?�이??, '?�디?�스', '?�니커즈', '?�동??, '?�포�?],    '?�류': ['?�드', '?�셔�?, '바�?', '?�킷', '캐주??],    '?�자?�품': ['?�마?�폰', '?�블�?, '?�트�?, '?�어??, '충전�?],    '?�포츠용??: ['축구�?, '?�구�?, '?�니?�라�?, '?�구글?�브', '?�스?�품']  };    const category = mockCategories[randomSeed];  const condition = mockConditions[randomSeed];  const tags = mockTags[category as keyof typeof mockTags] || ['?�반', '중고'];    // Generate realistic price estimates based on category and condition  const basePrices = {    '가�?: { min: 20000, max: 150000 },    '?�동??: { min: 30000, max: 200000 },    '?�류': { min: 15000, max: 80000 },    '?�자?�품': { min: 50000, max: 500000 },    '?�포츠용??: { min: 10000, max: 100000 }  };    const basePrice = basePrices[category as keyof typeof basePrices] || { min: 20000, max: 100000 };  const conditionMultiplier = { new: 1.0, good: 0.8, fair: 0.6, poor: 0.4 }[condition];  const baseValue = (basePrice.min + basePrice.max) / 2;  const estimatedPrice = Math.round(baseValue * conditionMultiplier);    const lowPrice = Math.round(estimatedPrice * 0.8);  const highPrice = Math.round(estimatedPrice * 1.2);    // Generate authenticity score based on condition and random factors  const authenticityScore = Math.max(0.3, Math.min(0.95,     0.7 + (condition === 'new' ? 0.2 : 0) + (Math.random() - 0.5) * 0.3  ));    // Generate risk flags based on condition and authenticity  const riskFlags: string[] = [];  if (condition === 'poor') riskFlags.push('?�태 불량');  if (authenticityScore < 0.5) riskFlags.push('?�품 ?�심');  if (estimatedPrice < basePrice.min * 0.5) riskFlags.push('가�??�심');    return {    category,    condition,    priceEstimate: {       low: lowPrice,       high: highPrice,       currency: 'KRW'     },    authenticityScore,    riskFlags,    tags: tags.slice(0, 3) // Limit to 3 tags  };}// Mock API endpoint simulationexport async function mockAnalyzeEndpoint(request: AnalysisRequest): Promise<AnalysisResponse> {  console.log('[MOCK_API] 분석 ?�청:', request);    try {    const result = await callMockAnalyzeAPI(request);    console.log('[MOCK_API] 분석 결과:', result);    return result;  } catch (error) {    console.error('[MOCK_API] 분석 ?�류:', error);    throw new Error('분석 �??�류가 발생?�습?�다.');  }}// Export for use in componentsexport { callMockAnalyzeAPI as default };
