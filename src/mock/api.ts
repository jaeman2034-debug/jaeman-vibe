// Mock API for development - simulates backend endpoints// This replaces the need for actual Cloud Functions during developmentexport interface AnalysisRequest {  imageUrl: string;  productId: string;}export interface AnalysisResponse {  category: string;  condition: 'new' | 'good' | 'fair' | 'poor';  priceEstimate: { low: number; high: number; currency: 'KRW' };  authenticityScore: number;  riskFlags: string[];  tags: string[];}// Mock analyze function that simulates AI analysisexport async function callMockAnalyzeAPI(request: AnalysisRequest): Promise<AnalysisResponse> {  // Simulate API delay  await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));    // Generate mock data based on the image URL (for variety)  const urlHash = request.imageUrl.split('/').pop()?.charCodeAt(0) || 0;  const randomSeed = (urlHash + request.productId.length) % 4;    const mockCategories = ['ê°€ë°?, '?´ë™??, '?˜ë¥˜', '?„ì?œí’ˆ', '?¤í¬ì¸ ìš©??];  const mockConditions = ['new', 'good', 'fair', 'poor'] as const;  const mockTags = {    'ê°€ë°?: ['ê°€ì£?, 'ë¸”ë™', 'ìºì£¼??, 'ë°±íŒ©', '?„ë”ë°?],    '?´ë™??: ['?˜ì´??, '?„ë””?¤ìŠ¤', '?¤ë‹ˆì»¤ì¦ˆ', '?´ë™??, '?¤í¬ì¸?],    '?˜ë¥˜': ['?„ë“œ', '?°ì…”ì¸?, 'ë°”ì?', '?¬í‚·', 'ìºì£¼??],    '?„ì?œí’ˆ': ['?¤ë§ˆ?¸í°', '?œë¸”ë¦?, '?¸íŠ¸ë¶?, '?´ì–´??, 'ì¶©ì „ê¸?],    '?¤í¬ì¸ ìš©??: ['ì¶•êµ¬ê³?, '?êµ¬ê³?, '?Œë‹ˆ?¤ë¼ì¼?, '?¼êµ¬ê¸€?¬ë¸Œ', '?¬ìŠ¤?©í’ˆ']  };    const category = mockCategories[randomSeed];  const condition = mockConditions[randomSeed];  const tags = mockTags[category as keyof typeof mockTags] || ['?¼ë°˜', 'ì¤‘ê³ '];    // Generate realistic price estimates based on category and condition  const basePrices = {    'ê°€ë°?: { min: 20000, max: 150000 },    '?´ë™??: { min: 30000, max: 200000 },    '?˜ë¥˜': { min: 15000, max: 80000 },    '?„ì?œí’ˆ': { min: 50000, max: 500000 },    '?¤í¬ì¸ ìš©??: { min: 10000, max: 100000 }  };    const basePrice = basePrices[category as keyof typeof basePrices] || { min: 20000, max: 100000 };  const conditionMultiplier = { new: 1.0, good: 0.8, fair: 0.6, poor: 0.4 }[condition];  const baseValue = (basePrice.min + basePrice.max) / 2;  const estimatedPrice = Math.round(baseValue * conditionMultiplier);    const lowPrice = Math.round(estimatedPrice * 0.8);  const highPrice = Math.round(estimatedPrice * 1.2);    // Generate authenticity score based on condition and random factors  const authenticityScore = Math.max(0.3, Math.min(0.95,     0.7 + (condition === 'new' ? 0.2 : 0) + (Math.random() - 0.5) * 0.3  ));    // Generate risk flags based on condition and authenticity  const riskFlags: string[] = [];  if (condition === 'poor') riskFlags.push('?íƒœ ë¶ˆëŸ‰');  if (authenticityScore < 0.5) riskFlags.push('?•í’ˆ ?˜ì‹¬');  if (estimatedPrice < basePrice.min * 0.5) riskFlags.push('ê°€ê²??˜ì‹¬');    return {    category,    condition,    priceEstimate: {       low: lowPrice,       high: highPrice,       currency: 'KRW'     },    authenticityScore,    riskFlags,    tags: tags.slice(0, 3) // Limit to 3 tags  };}// Mock API endpoint simulationexport async function mockAnalyzeEndpoint(request: AnalysisRequest): Promise<AnalysisResponse> {  console.log('[MOCK_API] ë¶„ì„ ?”ì²­:', request);    try {    const result = await callMockAnalyzeAPI(request);    console.log('[MOCK_API] ë¶„ì„ ê²°ê³¼:', result);    return result;  } catch (error) {    console.error('[MOCK_API] ë¶„ì„ ?¤ë¥˜:', error);    throw new Error('ë¶„ì„ ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.');  }}// Export for use in componentsexport { callMockAnalyzeAPI as default };