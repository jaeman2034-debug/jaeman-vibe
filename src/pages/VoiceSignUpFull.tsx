import React, { useCallback, useEffect, useRef, useState } from "react";import { useNavigate, useLocation } from "react-router-dom";import {  createUserWithEmailAndPassword,  updateProfile,  sendPasswordResetEmail,  fetchSignInMethodsForEmail,} from "firebase/auth";import { doc, setDoc, serverTimestamp } from "firebase/firestore";import { auth, db } from "@/lib/firebase";import { EmailVoiceField } from "../utils/speechEmail";/** * ?????Œì¼ ?˜ë‚˜ë¡????µë³µ) * - Web Speech API: ?´ë¦­ ??ì¦‰ì‹œ start (ê¶Œí•œ/UX ?ˆì •?? * - ?•ê·œ??ê²€ì¦? ?´ë¦„/?´ë©”??ë¹„ë²ˆ * - Firebase Auth ?°ë™: ?´ë©”??ë¹„ë²ˆ ?Œì› ?ì„± * - TTS ?ˆë‚´: ?¨ê³„ë§ˆë‹¤ ?Œì„± ?¼ë“œë°? * - HTTPS ê°€?? http ?˜ê²½ ê²½ê³  * * ?¬ìš©ë²? * 1) .env??VITE_FB_* ì±„ìš°ê¸? * 2) ?¼ìš°??or App.tsx?ì„œ <VoiceSignUpFull /> ?Œë” */// -------------------- SR ?€??ë³´ê°• --------------------declare global {  interface Window {    webkitSpeechRecognition?: any;    SpeechRecognition?: any;  }}// === TTS ?ì½” ì°¨ë‹¨ ?¤ì • ===const TTS_ECHO_WINDOW_MS = 1800; // ê¸°ì¡´ 800ms ??1.8së¡??˜ë¦¼const TTS_BLOCKLIST = [  /?´ë¦„??s*?•ì¸?ˆìŠµ?ˆë‹¤\.?$/i,  /?•ì¸?©ë‹ˆ??.?$/i,  /?„ì?°í¸/i,];// ?´ë©”??ID ?„ì  ??ë²„ë¦´ ?¡ìŒ(?ì–´ STT ?”ë“¤ë¦? & ??amp, 'cj', 'jj' ??const JUNK_TOKENS = new Set([  "email", "?´ë©”??, "ë©”ì¼",  "ì²˜ëŸ¼", "ê°™ì´", "ê°™ì?",  "amp", "&", "and",  "cj", "jj", "jje"]);// --- Email STT helpers -------------------------------------------------const AT_WORDS = /(ê³¨ë±…????\bat\b)/gi;         // -> '@'const DOT_WORDS = /(????ì©?/gi;                 // -> '.'const PROVIDER_RE = /(gmail|gë©”ì¼|ì§€ë©”ì¼|naver|?¤ì´ë²?daum|?¤ìŒ|hanmail|?œë©”??kakao|ì¹´ì¹´??/i;const EMAIL_ID_ALLOWED = /[a-z0-9._-]/;// === ?¤ì¸??ë³´ì • ===function normalizeEmailMishear(s: string) {  return (s || "")    .toLowerCase()    // 'ê³¨ë±…????at' -> '@'    .replace(/\b(ê³¨ë±…????\bat\b)\b/g, "@")    // '????ì©? -> '.'    .replace(/\b(????ì©?\b/g, ".")    // 'g ë©”ì¼/ì§€ ë©”ì¼/ì§€ë©”ì¼/g mail' -> 'gmail'    .replace(/\bg\s*ë©”ì¼\b/g, "gmail")    .replace(/\bg\s*mail\b/g, "gmail")    .replace(/\bì§€\s*ë©”ì¼\b/g, "gmail")    .replace(/\bì§€ë©”ì¼\b/g, "gmail")    // '?¤ì´ë²??¤ìŒ/?œë©”??ì¹´ì¹´?? -> ?ë¬¸ ?„ë©”??ë£¨íŠ¸    .replace(/\b?¤ì´ë²?b/g, "naver")    .replace(/\b?¤ìŒ\b/g, "daum")    .replace(/\b?œë©”??b/g, "hanmail")    .replace(/\bì¹´ì¹´??b/g, "kakao")    // 'cj' ê°€ 'j'ë¡?ë¶™ëŠ” ì¼€?´ìŠ¤ ë³´ì •    .replace(/\bcj(?=\s*[a-z])/g, "j")    .replace(/\bjj(?=\s*[a-z])/g, "j")    // ê³µë°±/?¹ë¬¸ ?•ë¦¬    .replace(/[ï¼Œã€?/g, ",");}const sanitizeDomain = (s: string) =>  (s || "")    .toLowerCase()    .replace(DOT_WORDS, ".")    .replace(/[^\w.-]+/g, "")   // ?œê?/ë¶ˆí•„??ê¸°í˜¸ ?œê±°    .replace(/^\.+/, "")    .replace(/\.+$/, "")    .replace(/\.{2,}/g, ".");function fixCommonDomain(dom: string) {  if (!dom) return dom;  const d = dom.replace(/\.(?:com|net)?$/, ""); // ?¤ì— com/net ? ë¬´ ?ì—¬ ?¤ì–´??ì¼€?´ìŠ¤ ë³´ì •  if (/^(gmail|gë©”ì¼|ì§€ë©”ì¼)$/.test(d)) return "gmail.com";  if (/^(naver|?¤ì´ë²?$/.test(d))       return "naver.com";  if (/^(daum|?¤ìŒ)$/.test(d))          return "daum.net";  if (/^(hanmail|?œë©”??$/.test(d))     return "hanmail.net";  if (/^(kakao|ì¹´ì¹´??$/.test(d))       return "kakao.com";  return dom;}// ?œê? ?¤í ë§??ì´/ë¹??¨â€?, ?«ì(??ê³?ë¹µâ€?ë¥?asciië¡?const DIGIT_KO: Record<string,string> = { "??:"0","ê³?:"0","ë¹?:"0","??:"1","??:"2","??:"3","??:"4","??:"5","??:"6","ë¥?:"6","ì¹?:"7","??:"8","êµ?:"9" };const ALPHA_KO: Record<string,string> = { "?ì´":"a","ë¹?:"b","??:"c","??:"d","??:"e","?í”„":"f","ì§€":"g","?ì´ì¹?:"h","?„ì´":"i","?œì´":"j","ì¼€??:"k","??:"l","??:"m","??:"n","??:"o","??:"p","??:"q","?„ë¥´":"r","?ìŠ¤":"s","??:"t","??:"u","ë¸Œì´":"v","?”ë¸”??:"w","?‘ìŠ¤":"x","?€??:"y","?œíŠ¸":"z","ì§€??:"z" };function koSpellToAscii(chunk: string) {  const tokens = (chunk || "").toLowerCase().trim().split(/\s+/).filter(Boolean);  let out = "";  for (let tk of tokens) {    if (JUNK_TOKENS.has(tk)) continue;      // ?”´ ?´ëŸ° ? í°?€ ë²„ë¦°??    if (ALPHA_KO[tk]) { out += ALPHA_KO[tk]; continue; }    if (tk in DIGIT_KO) { out += DIGIT_KO[tk]; continue; }    if (tk === "?? || tk === "?? || tk === "ì©?) { out += "."; continue; }    if (/^[a-z0-9._-]+$/.test(tk)) { out += tk; continue; }  }  return out;}// ID ?„ì : ?œê? ?¤í ë§??«ì ì§€??+ ??.)?€ ?‘ì˜†???ìˆ«?ì¼ ?Œë§Œ ?ˆìš©function accumulateId(prevId: string, rawChunk: string) {  let s = (rawChunk || "").toLowerCase();  if (/\s/.test(s) || /[ê°€-??/.test(s)) s = koSpellToAscii(s);  else s = s.replace(/\s+/g, "");  let out = "";  for (let i = 0; i < s.length; i++) {    const ch = s[i];    if (ch === ".") {      const prevChar = (prevId + out).slice(-1);      const nextChar = s[i + 1] || "";      if (/[a-z0-9]/.test(prevChar) && /[a-z0-9]/.test(nextChar)) out += ".";      continue;    }    if (EMAIL_ID_ALLOWED.test(ch)) out += ch;  }  let merged = prevId + out;  merged = merged.replace(/j{2,}/g, "j");   // jj ??j (? íƒ)  merged = merged.replace(/\.{2,}/g, ".");  // .. ??.  return merged;}function isLikelyEmail(id: string, dom: string) {  if (!id || !dom) return false;  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(`${id}@${dom}`);}// -------------------- ?´ë¦„ ì¶”ì¶œ ?¨ìˆ˜ ì¶”ê? --------------------function extractLikelyKoreanName(t: string) {  const onlyKo = (t || "")    .replace(/[^\uAC00-\uD7A3\s]/g, " ")    .replace(/\s+/g, " ")    .trim();  const cleaned = onlyKo    .replace(/\b(?ˆë…•?˜ì„¸???ˆë…•|ë°˜ê°‘?µë‹ˆ???€????s*?´ë¦„?€)\b/g, " ")    .replace(/\b(?…ë‹ˆ???´ì—?????????…ë‹ˆ?¤ìš”)\b/g, " ")    .replace(/\s+/g, " ")    .trim();  const parts = cleaned.split(" ").filter(Boolean);  if (parts.length === 0) return "";  const cand = parts.length >= 2    ? (parts[parts.length - 2] + parts[parts.length - 1]).trim()    : parts[0];  if (cand.length < 2 || cand.length > 6) return "";  return cand;}// -------------------- ?•ê·œ??ê²€ì¦?--------------------function cleanName(raw: string): string {  return (raw || "")    .replace(/[^a-zA-Zê°€-??s]/g, "")    .replace(/\s+/g, " ")    .trim();}function normalizeEmail(raw: string): string {  let t = (raw || "").toLowerCase().trim();  t = t    .replace(/\s+/g, " ")    .replace(/ê³¨ë±…?????ì´??g, "@")    .replace(/??s?/g, ".")    .replace(/?·ì»´|??ì»???ì½?g, ".com")    .replace(/\s+/g, "");  t = t    .replace(/ì§€ë©”ì¼|gmail\.?com/g, "gmail.com")    .replace(/?¤ì´ë²?naver\.?com/g, "naver.com")    .replace(/?¤ìŒ|daum\.?net/g, "daum.net")    .replace(/?¼í›„|yahoo\.?com/g, "yahoo.com");  return t;}function isValidEmail(v: string) {  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v || "");}function isStrongPassword(v: string) {  return (v || "").length >= 8;}// -------------------- TTS (ê°„ë‹¨ ?¬í¼) --------------------function speak(text: string, lang = "ko-KR") {  try {    const u = new SpeechSynthesisUtterance(text);    u.lang = lang;    window.speechSynthesis.cancel();    window.speechSynthesis.speak(u);  } catch {}}// TTS ì¤?STT ?„ì „ ?•ì?ë¥??„í•œ ë³´í˜¸ ?¨ìˆ˜async function speakAsync(text: string, lang = "ko-KR"): Promise<void> {  return new Promise((resolve) => {    try {      const u = new SpeechSynthesisUtterance(text);      u.lang = lang;      u.onend = () => resolve();      u.onerror = () => resolve();      window.speechSynthesis.cancel();      window.speechSynthesis.speak(u);    } catch {      resolve();    }  });}// TTS ?ì½” ì°¨ë‹¨ ?¨ìˆ˜function isEchoFromTTS(heard: string, last: string, lastEndAt: number, windowMs: number = 800): boolean {  if (!heard || !last) return false;    const now = Date.now();  const timeDiff = now - lastEndAt;    // ?œê°„ ì°??´ì—?œë§Œ ì²´í¬  if (timeDiff > windowMs) return false;    // ? ì‚¬??ì²´í¬ (ê°„ë‹¨???¬í•¨ ê´€ê³?  const heardLower = heard.toLowerCase();  const lastLower = last.toLowerCase();    // ?œìª½???¤ë¥¸ ìª½ì„ ?¬í•¨?˜ê±°?? ? ì‚¬???¨ì–´ê°€ ë§ìœ¼ë©??ì½”ë¡??ë‹¨  if (heardLower.includes(lastLower) || lastLower.includes(heardLower)) return true;    // ê³µí†µ ?¨ì–´ê°€ 2ê°??´ìƒ?´ë©´ ?ì½”ë¡??ë‹¨  const heardWords = heardLower.split(/\s+/).filter(Boolean);  const lastWords = lastLower.split(/\s+/).filter(Boolean);  const commonWords = heardWords.filter(word => lastWords.includes(word));    return commonWords.length >= 2;}// -------------------- ì»´í¬?ŒíŠ¸ --------------------type Step = 0 | 1 | 2 | 3;export default function VoiceSignUpFull() {  const nav = useNavigate();  const locationHook = useLocation();  const locale = "ko-KR"; // ?„ìš” ??i18n ?°ê²°  const [step, setStep] = useState<Step>(0);  const [name, setName] = useState("");  const [email, setEmail] = useState("");  const [pw, setPw] = useState("");  const [listening, setListening] = useState(false);  const [error, setError] = useState<string | null>(null);  const [busy, setBusy] = useState(false);  const [sttMuted, setSttMuted] = useState(false);  // ?´ë©”???ŒíŠ¸ ?íƒœ ì¶”ê?  const [emailId, setEmailId] = useState("");  const [emailDomain, setEmailDomain] = useState("");  const [emailMode, setEmailMode] = useState<"id" | "domain">("id"); // ?„ì¬ ?£ëŠ” ?€??  const domainSwitchedRef = useRef(false); // ì¤‘ë³µ ?„í™˜ ë°©ì?  // ?´ë¦„ ?„ìš© STT ?íƒœ  const [nameListening, setNameListening] = useState(false);  const nameRecRef = useRef<any>(null);    // ?´ë¦„ ìº¡ì²˜ ì¤??íƒœ (?„ì—­ STT ì°¨ë‹¨??  const isCapturingNameRef = useRef(false);  // STT ë¡œê·¸ ?íƒœ/?¨ìˆ˜ ì¶”ê?  const [sttLog, setSttLog] = useState<string[]>([]);  const sttLogRef = useRef<string[]>([]);  const appendStt = (line: string) => setSttLog(prev => {    const out = [...prev, `${new Date().toLocaleTimeString()} ${line}`].slice(-300);    sttLogRef.current = out;    return out;  });  // TTS ì¤?STT ?„ì „ ?•ì?ë¥??„í•œ ref  const forceStopRef = React.useRef<null | (() => void)>(null);  // "ìµœì¢…ê²°ê³¼ ?†ìŒ" ?ˆë‚´ ?€?´ë¨¸ ?„ì  ë²„ê·¸ ?˜ì •???„í•œ ref  const noFinalTimerRef = React.useRef<number | null>(null);  // TTS ?ì½” ì°¨ë‹¨???„í•œ ref??  const lastTextRef = useRef<string>("");  const lastEndAtRef = useRef<number>(0);  // TTS ì¤?STT ?„ì „ ?•ì?ë¥??„í•œ ë³´í˜¸ ?¨ìˆ˜  const speakGuarded = async (msg: string, opts: { restart?: boolean } = { restart: true }) => {    setUserStop(true);      // ?˜ë„??ì¤‘ì? ?Œë˜ê·?    // ?”´ TTS ?„ì— STT ?„ì „ ì¢…ë£Œ    try { forceStopRef.current?.(); } catch {}    try { stop(); } catch {}    setSttMuted(true);    await speakAsync(msg);  // TTS    setSttMuted(false);    setUserStop(false);    if (opts.restart !== false) {      // ?ì½” ?¬ìš´ ?€ë¹??´ì§ ?¬ìœ (800~1000ms) ???¬ì‹œ??      setTimeout(() => start(), 900);    }  };  // ?´ë©”???„ì„± ???ë™?¼ë¡œ ë¹„ë?ë²ˆí˜¸ ?¨ê³„ë¡??´ë™  const maybeAutoNext = React.useCallback(() => {    const id = emailId.trim();    const dom = fixCommonDomain(emailDomain.trim());    if (isLikelyEmail(id, dom)) {      const finalEmail = `${id}@${dom}`;      setEmail(finalEmail);            // draft/ëª¨ë“œ ë¦¬ì…‹      setEmailMode("id");      domainSwitchedRef.current = false;      setEmailId("");      setEmailDomain("");      // ?¤ìŒ ?¨ê³„ë¡??ë™ ?´ë™ + ?ˆë‚´ ?œë²ˆ      setStep(3);      speakGuarded("ë¹„ë?ë²ˆí˜¸ë¥??…ë ¥??ì£¼ì„¸??", { restart: false });    }  }, [emailId, emailDomain, setEmail, setEmailMode, setStep, speakGuarded]);  const [srLog, setSrLog] = useState<string[]>([]);  const log = (m: string) => setSrLog((xs) => [...xs.slice(-80), m]);  // ?´ë©”???Œì„± ?„ì  ?¨ìˆ˜ (ê¸°ì¡´ ë¡œì§ ? ì?)  const onEmailSpeechFinal = (raw: string) => {    // ê³µí†µ ì¹˜í™˜: ê³¨ë±…????    let t = (raw || "").toLowerCase().trim();    t = t.replace(AT_WORDS, "@").replace(DOT_WORDS, ".");    // 1) '@'ê°€ ?˜ì˜¤ë©?ì¢Œì¸¡?€ ID???„ì , ?°ì¸¡?€ ?„ë©”??ëª¨ë“œë¡??„í™˜    if (t.includes("@")) {      const [left, right = ""] = t.split("@");      const idNew = accumulateId(emailId, left);      setEmailId(idNew);      setEmailMode("domain");      const domNew = sanitizeDomain(emailDomain + right);      setEmailDomain(fixCommonDomain(domNew));      return;    }    // 2) provider(ì§€ë©”ì¼/?¤ì´ë²??¤ìŒ/?œë©”??ì¹´ì¹´?? ?¤ì›Œ?œê? ê°ì??˜ë©´ ?„ë©”??ëª¨ë“œë¡??„í™˜    if (PROVIDER_RE.test(t)) {      setEmailMode("domain");      setEmailDomain(prev => {        const merged = sanitizeDomain(prev + t);        return fixCommonDomain(merged);      });      return;    }    // 3) ?„ì¬ ëª¨ë“œ???°ë¼ ?„ì     if (emailMode === "id") {      setEmailId(prev => accumulateId(prev, t));    } else {      setEmailDomain(prev => fixCommonDomain(sanitizeDomain(prev + t)));    }  };  // ?´ë¦„ ?„ìš© STT ?ì„±  const ensureNameRec = useCallback(() => {    const SR = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;    if (!SR) return null;    if (!nameRecRef.current) {      const rec = new SR();      rec.lang = "ko-KR";      rec.interimResults = false; // ?´ë¦„?€ ìµœì¢… ê²°ê³¼ë§??„ìš”      rec.maxAlternatives = 1;      nameRecRef.current = rec;    }    return nameRecRef.current;  }, []);  // TTS ?”í–¥ ì°¨ë‹¨  const stopTTSForName = useCallback(() => {    try {      window.speechSynthesis.cancel();    } catch {}  }, []);  // ???´ë¦„ ?¸ì‹ ìµœì¢… ì²˜ë¦¬  const onNameFinal = useCallback((transcript: string) => {    const cand = extractLikelyKoreanName(transcript);    if (!cand) {      setError("?´ë¦„ë§??ë ·?˜ê²Œ ë§ì???ì£¼ì„¸?? (?? ?ê¸¸??");      appendStt("???´ë¦„ ?„ë³´ ?†ìŒ");      return;    }    setName(cand);    setError(null); // ?ëŸ¬ ë©”ì‹œì§€ ?œê±°    appendStt(`???´ë¦„ ?¸ì‹: ${cand}`);    // ?ë™ ì§„í–‰ ê¸ˆì?: ?¬ìš©?ê? '?¤ìŒ' ?´ë¦­?´ì„œ ?¨ê³„ ?´ë™  }, []);  // ??"ë§í•˜ê¸??ì„œ ?¬ë¼??ìµœì¢… ?ìŠ¤?¸ë? ?¬ê¸°??ì²˜ë¦¬ (?ˆë¡œ??ë¡œì§)  const onEmailSpeechFinalLocal = useCallback((raw: string) => {    appendStt(`?“§ "${raw}"`);    let t = normalizeEmailMishear(raw).trim();   // ??ë³´ì • ë¨¼ì?    t = t.replace(DOT_WORDS, ".").replace(AT_WORDS, "@");    if (emailMode === "id") {      if (t.includes("@")) {        const [left, right = ""] = t.split("@");        const newId = (left || "").replace(/\s+/g, "").replace(/[^a-z0-9._-]/g, "");        setEmailId(prev => prev + newId);        appendStt(`?‘¤ ID += "${left}" ??"${emailId + newId}"`);        if (!domainSwitchedRef.current) {          domainSwitchedRef.current = true;          setEmailMode("domain");        }        const domSeed = fixCommonDomain(sanitizeDomain(right));        if (domSeed) setEmailDomain(prev => prev || domSeed);        appendStt(`?Œ DOMAIN seed: "${domSeed || right}"`);        return;      }      // provider ?¤ì›Œ?œê? ë¨¼ì? ?˜ì™”?¼ë©´ ?„í™˜ë§?      if (!emailId && /(gmail|naver|daum|hanmail|kakao)/.test(t)) {        if (!domainSwitchedRef.current) {          domainSwitchedRef.current = true;          setEmailMode("domain");        }        const domSeed = t.match(/(gmail|naver|daum|hanmail|kakao)/)?.[1] ?? "";        if (domSeed) setEmailDomain(prev => prev || fixCommonDomain(domSeed));        return;      }      // ?¼ë°˜ ?„ì´???„ì       const idAcc = (t || "").replace(/\s+/g, "").replace(/[^a-z0-9._-]/g, "");      if (idAcc) setEmailId(prev => prev + idAcc);      appendStt(`?‘¤ ID += "${t}" ??"${emailId + idAcc}"`);      return;    }    // mode === 'domain'    const domAcc = fixCommonDomain(sanitizeDomain(emailDomain + t));    setEmailDomain(domAcc);    appendStt(`?Œ DOMAIN += "${t}" ??"${domAcc}"`);    // **?”ë©´???…ë ¥ì¹¸ì—??ì¦‰ì‹œ ë³´ì´?„ë¡ ë¯¸ë¦¬ë³´ê¸° ê°?ë§Œë“¤?´ì£¼ê¸?*    setEmail(prev => {      const preview = emailId ? `${emailId}@${domAcc}` : prev;      return preview;    });  }, [emailMode, emailId, emailDomain, appendStt]);  // HTTPS ê°€??(ë¡œì»¬ localhost???ˆìš©)  useEffect(() => {    if (location.protocol !== "https:" && location.hostname !== "localhost") {      setError("? ï¸ ë³´ì•ˆ ê²½ê³ : ë§ˆì´???¬ìš©???„í•´ HTTPSê°€ ?„ìš”?©ë‹ˆ??");    }  }, []);  useEffect(() => {    // ?¨ê³„ ì§„ì… ??ê°„ë‹¨ ?ˆë‚´(?Œì„±)    const lines = [      "?´ë¦„??ë§ì???ì£¼ì„¸?? ?? ?ˆë…•?˜ì„¸???´ì¬ë§Œì…?ˆë‹¤",      "?´ë©”?¼ì„ ë§ì???ì£¼ì„¸?? ?? jaefan ê³¨ë±…??ì§€ë©”ì¼ ??ì»?,      "ë¹„ë?ë²ˆí˜¸ë¥?ë§ì???ì£¼ì„¸?? ê³µê°œ ?¥ì†Œ?ì„œ??ì§ì ‘ ?…ë ¥??ê¶Œì¥?©ë‹ˆ??",      "?…ë ¥ ?´ìš©???•ì¸?˜ê³  ê°€?…í•˜ê¸?ë²„íŠ¼???„ë¥´?¸ìš”.",    ];    speak(lines[step], locale);        // ?´ë©”???¨ê³„ ì§„ì… ??ì´ˆê¸°??    if (step === 1) {      setEmailId("");      setEmailDomain("");      setEmailMode("id");    }    // eslint-disable-next-line react-hooks/exhaustive-deps  }, [step]);  // ì»´í¬?ŒíŠ¸ ?¸ë§ˆ?´íŠ¸ ???•ë¦¬  useEffect(() => {    return () => {      try { nameRecRef.current?.stop(); nameRecRef.current?.abort(); } catch {}    };  }, []);  // useSTT ???•ì˜  function useSTT(    onText: (txt: string, isFinal: boolean) => void,    opts?: { onLog?: (s: string) => void }  ) {    const Recognition =      typeof window !== "undefined"        ? (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition        : undefined;    const [listening, setListening] = useState(false);    const [available, setAvailable] = useState(false);    const recRef = useRef<any>(null);    const backoffRef = useRef(0);    const userStopRef = useRef(false);    useEffect(() => {      if (!Recognition) { setAvailable(false); return; }      const rec = new Recognition();      recRef.current = rec;      rec.continuous = true;      rec.interimResults = true;      rec.maxAlternatives = 3;      rec.lang = "ko-KR";      rec.onstart = () => { opts?.onLog?.("??onstart"); };      rec.onresult = (e: any) => {        backoffRef.current = 0;        let final = "", interim = "";        const finals: string[] = [];        for (let i = e.resultIndex; i < e.results.length; i++) {          const alt = e.results[i];          const best = alt[0]?.transcript || "";          if (alt.isFinal) {            for (let k = 0; k < alt.length; k++) finals.push(alt[k].transcript);            final += best;          } else {            interim += best;          }        }        if (interim) opts?.onLog?.(`??${interim}`);        if (finals.length > 0) {          const joined = finals.join(" ");          opts?.onLog?.(`?¤ "${joined}"`);          onText(joined, true);        } else if (final) {          opts?.onLog?.(`?¤ "${final}"`);          onText(final, true);        } else if (interim) {          onText(interim, false);        }      };      rec.onerror = (e: any) => {        const code = e?.error || "unknown";        opts?.onLog?.(`??onerror: ${code}`);        setListening(false);        if (!userStopRef.current && code !== "aborted") {          setTimeout(() => {            try { rec.start(); setListening(true); } catch {}          }, 1000 + backoffRef.current * 1000);          backoffRef.current = Math.min(backoffRef.current + 1, 5);        }      };      rec.onend = () => {        opts?.onLog?.("??onend");        setListening(false);        if (!userStopRef.current) {          setTimeout(() => {            try { rec.start(); setListening(true); } catch {}          }, 500);        }      };      setAvailable(true);    }, []);    const start = useCallback(() => {      if (!recRef.current || listening) return;      userStopRef.current = false;      try {        recRef.current.start();        setListening(true);        opts?.onLog?.("?™ start");      } catch {}    }, [listening, opts]);    const stop = useCallback(() => {      userStopRef.current = true;      try { recRef.current?.stop(); } catch {}      setListening(false);      opts?.onLog?.("?›‘ stop");    }, [opts]);    const setUserStop = useCallback((stop: boolean) => {      userStopRef.current = stop;    }, []);    const forceStop = useCallback(() => {      userStopRef.current = true;      try { recRef.current?.abort(); } catch {}      // ?¬ì‹œ???€?´ë¨¸ ?œê±°      backoffRef.current = 0;    }, []);    return { start, stop, setUserStop, listening, available, forceStop };  }  // ?„ì¬ ?„ë“œ ?íƒœ ì¶”ê?  const [currentField, setCurrentField] = useState<"name" | "email" | "pw">("name");  // useSTT ???¬ìš©  const { start, stop, setUserStop, listening: sttListening, available: sttOK, forceStop } =    useSTT(async (text, isFinal) => {      // ?´ë¦„ ìº¡ì²˜ ì¤‘ì—” ?„ë¬´ ê²ƒë„ ?˜ì? ?Šë„ë¡?ê°€??      if (isCapturingNameRef.current) return;            // TTS ?ì½” ì°¨ë‹¨: ë¸”ë¡ë¦¬ìŠ¤??+ ?œê°„ì°??˜ë¦¬ê¸?      const raw = (text || "").trim();      if (TTS_BLOCKLIST.some((re) => re.test(raw))) {        // TTS ?ˆë‚´ ë©˜íŠ¸??ì¦‰ì‹œ ë¬´ì‹œ        return;      }      if (isEchoFromTTS(raw, lastTextRef.current, lastEndAtRef.current, TTS_ECHO_WINDOW_MS)) {        return;      }            // ?´ë¦„ ?¨ê³„?ì„œ TTS ë¬¸ì¥ ?¤ì¸??ë°©ì?      if (step === 1 && isFinal) {        const cleanKo = raw.replace(/[^\uAC00-\uD7A3]/g, "");        if (cleanKo.length < 2) return; // ?ˆë¬´ ì§§ìŒ        if (/?©ë‹ˆ???•ì¸?ˆìŠµ?ˆë‹¤/.test(raw)) return; // ?ˆë‚´ ë©˜íŠ¸ ?¤ì¸??ì»?      }            if (!isFinal) return;            // ?„ë“œë³?ì²˜ë¦¬ ë¡œì§      if (currentField === "name") {        onNameFinal(text);        // "?´ë¦„???•ì¸?ˆìŠµ?ˆë‹¤" ì¤‘ë³µ ?¸ì¶œ ?œê±° - TTS ë£¨í”„ ë°©ì?      } else if (currentField === "email") {        onEmailSpeechFinalLocal(text);        const id = emailId.trim();        const dom = fixCommonDomain(emailDomain.trim());        if (isLikelyEmail(id, dom)) {          setEmail(`${id}@${dom}`);          appendStt(`???´ë©”???„ì„±: ${id}@${dom}`);          lastTextRef.current = `?´ë©”??${id}@${dom} ?•ì¸?ˆìŠµ?ˆë‹¤.`;          lastEndAtRef.current = Date.now();          speak(`?´ë©”??${id}@${dom} ?•ì¸?ˆìŠµ?ˆë‹¤.`, locale);              } else {        const currentStatus = emailMode === "id" ? `ID: ${id}` : `?„ë©”?? ${dom}`;        appendStt(`?„ì¬ ${currentStatus} ?…ë ¥ ì¤?);        lastTextRef.current = `?„ì¬ ${currentStatus} ?…ë ¥ ì¤‘ì…?ˆë‹¤.`;        lastEndAtRef.current = Date.now();        speak(`?„ì¬ ${currentStatus} ?…ë ¥ ì¤‘ì…?ˆë‹¤.`, locale);      }            // ?´ë©”???„ì„± ???ë™ ì§„í–‰ ì²´í¬      maybeAutoNext();      } else if (currentField === "pw") {        const pw = text.trim();        setPw(pw);        if (!isStrongPassword(pw)) {          setError("ë¹„ë?ë²ˆí˜¸??8???´ìƒ?´ì–´???©ë‹ˆ??");          lastTextRef.current = "ë¹„ë?ë²ˆí˜¸??8???´ìƒ?´ì–´???©ë‹ˆ??";          lastEndAtRef.current = Date.now();          speak("ë¹„ë?ë²ˆí˜¸??8???´ìƒ?´ì–´???©ë‹ˆ??", locale);        } else {          appendStt(`??ë¹„ë?ë²ˆí˜¸ ?•ì¸: ${pw.length}??);          lastTextRef.current = "ë¹„ë?ë²ˆí˜¸ ?•ì¸?ˆìŠµ?ˆë‹¤.";          lastEndAtRef.current = Date.now();          speak("ë¹„ë?ë²ˆí˜¸ ?•ì¸?ˆìŠµ?ˆë‹¤.", locale);        }      }      // "ìµœì¢…ê²°ê³¼ ?†ìŒ" ?ˆë‚´ ?€?´ë¨¸ ?„ì  ë²„ê·¸ ?˜ì •      if (noFinalTimerRef.current) {        clearTimeout(noFinalTimerRef.current);        noFinalTimerRef.current = null;      }      noFinalTimerRef.current = window.setTimeout(() => {        if (sttListening) {          speakGuarded("??ëª©ì†Œë¦¬ê? ???¤ë¦¬ì§€ ?ŠëŠ” ê²?ê°™ì•„?? ë§ˆì´??ê°€ê¹Œì´?ì„œ ?ë ·?˜ê²Œ ë§ì???ì£¼ì„¸??", { restart: true });        }      }, 6000);    }, { onLog: appendStt });  // forceStop??ref???€??(?Œë” ?œì„œ ë¬¸ì œ ?´ê²°)  React.useEffect(() => {    forceStopRef.current = forceStop;  }, [forceStop]);  // ?ì—°???Œì‹± ê²°ê³¼ ?„ë¦¬???ìš©  React.useEffect(() => {    const q = new URLSearchParams(locationHook.search);    if (q.get("from") === "nat") {      try {        const raw = localStorage.getItem("vibe:preset");        if (raw) {          const p = JSON.parse(raw);          setName(p.name ?? "");          setEmail(p.email ?? "");          setPw(p.password ?? "");          // ?„í™”ë²ˆí˜¸??ê°€???¼ì— ?†ìœ¼ë©??€?¥ë§Œ (?„ë“œ ?ˆìœ¼ë©?ì¶”ê?)          setStep(3); // ë°”ë¡œ "?•ì¸ ??ê°€?? ?¨ê³„ë¡?          localStorage.removeItem("vibe:preset");        }      } catch {}    }  }, [locationHook.search]); // eslint-disable-line  // ???´ë¦„ ?„ìš© STT ?œì‘ (useSTT ???´í›„???•ì˜)  const startName = useCallback(() => {    // 1) ?„ì—­ STT ?„ì „ ì¤‘ë‹¨(?¬ì‹œ???€?´ë¨¸ê¹Œì?)    isCapturingNameRef.current = true;    setUserStop(true);    forceStop?.();         // <= useSTTê°€ ?œê³µ (abort + restartTimer clear)    setUserStop(false);    // 2) TTSê°€ ë§í•˜ê³??ˆìœ¼ë©?ì¦‰ì‹œ ì¤‘ì? (?ì½”/ë£¨í”„ ë°©ì?)    try { window.speechSynthesis?.cancel(); } catch {}    // 3) ?”í–¥ ë°©ì?ë¡??´ì§ ??²Œ ?´ë¦„ ?¸ì‹ê¸??œì‘    setTimeout(() => {      const SR = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;      if (!SR) { setError("ë¸Œë¼?°ì?ê°€ STTë¥?ì§€?í•˜ì§€ ?Šì•„??https/localhost ?„ìš”)"); isCapturingNameRef.current = false; return; }      const rec = new SR();      nameRecRef.current = rec;      rec.lang = "ko-KR";      rec.continuous = false;      rec.interimResults = true;      rec.maxAlternatives = 3;      rec.onstart  = () => appendStt("??onstart(name)");      rec.onresult = (e: any) => {        const text = Array.from(e.results).map((r: any) => r[0].transcript).join(" ");        appendStt(`?¤(name) "${text}"`);        onNameFinal(text);                       // ???´ë¦„ ì¶”ì¶œ/ë°˜ì˜ ?¨ìˆ˜      };      rec.onnomatch = () => appendStt("??onnomatch(name)");      rec.onerror = (err: any) => { appendStt(`??onerror(name): ${err?.error || err}`); setNameListening(false); };      rec.onend   = () => { appendStt("??onend(name)"); setNameListening(false); isCapturingNameRef.current = false; };      try { rec.start(); setNameListening(true); } catch {}    }, 300);  }, [appendStt, onNameFinal, forceStop, setUserStop]);  // ???´ë¦„ ?¸ì‹ ì¢…ë£Œ ?¨ìˆ˜  const stopName = useCallback(() => {    try { nameRecRef.current?.stop(); } catch {}    isCapturingNameRef.current = false;  }, []);  // ??"?„ì„± ?„ë³´"???Œë§Œ ì»¤ë°‹ + ë¡œê·¸ (useSTT ???´í›„???•ì˜)  const onTryNext = useCallback(() => {    const domFixed = fixCommonDomain(emailDomain);    if (isLikelyEmail(emailId, domFixed)) {      const finalEmail = `${emailId}@${domFixed}`;      setEmail(finalEmail);      appendStt(`??EMAIL ?•ì •: ${finalEmail}`);      // ì´ˆê¸°??ë°??¤ìŒ ?¨ê³„      setEmailMode("id");      domainSwitchedRef.current = false;      setEmailId("");       setEmailDomain("");      setStep(3);    } else {      appendStt("???„ì§ ?´ë©”???•ì‹???„ì„±?˜ì? ?Šì•˜?µë‹ˆ??");    }  }, [emailId, emailDomain, setEmail, appendStt, setEmailMode, setStep]);  // ê¸°ì¡´ doListen ?¨ìˆ˜ (?¸í™˜?±ì„ ?„í•´ ? ì?)  const doListen = (field: "name" | "email" | "pw") => {    setCurrentField(field);    if (sttListening) return;    setError(null);    start();    try {      const SR = window.webkitSpeechRecognition || window.SpeechRecognition;      if (!SR) {        setListening(false);        setError("??ë¸Œë¼?°ì????Œì„± ?¸ì‹??ì§€?í•˜ì§€ ?ŠìŠµ?ˆë‹¤. Chrome/Edgeë¥?ê¶Œì¥?©ë‹ˆ??");        return;      }      const r: any = new SR();      r.lang = locale;      r.interimResults = true;      r.maxAlternatives = 2;      r.continuous = false;      let finalText = "";      let interimText = "";      r.onstart = () => log("??onstart");      r.onresult = (e: any) => {        for (let i = e.resultIndex; i < e.results.length; i++) {          const res = e.results[i];          const t = (res?.[0]?.transcript || "").trim();          if (!t) continue;          if (res.isFinal) finalText = t;          else interimText = t;        }        log(`?¯ onresult: "${finalText || interimText}"`);      };      r.onerror = (e: any) => {        const code = e?.error || "unknown";        log(`??onerror: ${code}`);        setError(          code === "not-allowed"            ? "ë§ˆì´??ê¶Œí•œ??ê±°ë??˜ì—ˆ?µë‹ˆ?? ì£¼ì†Œì°??¼ìª½ ?”’?ì„œ ?ˆìš©?¼ë¡œ ë³€ê²½í•´ ì£¼ì„¸??"            : code === "audio-capture"            ? "ë§ˆì´???¥ì¹˜ë¥?ì°¾ì„ ???†ìŠµ?ˆë‹¤. OS???…ë ¥ ?¥ì¹˜ë¥??•ì¸??ì£¼ì„¸??"            : code === "no-speech"            ? "ë§ì†Œë¦¬ê? ê°ì??˜ì? ?Šì•˜?µë‹ˆ?? ì¡°ê¸ˆ ???¬ê²Œ ?ë ·?˜ê²Œ ë§ì???ì£¼ì„¸??"            : "?Œì„± ?¸ì‹ ?¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤. ?¤ì‹œ ?œë„??ì£¼ì„¸??"        );      };      r.onend = () => {        log("??onend");        setListening(false);        const text = (finalText || interimText || "").trim();        if (!text) return;        if (field === "name") {              // 1?¨ê³„: ?´ë¦„ ?¸ì‹ (?ë™ ì§„í–‰ ?œê±°)              if (!finalText) return;              const cand = extractLikelyKoreanName(text);              if (cand && cand.replace(/[^\uAC00-\uD7A3]/g, "").length >= 2) {                setName(cand);                log(`???´ë¦„ ?¸ì‹: ${cand}`);                speak(`?´ë¦„ ${cand} ?•ì¸?ˆìŠµ?ˆë‹¤.`, locale);                // ?ë™ ì§„í–‰ ê¸ˆì?: ?¬ìš©?ê? '?¤ìŒ' ?´ë¦­?´ì„œ ?¨ê³„ ?´ë™          } else {                if (typeof log === "function") {                  log("?¹ï¸ ??ê¸€???´ìƒ???´ë¦„?¼ë¡œ ë§ì???ì£¼ì„¸??");                }                setError("?´ë¦„???¸ì‹?˜ì? ëª»í–ˆ?µë‹ˆ?? ?¤ì‹œ ë§ì???ì£¼ì„¸??");                speak("?´ë¦„???¸ì‹?˜ì? ëª»í–ˆ?µë‹ˆ?? ?¤ì‹œ ë§ì???ì£¼ì„¸??", locale);          }        } else if (field === "email") {          // 2?¨ê³„: ?´ë©”??          if (!finalText) return;          onEmailSpeechFinal(text);          // ?„ì  ê²°ê³¼ë¡?email ê°±ì‹ (????ì¤€ë¹„ë˜ë©?          const id = emailId.trim();          const dom = fixCommonDomain(emailDomain.trim());          if (isLikelyEmail(id, dom)) {            setEmail(`${id}@${dom}`);            speak(`?´ë©”??${id}@${dom} ?•ì¸?ˆìŠµ?ˆë‹¤.`, locale);          } else {            // ?„ì¬ ?„ì  ?íƒœ ?ˆë‚´            const currentStatus = emailMode === "id" ? `ID: ${id}` : `?„ë©”?? ${dom}`;            speak(`?„ì¬ ${currentStatus} ?…ë ¥ ì¤‘ì…?ˆë‹¤.`, locale);          }        } else {          const v = text.replace(/\s+/g, "");          setPw(v);          if (!isStrongPassword(v)) {            setError("ë¹„ë?ë²ˆí˜¸??8???´ìƒ?´ì–´???©ë‹ˆ??");            speak("ë¹„ë?ë²ˆí˜¸??8???´ìƒ?´ì–´???©ë‹ˆ??", locale);          } else {            speak("ë¹„ë?ë²ˆí˜¸ ?•ì¸?ˆìŠµ?ˆë‹¤.", locale);          }        }      };      r.start();      log(`?™ start(lang=${r.lang})`);    } catch (err: any) {      setListening(false);      setError(err?.message || "?Œì„± ?¸ì‹ ì´ˆê¸°???¤íŒ¨");    }  };  // ?œë˜?„íŠ¸ ?´ë©”???„ì„±???•ì¸  const draftEmail = emailId && emailDomain ? `${emailId}@${fixCommonDomain(emailDomain)}` : "";  const stepValid =    (step === 0 && cleanName(name.trim()).length >= 2) ||    (step === 1 && (isValidEmail(email.trim()) || isValidEmail(draftEmail))) ||    (step === 2 && isStrongPassword(pw)) ||    step === 3;  const next = () => {    if (!stepValid) return;        // 2?¨ê³„ -> 3?¨ê³„ ?´ë™ ì§ì „ ?´ë©”??ë³´ì •    if (step === 1) {      const finalEmail = email || draftEmail;      if (isValidEmail(finalEmail)) {        setEmail(finalEmail);        // ?œë˜?„íŠ¸ ì´ˆê¸°??        setEmailId("");         setEmailDomain("");         setEmailMode("id");         domainSwitchedRef.current = false;      }    }        const nextStep = Math.min(3, step + 1) as Step;    setStep(nextStep);        // ?¨ê³„ë³?TTS ?ˆë‚´ (STT??? ê¹ ?¬ê²Œ)    if (nextStep === 1) {      speakGuarded("?´ë¦„???…ë ¥??ì£¼ì„¸??", { restart: false });    } else if (nextStep === 2) {      speakGuarded("?´ë©”??ì£¼ì†Œë¥??…ë ¥??ì£¼ì„¸??", { restart: false });    } else if (nextStep === 3) {      speakGuarded("ë¹„ë?ë²ˆí˜¸ë¥??…ë ¥??ì£¼ì„¸??", { restart: false });    }  };  const prev = () => setStep((s) => (Math.max(0, s - 1) as Step));  // Firebase ê°€???ë¦„  async function submitSignUp() {    if (!isValidEmail(email) || !isStrongPassword(pw)) return;    setBusy(true);    setError(null);    try {      // ì¤‘ë³µ ?´ë©”??ë¯¸ë¦¬ ?•ì¸(UX ì¹œí™”)              // auth?€ db???´ë? ?„ì—???•ì˜??      const methods = await fetchSignInMethodsForEmail(auth, email);      if (methods && methods.length > 0) {        setError("?´ë? ê°€?…ëœ ?´ë©”?¼ì…?ˆë‹¤. ?¤ë¥¸ ?´ë©”?¼ì„ ?¬ìš©??ì£¼ì„¸??");        speak("?´ë? ê°€?…ëœ ?´ë©”?¼ì…?ˆë‹¤.", locale);        setBusy(false);        return;      }      const cred = await createUserWithEmailAndPassword(auth, email, pw);      // (?´ë¦„?€ ë³´í†µ updateProfileë¡??œì‹œëª??¤ì •. ?„ìš” ??ì¶”ê?)      speak("?Œì›ê°€?…ì´ ?„ë£Œ?˜ì—ˆ?µë‹ˆ?? ?˜ì˜?©ë‹ˆ??", locale);      alert(`ê°€???„ë£Œ! ?˜ì˜?©ë‹ˆ?? ${name || "?¬ìš©??}??);      console.log("??user:", cred.user);      // TODO: ?¼ìš°???´ë™ ??    } catch (e: any) {      const msg = e?.message || "ê°€??ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.";      setError(msg);      speak("ê°€??ì¤??¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤.", locale);    } finally {      setBusy(false);    }  }  // -------------------- UI --------------------  const wrap: React.CSSProperties = {    maxWidth: 560,    margin: "32px auto",    padding: "0 16px",    fontFamily: "system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif",  };  const title: React.CSSProperties = { fontSize: 22, fontWeight: 800, margin: "12px 0 4px" };  const sub: React.CSSProperties = { color: "#64748b", marginBottom: 16 };  const row: React.CSSProperties = { display: "flex", gap: 8, alignItems: "center" };  const btn: React.CSSProperties = {    border: 0,    background: "#2563eb",    color: "#fff",    padding: "10px 14px",    borderRadius: 10,    cursor: "pointer",    fontWeight: 700,  };  const ghost: React.CSSProperties = {    border: "2px solid #e2e8f0",    background: "#fff",    color: "#334155",    padding: "8px 12px",    borderRadius: 10,    cursor: "pointer",    fontWeight: 700,  };  const input: React.CSSProperties = {    flex: 1,    border: "2px solid #e2e8f0",    borderRadius: 10,    padding: "10px 12px",    outline: "none",  };  const danger: React.CSSProperties = { color: "#dc2626", marginTop: 8 };  return (    <div style={wrap}>      <h2 style={title}>?Œì„± ?Œì›ê°€??/h2>      <div style={sub}>        ?¸ì–´: {locale}{" "}        {location.protocol !== "https:" && location.hostname !== "localhost" && (          <span style={{ color: "#b91c1c", marginLeft: 8 }}>            (HTTP ?˜ê²½: ë§ˆì´???œì•½ ê°€??          </span>        )}      </div>      {/* ì§„í–‰ ë°?*/}      <div style={{ height: 8, background: "#e2e8f0", borderRadius: 6, overflow: "hidden", margin: "12px 0 24px" }}>        <div          style={{            height: "100%",            width: `${(step + 1) * 25}%`,            background: "#2563eb",            transition: "width .15s",          }}        />      </div>      {step === 0 && (        <section>          <h3 style={title}>1/4 ?´ë¦„ ë§í•˜ê¸?/h3>          <p style={sub}>?? "?ˆë…•?˜ì„¸???´ì¬ë§Œì…?ˆë‹¤" / "???´ë¦„?€ ë°±ìŠ¹ê¶Œì´?ìš”"</p>          <div style={row}>            <input              style={input}              aria-label="?´ë¦„"              placeholder="?´ë¦„"              value={name}              onChange={(e) => setName(e.target.value)}            />            <button               style={ghost}               onClick={() => (!nameListening ? startName() : stopName())}            >              {nameListening ? "?£ê¸° ì¢…ë£Œ" : "?™ ë§í•˜ê¸?}            </button>          </div>          {name && cleanName(name).length < 2 && <div style={danger}>?´ë¦„???ˆë¬´ ì§§ìŠµ?ˆë‹¤.</div>}        </section>      )}      {step === 1 && (        <section>          <h3 style={title}>2/4 ?´ë©”??ë§í•˜ê¸?/h3>          <p style={sub}>?? "?´ë©”?¼ì? jaeman ê³¨ë±…??ì§€ë©”ì¼ ??ì»?</p>                    {/* EmailVoiceField ?¬ìš© */}          <EmailVoiceField            emailId={emailId}            emailDomain={emailDomain}            mode={emailMode}            setEmailId={setEmailId}            setEmailDomain={setEmailDomain}            setMode={setEmailMode}            domainSwitchedRef={domainSwitchedRef}            pushLog={log}            onTryNext={() => {              const finalEmail = email || (emailId && emailDomain ? `${emailId}@${fixCommonDomain(emailDomain)}` : "");              if (isValidEmail(finalEmail)) {                setEmail(finalEmail);                // ?œë˜?„íŠ¸ ì´ˆê¸°??                setEmailId("");                 setEmailDomain("");                 setEmailMode("id");                domainSwitchedRef.current = false;                setStep(2); // ë¹„ë?ë²ˆí˜¸ ?¨ê³„ë¡??´ë™              }            }}            onFinal={onEmailSpeechFinalLocal}          />                    {/* ?˜ë™ ?…ë ¥ ?„ë“œ */}          <div style={{ marginTop: 16 }}>            <label style={{ display: "block", marginBottom: 8, fontWeight: 600 }}>?˜ë™ ?…ë ¥</label>            <input              style={input}              aria-label="?´ë©”??              placeholder="?´ë©”?¼ì„ ì§ì ‘ ?…ë ¥?˜ì„¸??              value={email}              onChange={(e) => {                setEmail(e.target.value);                if (e.target.value) {                   setEmailId("");                   setEmailDomain("");                   setEmailMode("id");                  domainSwitchedRef.current = false;                }              }}            />          </div>                    {!isValidEmail(email) && email && <div style={danger}>?¬ë°”ë¥??´ë©”???•ì‹???„ë‹™?ˆë‹¤.</div>}        </section>      )}      {step === 2 && (        <section>          <h3 style={title}>3/4 ë¹„ë?ë²ˆí˜¸ ë§í•˜ê¸?/h3>          <p style={sub}>8???´ìƒ ê¶Œì¥. (ê³µê°œ ?¥ì†Œ?ì„œ??ì§ì ‘ ?…ë ¥ ê¶Œì¥)</p>          <div style={row}>            <input              style={input}              type="password"              aria-label="ë¹„ë?ë²ˆí˜¸"              placeholder="ë¹„ë?ë²ˆí˜¸"              value={pw}              onChange={(e) => setPw(e.target.value)}            />            <button style={ghost} onClick={() => doListen("pw")} disabled={listening}>              {listening ? "?£ëŠ” ì¤?.." : "?™ ë§í•˜ê¸?}            </button>          </div>          {!isStrongPassword(pw) && pw && <div style={danger}>ë¹„ë?ë²ˆí˜¸??8???´ìƒ?´ì–´???©ë‹ˆ??</div>}        </section>      )}      {step === 3 && (        <section>          <h3 style={title}>4/4 ?•ì¸ ??ê°€??/h3>          <ul style={{ lineHeight: 1.8, color: "#334155" }}>            <li><b>?´ë¦„</b>: {name || "-"}</li>            <li><b>?´ë©”??/b>: {email || "-"}</li>          </ul>          <p style={{ color: "#64748b" }}>??ë¹„ë?ë²ˆí˜¸??ë³´ì•ˆ???œì‹œ?˜ì? ?ŠìŠµ?ˆë‹¤.</p>        </section>      )}      {/* ?¤ë¥˜ */}      {error && <div style={danger}>{error}</div>}      {/* STT ë¡œê·¸ (?”ë²„ê·¸ìš©) */}      <div style={{ marginTop: 16, padding: 12, background: "#f8fafc", borderRadius: 8, border: "1px solid #e2e8f0" }}>        <div style={{ fontSize: 12, fontWeight: 600, color: "#475569", marginBottom: 8 }}>?¤ STT ë¡œê·¸</div>        <div          style={{            height: 120,            overflow: "auto",            fontSize: 11,            fontFamily: "monospace",            background: "#0f172a",            color: "#e2e8f0",            padding: 8,            borderRadius: 4,          }}        >          {sttLog.length === 0            ? <span style={{ color: "#64748b" }}>?Œì„± ?¸ì‹???œì‘?˜ë©´ ë¡œê·¸ê°€ ?œì‹œ?©ë‹ˆ??..</span>            : sttLog.map((msg, i) => <div key={i} style={{ marginBottom: 2 }}>{msg}</div>)}        </div>      </div>      {/* ?´ë¹„ê²Œì´??*/}      <div style={{ display: "flex", gap: 8, marginTop: 16 }}>        <button style={ghost} onClick={prev} disabled={step === 0}>?´ì „</button>        {step < 3 ? (          <button style={{ ...btn, opacity: stepValid ? 1 : 0.6 }} onClick={next} disabled={!stepValid}>            ?¤ìŒ          </button>        ) : (          <button            style={{ ...btn, opacity: stepValid && !busy ? 1 : 0.6 }}            onClick={submitSignUp}            disabled={!stepValid || busy}          >            {busy ? "ê°€??ì¤?.." : "ê°€?…í•˜ê¸?}          </button>        )}      </div>    </div>  );}