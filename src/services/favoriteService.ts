import {   doc,   setDoc,   deleteDoc,   getDoc,   collection,   query,   getDocs,   orderBy,  onSnapshot,  writeBatch,  serverTimestamp} from 'firebase/firestore';import { db } from '@/lib/firebase';import type { MarketItem } from '../features/market/types';// ì°œí•˜ê¸??€??export interface FavoriteItem {  id: string;  productId: string;  uid: string;  createdAt: any; // Firestore Timestamp  item?: MarketItem; // ?í’ˆ ?•ë³´ (?µì…˜)}// ì°œí•˜ê¸?ì¶”ê?export const addToFavorites = async (uid: string, productId: string): Promise<void> => {  try {    const favoriteRef = doc(db, 'users', uid, 'favorites', productId);    await setDoc(favoriteRef, {      productId,      createdAt: serverTimestamp(),    }, { merge: true });    console.log('ì°œí•˜ê¸?ì¶”ê? ?„ë£Œ:', productId);  } catch (error) {    console.error('ì°œí•˜ê¸?ì¶”ê? ?¤íŒ¨:', error);    throw new Error('ì°œí•˜ê¸?ì¶”ê????¤íŒ¨?ˆìŠµ?ˆë‹¤.');  }};// ì°œí•˜ê¸??œê±°export const removeFromFavorites = async (uid: string, productId: string): Promise<void> => {  try {    const favoriteRef = doc(db, 'users', uid, 'favorites', productId);    await deleteDoc(favoriteRef);    console.log('ì°œí•˜ê¸??œê±° ?„ë£Œ:', productId);  } catch (error) {    console.error('ì°œí•˜ê¸??œê±° ?¤íŒ¨:', error);    throw new Error('ì°œí•˜ê¸??œê±°???¤íŒ¨?ˆìŠµ?ˆë‹¤.');  }};// ì°œí•˜ê¸??íƒœ ?•ì¸export const isFavorite = async (uid: string, productId: string): Promise<boolean> => {  try {    const favoriteRef = doc(db, 'users', uid, 'favorites', productId);    const docSnap = await getDoc(favoriteRef);    return docSnap.exists();  } catch (error) {    console.error('ì°œí•˜ê¸??íƒœ ?•ì¸ ?¤íŒ¨:', error);    return false;  }};// ?¬ìš©?ì˜ ì°œí•œ ?í’ˆ ëª©ë¡ ì¡°íšŒexport const getUserFavorites = async (uid: string): Promise<FavoriteItem[]> => {  try {    const favoritesRef = collection(db, 'users', uid, 'favorites');    const q = query(favoritesRef, orderBy('createdAt', 'desc'));    const querySnapshot = await getDocs(q);        const favorites: FavoriteItem[] = [];    querySnapshot.forEach((doc) => {      favorites.push({        id: doc.id,        ...doc.data()      } as FavoriteItem);    });        return favorites;  } catch (error) {    console.error('ì°œí•œ ?í’ˆ ëª©ë¡ ì¡°íšŒ ?¤íŒ¨:', error);    return [];  }};// ì°œí•œ ?í’ˆ???ì„¸ ?•ë³´?€ ?¨ê»˜ ì¡°íšŒexport const getUserFavoritesWithDetails = async (uid: string): Promise<(FavoriteItem & { item: MarketItem })[]> => {  try {    const favorites = await getUserFavorites(uid);        // ê°?ì°œí•œ ?í’ˆ???ì„¸ ?•ë³´ ì¡°íšŒ    const favoritesWithDetails = await Promise.all(      favorites.map(async (favorite) => {        try {          const itemRef = doc(db, 'products', favorite.productId);          const itemSnap = await getDoc(itemRef);                    if (itemSnap.exists()) {            return {              ...favorite,              item: { id: itemSnap.id, ...itemSnap.data() } as MarketItem            };          } else {            // ?í’ˆ???? œ??ê²½ìš°            return {              ...favorite,              item: undefined            };          }        } catch (error) {          console.error('?í’ˆ ?•ë³´ ì¡°íšŒ ?¤íŒ¨:', favorite.productId, error);          return {            ...favorite,            item: undefined          };        }      })    );        // ?í’ˆ ?•ë³´ê°€ ?ˆëŠ” ê²ƒë§Œ ?„í„°ë§?    return favoritesWithDetails.filter(fav => fav.item) as (FavoriteItem & { item: MarketItem })[];  } catch (error) {    console.error('ì°œí•œ ?í’ˆ ?ì„¸ ?•ë³´ ì¡°íšŒ ?¤íŒ¨:', error);    return [];  }};// ?¤ì‹œê°?ì°œí•œ ?í’ˆ ëª©ë¡ êµ¬ë…export const subscribeToUserFavorites = (  uid: string,  callback: (favorites: FavoriteItem[]) => void) => {  try {    const favoritesRef = collection(db, 'users', uid, 'favorites');    const q = query(favoritesRef, orderBy('createdAt', 'desc'));        return onSnapshot(q, (snapshot) => {      const favorites: FavoriteItem[] = [];      snapshot.forEach((doc) => {        favorites.push({          id: doc.id,          ...doc.data()        } as FavoriteItem);      });            callback(favorites);    });  } catch (error) {    console.error('ì°œí•œ ?í’ˆ ?¤ì‹œê°?êµ¬ë… ?¤íŒ¨:', error);    return () => {};  }};// ì°œí•œ ?í’ˆ ê°œìˆ˜ ì¡°íšŒexport const getFavoriteCount = async (uid: string): Promise<number> => {  try {    const favorites = await getUserFavorites(uid);    return favorites.length;  } catch (error) {    console.error('ì°œí•œ ?í’ˆ ê°œìˆ˜ ì¡°íšŒ ?¤íŒ¨:', error);    return 0;  }};// ?í’ˆ??ì°œí•œ ?¬ìš©????ì¡°íšŒexport const getItemFavoriteCount = async (productId: string): Promise<number> => {  try {    // ëª¨ë“  ?¬ìš©?ì˜ ì°œí•œ ?í’ˆ?ì„œ ?´ë‹¹ ?í’ˆ??ì°¾ê¸°    // ?¤ì œ ?´ì˜?ì„œ??ë³„ë„ ?„ë“œë¡?ê´€ë¦¬í•˜??ê²ƒì´ ?¨ìœ¨??    const usersRef = collection(db, 'users');    const usersSnap = await getDocs(usersRef);        let totalCount = 0;        for (const userDoc of usersSnap.docs) {      const userFavoritesRef = collection(db, 'users', userDoc.id, 'favorites');      const itemSnap = await getDoc(doc(userFavoritesRef, productId));      if (itemSnap.exists()) {        totalCount++;      }    }        return totalCount;  } catch (error) {    console.error('?í’ˆ ì°œí•œ ?¬ìš©????ì¡°íšŒ ?¤íŒ¨:', error);    return 0;  }};// ì°œí•˜ê¸??¼ê´„ ì²˜ë¦¬ (?¬ëŸ¬ ?í’ˆ????ë²ˆì— ì°œí•˜ê¸??œê±°)export const batchUpdateFavorites = async (  uid: string,  operations: { productId: string; action: 'add' | 'remove' }[]): Promise<void> => {  try {    const batch = writeBatch(db);        operations.forEach(({ productId, action }) => {      const favoriteRef = doc(db, 'users', uid, 'favorites', productId);            if (action === 'add') {        batch.set(favoriteRef, {          productId,          createdAt: serverTimestamp()        });      } else if (action === 'remove') {        batch.delete(favoriteRef);      }    });        await batch.commit();    console.log('ì°œí•˜ê¸??¼ê´„ ì²˜ë¦¬ ?„ë£Œ:', operations.length, 'ê°?);  } catch (error) {    console.error('ì°œí•˜ê¸??¼ê´„ ì²˜ë¦¬ ?¤íŒ¨:', error);    throw new Error('ì°œí•˜ê¸??¼ê´„ ì²˜ë¦¬???¤íŒ¨?ˆìŠµ?ˆë‹¤.');  }};// ì°œí•œ ?í’ˆ ê²€??(?œëª©, ?œê·¸ ?±ìœ¼ë¡?export const searchFavorites = async (  uid: string,  searchQuery: string): Promise<(FavoriteItem & { item: MarketItem })[]> => {  try {    const allFavorites = await getUserFavoritesWithDetails(uid);        if (!searchQuery.trim()) {      return allFavorites;    }        const queryLower = searchQuery.toLowerCase();        return allFavorites.filter((favorite) => {      const item = favorite.item;      if (!item) return false;            // ?œëª© ê²€??      if (item.title.toLowerCase().includes(queryLower)) {        return true;      }            // ?¤ëª… ê²€??      if (item.description.toLowerCase().includes(queryLower)) {        return true;      }            // ì¹´í…Œê³ ë¦¬ ê²€??      if (item.category && item.category.toLowerCase().includes(queryLower)) {        return true;      }            // AI ?œê·¸ ê²€??      if (item.ai?.tags) {        const tagMatch = item.ai.tags.some(tag =>           tag.toLowerCase().includes(queryLower)        );        if (tagMatch) return true;      }            // ë¸Œëœ??ê²€??      if (item.ai?.brand && item.ai.brand.toLowerCase().includes(queryLower)) {        return true;      }            return false;    });  } catch (error) {    console.error('ì°œí•œ ?í’ˆ ê²€???¤íŒ¨:', error);    return [];  }}; 