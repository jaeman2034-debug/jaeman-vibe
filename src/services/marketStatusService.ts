import {   doc,   getDoc,   updateDoc,   collection,   query,   where,   orderBy,   getDocs,  onSnapshot,  writeBatch} from 'firebase/firestore';import { db } from '@/lib/firebase';import type { MarketItem } from '../features/market/types';// ?í’ˆ ?íƒœ ?€??export type ItemStatus = 'active' | 'reserved' | 'sold';// ?íƒœ ë³€ê²??´ë ¥ ?€??export interface StatusChangeHistory {  id: string;  itemId: string;  userId: string;  oldStatus: ItemStatus;  newStatus: ItemStatus;  reason?: string;  createdAt: any; // Firestore Timestamp}// ?íƒœ ë³€ê²?ê¶Œí•œ ?•ì¸export const canUpdateStatus = async (itemId: string, userId: string): Promise<boolean> => {  try {    const itemRef = doc(db, 'market_items', itemId);    const itemSnap = await getDoc(itemRef);        if (!itemSnap.exists()) {      return false;    }        const itemData = itemSnap.data() as MarketItem;    return itemData.ownerId === userId;  } catch (error) {    console.error('?íƒœ ë³€ê²?ê¶Œí•œ ?•ì¸ ?¤íŒ¨:', error);    return false;  }};// ?í’ˆ ?íƒœ ?…ë°?´íŠ¸export const updateItemStatus = async (  itemId: string,   userId: string,   newStatus: ItemStatus,  reason?: string): Promise<void> => {  try {    // ê¶Œí•œ ?•ì¸    const hasPermission = await canUpdateStatus(itemId, userId);    if (!hasPermission) {      throw new Error('?í’ˆ ?íƒœë¥?ë³€ê²½í•  ê¶Œí•œ???†ìŠµ?ˆë‹¤.');    }    // ?„ì¬ ?íƒœ ì¡°íšŒ    const itemRef = doc(db, 'market_items', itemId);    const itemSnap = await getDoc(itemRef);        if (!itemSnap.exists()) {      throw new Error('?í’ˆ??ì°¾ì„ ???†ìŠµ?ˆë‹¤.');    }        const currentData = itemSnap.data() as MarketItem;    const oldStatus = currentData.status;    // ?íƒœ ë³€ê²½ì´ ?¤ì œë¡??„ìš”?œì? ?•ì¸    if (oldStatus === newStatus) {      console.log('?íƒœê°€ ?´ë? ?™ì¼?©ë‹ˆ??', newStatus);      return;    }    // ?í’ˆ ?íƒœ ?…ë°?´íŠ¸    await updateDoc(itemRef, {      status: newStatus,      updatedAt: new Date()    });    // ?íƒœ ë³€ê²??´ë ¥ ?€??    await saveStatusChangeHistory(itemId, userId, oldStatus, newStatus, reason);    console.log('?í’ˆ ?íƒœ ?…ë°?´íŠ¸ ?„ë£Œ:', {      itemId,      oldStatus,      newStatus,      reason    });  } catch (error) {    console.error('?í’ˆ ?íƒœ ?…ë°?´íŠ¸ ?¤íŒ¨:', error);    throw error;  }};// ?íƒœ ë³€ê²??´ë ¥ ?€??const saveStatusChangeHistory = async (  itemId: string,  userId: string,  oldStatus: ItemStatus,  newStatus: ItemStatus,  reason?: string): Promise<void> => {  try {    const historyRef = doc(collection(db, 'status_changes'));    await updateDoc(historyRef, {      itemId,      userId,      oldStatus,      newStatus,      reason,      createdAt: new Date()    });  } catch (error) {    console.error('?íƒœ ë³€ê²??´ë ¥ ?€???¤íŒ¨:', error);    // ?´ë ¥ ?€???¤íŒ¨???í’ˆ ?íƒœ ?…ë°?´íŠ¸ë¥?ë§‰ì? ?ŠìŒ  }};// ?¬ìš©?ì˜ ?í’ˆ ?íƒœë³?ì¡°íšŒexport const getUserItemsByStatus = async (  userId: string,  status?: ItemStatus): Promise<MarketItem[]> => {  try {    let q = query(      collection(db, 'market_items'),      where('ownerId', '==', userId),      orderBy('createdAt', 'desc')    );    if (status) {      q = query(q, where('status', '==', status));    }    const querySnapshot = await getDocs(q);    const items: MarketItem[] = [];        querySnapshot.forEach((doc) => {      items.push({        id: doc.id,        ...doc.data()      } as MarketItem);    });        return items;  } catch (error) {    console.error('?¬ìš©???í’ˆ ?íƒœë³?ì¡°íšŒ ?¤íŒ¨:', error);    return [];  }};// ?í’ˆ ?íƒœë³??µê³„ ì¡°íšŒexport const getStatusStatistics = async (userId: string): Promise<{  active: number;  reserved: number;  sold: number;  total: number;}> => {  try {    const allItems = await getUserItemsByStatus(userId);        const stats = {      active: allItems.filter(item => item.status === 'active').length,      reserved: allItems.filter(item => item.status === 'reserved').length,      sold: allItems.filter(item => item.status === 'sold').length,      total: allItems.length    };        return stats;  } catch (error) {    console.error('?íƒœ ?µê³„ ì¡°íšŒ ?¤íŒ¨:', error);    return { active: 0, reserved: 0, sold: 0, total: 0 };  }};// ?¤ì‹œê°??í’ˆ ?íƒœ ëª¨ë‹ˆ?°ë§export const subscribeToUserItemsStatus = (  userId: string,  callback: (items: MarketItem[]) => void) => {  try {    const q = query(      collection(db, 'market_items'),      where('ownerId', '==', userId),      orderBy('createdAt', 'desc')    );        return onSnapshot(q, (snapshot) => {      const items: MarketItem[] = [];      snapshot.forEach((doc) => {        items.push({          id: doc.id,          ...doc.data()        } as MarketItem);      });            callback(items);    });  } catch (error) {    console.error('?í’ˆ ?íƒœ ?¤ì‹œê°?êµ¬ë… ?¤íŒ¨:', error);    return () => {};  }};// ?íƒœ ë³€ê²??´ë ¥ ì¡°íšŒexport const getStatusChangeHistory = async (  itemId: string,  limit: number = 10): Promise<StatusChangeHistory[]> => {  try {    const q = query(      collection(db, 'status_changes'),      where('itemId', '==', itemId),      orderBy('createdAt', 'desc'),      limit    );        const querySnapshot = await getDocs(q);    const history: StatusChangeHistory[] = [];        querySnapshot.forEach((doc) => {      history.push({        id: doc.id,        ...doc.data()      } as StatusChangeHistory);    });        return history;  } catch (error) {    console.error('?íƒœ ë³€ê²??´ë ¥ ì¡°íšŒ ?¤íŒ¨:', error);    return [];  }};// ?¼ê´„ ?íƒœ ?…ë°?´íŠ¸ (?¬ëŸ¬ ?í’ˆ)export const batchUpdateItemStatus = async (  operations: {    itemId: string;    userId: string;    newStatus: ItemStatus;    reason?: string;  }[]): Promise<void> => {  try {    const batch = writeBatch(db);        for (const operation of operations) {      // ê¶Œí•œ ?•ì¸      const hasPermission = await canUpdateStatus(operation.itemId, operation.userId);      if (!hasPermission) {        throw new Error(`?í’ˆ ${operation.itemId}???íƒœë¥?ë³€ê²½í•  ê¶Œí•œ???†ìŠµ?ˆë‹¤.`);      }            const itemRef = doc(db, 'market_items', operation.itemId);      batch.update(itemRef, {        status: operation.newStatus,        updatedAt: new Date()      });    }        await batch.commit();    console.log('?¼ê´„ ?íƒœ ?…ë°?´íŠ¸ ?„ë£Œ:', operations.length, 'ê°?);      } catch (error) {    console.error('?¼ê´„ ?íƒœ ?…ë°?´íŠ¸ ?¤íŒ¨:', error);    throw error;  }};// ?íƒœë³??í’ˆ ?„í„°ë§?export const filterItemsByStatus = (  items: MarketItem[],  status?: ItemStatus): MarketItem[] => {  if (!status) return items;  return items.filter(item => item.status === status);};// ?íƒœ ë³€ê²?ê°€???¬ë? ?•ì¸export const canChangeToStatus = (  currentStatus: ItemStatus,  targetStatus: ItemStatus): boolean => {  // ?íƒœ ë³€ê²?ê·œì¹™ ?•ì˜  const allowedTransitions: Record<ItemStatus, ItemStatus[]> = {    active: ['reserved', 'sold'],      // ?ë§¤ì¤????ˆì•½ì¤? ?ë§¤?„ë£Œ    reserved: ['active', 'sold'],     // ?ˆì•½ì¤????ë§¤ì¤? ?ë§¤?„ë£Œ    sold: []                          // ?ë§¤?„ë£Œ ??ë³€ê²?ë¶ˆê?  };    return allowedTransitions[currentStatus].includes(targetStatus);};// ?íƒœë³??‰ìƒ ë°??ìŠ¤??export const getStatusDisplayInfo = (status: ItemStatus): {  color: string;  backgroundColor: string;  text: string;  description: string;} => {  switch (status) {    case 'active':      return {        color: '#059669',        backgroundColor: '#d1fae5',        text: '?ë§¤ì¤?,        description: '?„ì¬ ?ë§¤ ì¤‘ì¸ ?í’ˆ?…ë‹ˆ??      };    case 'reserved':      return {        color: '#d97706',        backgroundColor: '#fed7aa',        text: '?ˆì•½ì¤?,        description: 'êµ¬ë§¤?ê? ?ˆì•½???í’ˆ?…ë‹ˆ??      };    case 'sold':      return {        color: '#dc2626',        backgroundColor: '#fecaca',        text: '?ë§¤?„ë£Œ',        description: '?ë§¤ê°€ ?„ë£Œ???í’ˆ?…ë‹ˆ??      };    default:      return {        color: '#6b7280',        backgroundColor: '#f3f4f6',        text: '?????†ìŒ',        description: '?íƒœ ?•ë³´ê°€ ?†ìŠµ?ˆë‹¤'      };  }}; 