"use strict";
// 기존 ?�품?�의 ?�정???�보�??�괄 보정?�는 백필 ?�틸리티import { collection, doc, getDocs, serverTimestamp, updateDoc } from 'firebase/firestore';import { db } from '@/lib/firebase';import { reverseGeocodeDong } from '@/lib/geo';export async function backfillProductDong() {  const snap = await getDocs(collection(db, 'products'));  for (const d of snap.docs) {    const p = d.data() as any;    if (p.address?.dong || !p.geo?.lat) continue;    try {      const a = await reverseGeocodeDong(p.geo.lat, p.geo.lng);      await updateDoc(doc(db, 'products', d.id), {        address: a,        updatedAt: serverTimestamp()      });      await new Promise(r => setTimeout(r, 120)); // ?�도 ?�한 ?�피    } catch {}  }}/** * 기존 ?�품?�의 ?�정???�보�??�괄 보정 * - products 컬렉?�의 기존 ?�품?�을 ?�?�으�??? * - ?��? address가 ?�거??geo 좌표가 ?�는 ?�품?� 건너?� * - 카카??API ?�도 ?�한??고려?�여 120ms ?�레???�용 */export async function backfillDong() {  console.log('?�� [BACKFILL] ?�정???�보 ?�괄 보정 ?�작');    try {    const snap = await getDocs(collection(db, 'products'));    console.log(`?�� [BACKFILL] �?${snap.docs.length}�??�품 발견`);        let processed = 0;    let updated = 0;    let skipped = 0;    let errors = 0;        for (const d of snap.docs) {      processed++;      const p = d.data() as any;            // ?��? address가 ?�거??geo 좌표가 ?�는 ?�품?� 건너?�기      if (p.address?.dong || !p.geo?.lat) {        skipped++;        continue;      }            try {        console.log(`?�� [BACKFILL] ${processed}/${snap.docs.length} 처리 �? ${p.title || d.id}`);                const addr = await reverseGeocodeDong(p.geo.lat, p.geo.lng);        await updateDoc(doc(db, 'products', d.id), {           address: addr,           updatedAt: serverTimestamp()         });                updated++;        console.log(`??[BACKFILL] ${d.id} ?�데?�트 ?�료: ${addr.full}`);                // 카카??API ?�도 ?�한 ?�피 (120ms ?�레??        await new Promise(r => setTimeout(r, 120));              } catch (error) {        errors++;        console.error(`??[BACKFILL] ${d.id} ?�데?�트 ?�패:`, error);      }    }        console.log(`?�� [BACKFILL] ?�료! 처리: ${processed}, ?�데?�트: ${updated}, 건너?�: ${skipped}, ?�류: ${errors}`);    return { processed, updated, skipped, errors };      } catch (error) {    console.error('?�� [BACKFILL] ?�체 ?�로?�스 ?�패:', error);    throw error;  }}/** * market 컬렉?�의 기존 ?�품?�을 products 컬렉?�으�?마이그레?�션 * - 기존 market 컬렉?�의 ?�품?�을 ?�로??구조�?변?? * - ?�정???�보???�께 ?�성 */export async function migrateMarketToProducts() {  console.log('?�� [MIGRATE] market ??products 마이그레?�션 ?�작');    try {    const { collection: firestoreCollection, addDoc, serverTimestamp } = await import('firebase/firestore');        const marketSnap = await getDocs(firestoreCollection(db, 'market'));    console.log(`?�� [MIGRATE] �?${marketSnap.docs.length}�?market ?�품 발견`);        let processed = 0;    let migrated = 0;    let errors = 0;        for (const d of marketSnap.docs) {      processed++;      const p = d.data() as any;            try {        console.log(`?�� [MIGRATE] ${processed}/${marketSnap.docs.length} 처리 �? ${p.title || d.id}`);                // ?�로???�품 구조�?변??        const newProduct = {          title: p.title || '?�목 ?�음',          description: p.desc || p.description || '',          price: p.price || 0,          category: p.category || '기�?',          images: Array.isArray(p.images) ? p.images : [],          status: p.status || '?�매�?,          sellerId: p.sellerId || p.sellerUid || 'unknown',          createdAt: p.createdAt || serverTimestamp(),          updatedAt: serverTimestamp(),          // ?�치 ?�보 변??          geo: p.location ? {            lat: p.location.lat || p.location.latitude || 0,            lng: p.location.lng || p.location.longitude || 0          } : p.lat && p.lng ? {            lat: Number(p.lat),            lng: Number(p.lng)          } : null,          // 기존 location ?�보 ?��? (?�위 ?�환??          location: p.location ? {            lat: p.location.lat || p.location.latitude || 0,            lng: p.location.lng || p.location.longitude || 0,            placeName: p.location.placeName || p.location.name || ''          } : p.lat && p.lng ? {            lat: Number(p.lat),            lng: Number(p.lng),            placeName: ''          } : undefined,          // 기�? ?�드          chatCount: p.chatCount || 0,          likeCount: p.likeCount || 0,          viewCount: p.viewCount || 0,          analysis: p.analysis || null        };                // ?�정???�보 ?�성 (geo 좌표가 ?�는 경우)        if (newProduct.geo?.lat && newProduct.geo?.lng) {          try {            const addr = await reverseGeocodeDong(newProduct.geo.lat, newProduct.geo.lng);            newProduct.address = addr;            console.log(`?�� [MIGRATE] ?�정???�보 ?�성: ${addr.full}`);          } catch (geoError) {            console.warn(`?�️ [MIGRATE] ?�정???�보 ?�성 ?�패:`, geoError);          }        }                // products 컬렉?�에 추�?        await addDoc(firestoreCollection(db, 'products'), newProduct);        migrated++;        console.log(`??[MIGRATE] ${d.id} 마이그레?�션 ?�료`);                // 카카??API ?�도 ?�한 ?�피        if (newProduct.address) {          await new Promise(r => setTimeout(r, 120));        }              } catch (error) {        errors++;        console.error(`??[MIGRATE] ${d.id} 마이그레?�션 ?�패:`, error);      }    }        console.log(`?�� [MIGRATE] ?�료! 처리: ${processed}, 마이그레?�션: ${migrated}, ?�류: ${errors}`);    return { processed, migrated, errors };      } catch (error) {    console.error('?�� [MIGRATE] ?�체 ?�로?�스 ?�패:', error);    throw error;  }}/** * 개발??콘솔?�서 ?�행?????�는 ?�역 ?�수?? */if (typeof window !== 'undefined') {  (window as any).backfillDong = backfillDong;  (window as any).migrateMarketToProducts = migrateMarketToProducts;    console.log('?�� [BACKFILL] ?�역 ?�수 ?�록 ?�료:');  console.log('  - backfillDong() : 기존 ?�품 ?�정???�보 보정');  console.log('  - migrateMarketToProducts() : market ??products 마이그레?�션');}// ?��?지 URL 백필 ?�틸리티export async function backfillImageUrls() {  console.log('[백필] ?��?지 URL 백필 ?�작...');    try {    const { db } = await import('@/lib/firebase');    const { collection, getDocs, updateDoc, doc } = await import('firebase/firestore');        // products 컬렉?�의 모든 문서 조회    const snapshot = await getDocs(collection(db, 'products'));    let updatedCount = 0;    let errorCount = 0;        for (const docSnapshot of snapshot.docs) {      const data = docSnapshot.data();            try {        // ?��?지가 ?�거??�?배열??경우 건너?�기        if (!data.images || data.images.length === 0) {          console.log(`[백필] ${docSnapshot.id}: ?��?지 ?�음, 건너?�기`);          continue;        }                // ?��? ?�바�?구조�??�어 ?�는지 ?�인        if (Array.isArray(data.images) && data.images.length > 0) {          const firstImage = data.images[0];                    // ?��? 구조?�된 ?�이?�인 경우          if (typeof firstImage === 'object' && firstImage.url) {            console.log(`[백필] ${docSnapshot.id}: ?��? ?�바�?구조`);            continue;          }                    // ?�순 URL 배열??경우 구조??          if (typeof firstImage === 'string') {            const imageData = data.images.map((url: string, index: number) => ({              url,              path: `products/${data.sellerId || 'unknown'}/${docSnapshot.id}_${index}.jpg`,              filename: `image_${index}.jpg`,              size: 0,              type: 'image/jpeg',              uploadedAt: new Date()            }));                        await updateDoc(doc(db, 'products', docSnapshot.id), {              images: imageData,              imageUrls: data.images,              thumbnail: data.images[0],              updatedAt: new Date()            });                        console.log(`[백필] ${docSnapshot.id}: 구조???�료 (${data.images.length}�??��?지)`);            updatedCount++;          }        }      } catch (error) {        console.error(`[백필] ${docSnapshot.id} 처리 ?�패:`, error);        errorCount++;      }    }        console.log(`[백필] ?�료: ${updatedCount}�??�데?�트, ${errorCount}�??�패`);    return { updatedCount, errorCount };      } catch (error) {    console.error('[백필] ?�체 ?�패:', error);    throw error;  }}// ?�역 ?�수�??�록 (개발 모드?�서�?if (import.meta.env.DEV) {  (window as any).backfillImageUrls = backfillImageUrls;  console.log('[백필] ?�역 ?�수 ?�록?? window.backfillImageUrls()');}
