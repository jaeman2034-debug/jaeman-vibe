"use strict";
// ????�코???�틸리티 (카카??구�? API)export interface GeocodingResult {  address: string;  placeName: string;  lat: number;  lng: number;  region1Depth?: string; // ????  region2Depth?: string; // �?�?  region3Depth?: string; // ????�?}// 카카??????�코??APIexport async function kakaoReverseGeocoding(  lat: number,   lng: number,   apiKey: string): Promise<GeocodingResult | null> {  try {    const response = await fetch(      `https://dapi.kakao.com/v2/local/geo/coord2address.json?x=${lng}&y=${lat}`,      {        headers: {          'Authorization': `KakaoAK ${apiKey}`,          'Content-Type': 'application/json'        }      }    );    if (!response.ok) {      throw new Error(`Kakao API ?�류: ${response.status}`);    }    const data = await response.json();    const address = data.documents[0];        if (!address) {      return null;    }    return {      address: address.address.address_name,      placeName: address.address.region_3depth_name || address.address.region_2depth_name,      lat,      lng,      region1Depth: address.address.region_1depth_name,      region2Depth: address.address.region_2depth_name,      region3Depth: address.address.region_3depth_name    };  } catch (error) {    console.error('[GEOCODING] Kakao API ?�류:', error);    return null;  }}// 구�? ????�코??APIexport async function googleReverseGeocoding(  lat: number,   lng: number,   apiKey: string): Promise<GeocodingResult | null> {  try {    const response = await fetch(      `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=${apiKey}&language=ko`    );    if (!response.ok) {      throw new Error(`Google API ?�류: ${response.status}`);    }    const data = await response.json();        if (data.status !== 'OK' || !data.results[0]) {      return null;    }    const result = data.results[0];    const addressComponents = result.address_components;        // 주소 구성 ?�소 ?�싱    const region1Depth = addressComponents.find(c => c.types.includes('administrative_area_level_1'))?.long_name;    const region2Depth = addressComponents.find(c => c.types.includes('administrative_area_level_2'))?.long_name;    const region3Depth = addressComponents.find(c => c.types.includes('sublocality_level_1'))?.long_name;    return {      address: result.formatted_address,      placeName: region3Depth || region2Depth || region1Depth || '?�치',      lat,      lng,      region1Depth,      region2Depth,      region3Depth    };  } catch (error) {    console.error('[GEOCODING] Google API ?�류:', error);    return null;  }}// ?�동 ????�코??(카카???�선, ?�패 ??구�?)export async function autoReverseGeocoding(  lat: number,   lng: number,  kakaoKey?: string,  googleKey?: string): Promise<GeocodingResult | null> {  // 카카??API ?�선 ?�도  if (kakaoKey) {    const kakaoResult = await kakaoReverseGeocoding(lat, lng, kakaoKey);    if (kakaoResult) {      console.log('[GEOCODING] Kakao API ?�공:', kakaoResult);      return kakaoResult;    }  }  // 구�? API ?�도  if (googleKey) {    const googleResult = await googleReverseGeocoding(lat, lng, googleKey);    if (googleResult) {      console.log('[GEOCODING] Google API ?�공:', googleResult);      return googleResult;    }  }  // 기본 ?�치 ?�보 반환  return {    address: `${lat.toFixed(6)}, ${lng.toFixed(6)}`,    placeName: '?�재 ?�치',    lat,    lng  };}// 주소 ?�식??export function formatAddress(result: GeocodingResult): string {  const parts = [    result.region1Depth,    result.region2Depth,    result.region3Depth  ].filter(Boolean);    return parts.length > 0 ? parts.join(' ') : result.placeName;}
