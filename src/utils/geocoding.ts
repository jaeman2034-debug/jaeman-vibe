// ????§ÏΩî???†Ìã∏Î¶¨Ìã∞ (Ïπ¥Ïπ¥??Íµ¨Í? API)export interface GeocodingResult {  address: string;  placeName: string;  lat: number;  lng: number;  region1Depth?: string; // ????  region2Depth?: string; // Íµ?Íµ?  region3Depth?: string; // ????Î©?}// Ïπ¥Ïπ¥??????§ÏΩî??APIexport async function kakaoReverseGeocoding(  lat: number,   lng: number,   apiKey: string): Promise<GeocodingResult | null> {  try {    const response = await fetch(      `https://dapi.kakao.com/v2/local/geo/coord2address.json?x=${lng}&y=${lat}`,      {        headers: {          'Authorization': `KakaoAK ${apiKey}`,          'Content-Type': 'application/json'        }      }    );    if (!response.ok) {      throw new Error(`Kakao API ?§Î•ò: ${response.status}`);    }    const data = await response.json();    const address = data.documents[0];        if (!address) {      return null;    }    return {      address: address.address.address_name,      placeName: address.address.region_3depth_name || address.address.region_2depth_name,      lat,      lng,      region1Depth: address.address.region_1depth_name,      region2Depth: address.address.region_2depth_name,      region3Depth: address.address.region_3depth_name    };  } catch (error) {    console.error('[GEOCODING] Kakao API ?§Î•ò:', error);    return null;  }}// Íµ¨Í? ????§ÏΩî??APIexport async function googleReverseGeocoding(  lat: number,   lng: number,   apiKey: string): Promise<GeocodingResult | null> {  try {    const response = await fetch(      `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=${apiKey}&language=ko`    );    if (!response.ok) {      throw new Error(`Google API ?§Î•ò: ${response.status}`);    }    const data = await response.json();        if (data.status !== 'OK' || !data.results[0]) {      return null;    }    const result = data.results[0];    const addressComponents = result.address_components;        // Ï£ºÏÜå Íµ¨ÏÑ± ?îÏÜå ?åÏã±    const region1Depth = addressComponents.find(c => c.types.includes('administrative_area_level_1'))?.long_name;    const region2Depth = addressComponents.find(c => c.types.includes('administrative_area_level_2'))?.long_name;    const region3Depth = addressComponents.find(c => c.types.includes('sublocality_level_1'))?.long_name;    return {      address: result.formatted_address,      placeName: region3Depth || region2Depth || region1Depth || '?ÑÏπò',      lat,      lng,      region1Depth,      region2Depth,      region3Depth    };  } catch (error) {    console.error('[GEOCODING] Google API ?§Î•ò:', error);    return null;  }}// ?êÎèô ????§ÏΩî??(Ïπ¥Ïπ¥???∞ÏÑ†, ?§Ìå® ??Íµ¨Í?)export async function autoReverseGeocoding(  lat: number,   lng: number,  kakaoKey?: string,  googleKey?: string): Promise<GeocodingResult | null> {  // Ïπ¥Ïπ¥??API ?∞ÏÑ† ?úÎèÑ  if (kakaoKey) {    const kakaoResult = await kakaoReverseGeocoding(lat, lng, kakaoKey);    if (kakaoResult) {      console.log('[GEOCODING] Kakao API ?±Í≥µ:', kakaoResult);      return kakaoResult;    }  }  // Íµ¨Í? API ?úÎèÑ  if (googleKey) {    const googleResult = await googleReverseGeocoding(lat, lng, googleKey);    if (googleResult) {      console.log('[GEOCODING] Google API ?±Í≥µ:', googleResult);      return googleResult;    }  }  // Í∏∞Î≥∏ ?ÑÏπò ?ïÎ≥¥ Î∞òÌôò  return {    address: `${lat.toFixed(6)}, ${lng.toFixed(6)}`,    placeName: '?ÑÏû¨ ?ÑÏπò',    lat,    lng  };}// Ï£ºÏÜå ?ïÏãù??export function formatAddress(result: GeocodingResult): string {  const parts = [    result.region1Depth,    result.region2Depth,    result.region3Depth  ].filter(Boolean);    return parts.length > 0 ? parts.join(' ') : result.placeName;}
