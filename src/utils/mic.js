"use strict";
// src/utils/mic.ts/** 마이??권한: ?�공 true / ?�패 false */export async function ensureMicPermission(): Promise<boolean> {    try {      const stream = await navigator.mediaDevices.getUserMedia({        audio: {          noiseSuppression: true,          echoCancellation: true,          autoGainControl: true,          channelCount: 1,          sampleRate: 16000        }      });      stream.getTracks().forEach(t => t.stop());      return true;    } catch (err) {      console.error("마이??권한 ?�청 ?�패:", err);      return false;    }  }    /** ?�전 ?�러 ?�출(콜백 ?�으�?콘솔�? */  function safeError(onError: ((m: string) => void) | undefined, msg: string) {    console.error(msg);    if (typeof onError === "function") { try { onError(msg); } catch (e) { console.error(e); } }  }    // >>> @MIC_LISTEN_ONCE_P_SIMPLE// === 겹점??차단???�역 ===let __activeStream: MediaStream | null = null;let __activeAudioCtx: AudioContext | null = null;let __activeRecognition: any | null = null;export function forceKillMic() {  try { __activeRecognition?.stop?.(); } catch {}  __activeRecognition = null;  try { __activeStream?.getTracks?.().forEach(t => t.stop()); } catch {}  __activeStream = null;  try {     if (__activeAudioCtx && __activeAudioCtx.state !== 'closed') {      __activeAudioCtx.close();     }  } catch {}  __activeAudioCtx = null;}/** * ?�성????번만 ?�고 ?�스??반환 (간결?? * - 간단?�고 ?�정?�인 구조 * - 최종 결과 ?�선, interim 백업 * - 겹점??방�? ?�이 ?�수 STT�? */export function listenOnceP(locale="ko-KR", totalTimeout=20000, preSpeechTimeout=8000, resultTimeout=10000){  return new Promise<string>((resolve, reject) => {    const SR:any = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;    if (!SR) return reject(new Error("??브라?��????�성 ?�식??지?�하지 ?�습?�다."));    const rec:any = new SR();    rec.lang = locale;    rec.interimResults = true;         // ?�� 중간 결과??받기    rec.maxAlternatives = 3;    rec.continuous = false;    let finished = false, gotSpeech = false;    let bestFinal = "", bestInterim = "";    const finish = (fn:()=>void) => { if (finished) return; finished = true;      try { rec.onresult = rec.onerror = rec.onend = rec.onaudiostart = rec.onsoundstart = rec.onspeechstart = null; } catch {}      try { rec.stop(); } catch {}      fn();    };    const tTotal = setTimeout(() => finish(() => reject(new Error("?�간 초과: ?�식???�료?��? ?�았?�니??"))), totalTimeout);    let tPre:any, tRes:any;    const clearTimers = ()=>{ clearTimeout(tTotal); clearTimeout(tPre); clearTimeout(tRes); };    const armRes = ()=>{ clearTimeout(tRes); tRes=setTimeout(()=>{      if (!finished) {        const text = bestFinal || bestInterim || "";        if (text) finish(()=>{ clearTimers(); resolve(text); });        else finish(()=>{ clearTimers(); reject(new Error("?�식??조기??종료?�었?�니??")); });      }    }, resultTimeout); };    const mark = ()=>{ if (!gotSpeech){ gotSpeech = true; armRes(); } };    rec.onaudiostart = mark; rec.onsoundstart = mark; rec.onspeechstart = mark;    tPre = setTimeout(()=>{ if (!gotSpeech) finish(()=>{ clearTimers(); reject(new Error("말소리�? 감�??��? ?�았?�니??")); }); }, preSpeechTimeout);    rec.onresult = (e:any) => {      try {        console.log("?�� onresult ?�벤??발생!");        console.log("?�� results:", e.results);                for (let i=e.resultIndex; i<e.results.length; i++){          const r=e.results[i], a=r?.[0];          const t=(a?.transcript||"").trim();          if (!t) continue;          if (r.isFinal) bestFinal = t; else bestInterim = t;        }        if (gotSpeech) armRes();        if (bestFinal) finish(()=>{ clearTimers(); resolve(bestFinal); }); // 최종 ?�면 즉시 반환      } catch {}    };    rec.onerror = (e:any) => { finish(()=>{ clearTimers(); reject(new Error(e?.error || "?�성 ?�식 ?�류")); }); };    rec.onend = () => {      console.log("?�� onend ?�벤??발생");      if (!finished) {        const text = bestFinal || bestInterim || "";        if (text) {          console.log("??onend?�서 ?�스???�인:", text);          finish(()=>{ clearTimers(); resolve(text); });        } else {          console.log("?�️ onend?�서 ?�스???�음");          finish(()=>{ clearTimers(); reject(new Error("?�식??조기??종료?�었?�니??")); });        }      }    };    try {       rec.start();       console.log("?�� SpeechRecognition ?�작??);    } catch {       finish(()=> reject(new Error("SpeechRecognition ?�작 ?�패")));     }  });}// <<< @MIC_LISTEN_ONCE_P_SIMPLE    /** (?�션) ?�속 ?�식???�요?????�용?????�는 ?�퍼 */  export function startListening(    locale: string,    onResult: (text: string) => void,    onError?: (message: string) => void  ) {    try {      const SR: any = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;      if (!SR) { safeError(onError, "??브라?��????�성 ?�식??지?�하지 ?�습?�다. Chrome???�용??주세??"); return () => {}; }        const rec: any = new SR();      rec.lang = locale || "ko-KR";      rec.interimResults = true;      rec.continuous = true;        rec.onresult = (e: any) => {        let acc = "";        for (let i = e.resultIndex; i < e.results.length; i++) {          acc += e.results[i][0].transcript;        }        onResult(acc.trim());      };        rec.onerror = (e: any) => {        const code = e?.error;        let msg = "?�성 ?�식 ?�류가 발생?�습?�다. ?�시 ?�도??주세??";        if (code === "not-allowed") msg = "마이??권한??거�??�었?�니?? 주소�??�쪽 ?��?�서 '?�용'?�로 변경하?�요.";        if (code === "audio-capture") msg = "마이???�치�?찾을 ???�습?�다. OS???�력 ?�치�??�인?�세??";        if (code === "no-speech") msg = "말소리�? 감�??��? ?�았?�니?? 조금 ???�게 ?�렷?�게 말�???주세??";        safeError(onError, msg);      };        rec.start();      return () => { try { rec.stop(); } catch {} };    } catch {      safeError(onError, "startListening 초기???�패");      return () => {};    }  }  // >>> @MIC_VU_METER/** * ?�시�?마이???�벨 미터 * - onLevel: 0~1 ?�이 ?�력 강도 콜백(초당 30~60?? * - 반환: stop() ?�수 (?�트�??�디?�컨?�스???�리) */export async function startMicLevelMeter(onLevel: (v: number) => void) {  // ?�� ?�른 ?�유 모두 종료  forceKillMic();  const stream = await navigator.mediaDevices.getUserMedia({    audio: {      noiseSuppression: true,      echoCancellation: true,      autoGainControl: true,      channelCount: 1,      sampleRate: 16000    }  });  __activeStream = stream;  const Ctx: any = (window as any).AudioContext || (window as any).webkitAudioContext;  const ctx = new Ctx();  __activeAudioCtx = ctx;  const src = ctx.createMediaStreamSource(stream);  const analyser = ctx.createAnalyser();  analyser.fftSize = 1024;  const data = new Uint8Array(analyser.frequencyBinCount);  src.connect(analyser);  let raf = 0;  const loop = () => {    analyser.getByteTimeDomainData(data);    // ?�형??중앙(128)?�서 ?�마??벗어?�는지�??�벨 계산    let peak = 0;    for (let i = 0; i < data.length; i++) {      const dev = Math.abs(data[i] - 128) / 128; // 0~1      if (dev > peak) peak = dev;    }    onLevel(Math.min(1, peak * 2)); // 민감???�짝 ?�림    raf = requestAnimationFrame(loop);  };  loop();  const stop = () => {    cancelAnimationFrame(raf);    try { src.disconnect(); } catch {}    try { analyser.disconnect(); } catch {}    try { stream.getTracks().forEach(t => t.stop()); } catch {}    try { ctx.close(); } catch {}  };  return stop;}// <<< @MIC_VU_METER// === ?�버깅용 ?�역 ?�출 ===(window as any).debugListenOnceP = listenOnceP;(window as any).debugForceKillMic = forceKillMic;  
