/* ------------------------------------------------------- * VIBE NLU (ko-KR) ??voice signup ìµœì¢…ë³? * - ?•ì • ?¨í„´(?„ë‹ˆê³??„ë‹ˆ??ë§ê³ ?? * - ?¸ì´ì¦?ì»??¡ë‹´/?˜ë¬¸??ì§§ì? ë°œí™”) * - ?œê? ?´ë¦„ ì¶”ì¶œ(2~6?? * - ì² ì ëª¨ë“œ(????ë§?/ ????ë§? * - ?¬ë­??ë§ˆì?ë§??Œì ˆ ?ŒíŠ¸: êµ??????? * - ?¸ì§‘ê±°ë¦¬/?ëª¨ê±°ë¦¬ ë³´ì •(?°â†”êµ???1ê¸€??ì°¨ì´) * - ?”ì ? ì? ê·œì¹™(ê°™ì? ?”ì + ?•ì •???Œë§Œ êµì²´) * ----------------------------------------------------- */export type Intent =  | "START" | "STOP" | "NEXT" | "BACK" | "REPEAT" | "CANCEL"  | "SET_NAME" | "SET_EMAIL" | "SET_PASSWORD"  | "NOISE" | "UNKNOWN";export type Slots = { name?: string; email?: string; password?: string };export type ParseResult = {  intent: Intent;  slot?: Slots;  _debug?: { normalized?: string; picked?: string; candidates?: string[] };};/* =============== ê³µí†µ ?¬í¼ =============== */const toLowerTrim = (s: string) => (s ?? "").toLowerCase().trim();const onlyKr = (s: string) => s.replace(/[^\uAC00-\uD7A3\s]/g, " ");const squeeze = (s: string) => s.replace(/\s+/g, " ").trim();/** ?´ë¦„ ?„ì²˜ë¦? ?œê?ë§? ì¤‘ë³µ?Œì ˆ ì¶•ì•½, ê³µë°± ?œê±°, ê¸¸ì´ 2~6 */export const normalizeName = (s: string) => {  let t = squeeze(onlyKr(s));  t = t.replace(/([ê°€-??)\s*\1{1,}/g, "$1");  t = t.replace(/\s/g, "");  if (t.length < 2 || t.length > 6) return "";  return t;};/* =============== ?¸ì´ì¦?ë¸”ë™ë¦¬ìŠ¤??=============== */const NAME_BLACKLIST = [  "?¤ìŒ","?¤ë¡œ","ë°˜ë³µ","?œì‘","ì¤‘ì?","?•ì?","ì·¨ì†Œ","ë¡œê·¸","?¸ì‹","ì´ˆê¸°??,  "?±í•¨??,"?„ì?°í¸","ë¹„ë?ë²ˆí˜¸","?•ì •","?„í˜•","?œë§Œ","ì§„í–‰","?•ì¸","?ˆë‚´","ì§ˆë¬¸"];const noisePatterns: RegExp[] = [  /?ˆë…•?˜ì„¸??, /?´ëŸ¬??, /?´ë–»ê²?, /?¡ì•„/, /?œì‘?©ë‹ˆ??, /ì§„í–‰/,  /^?¤ìŒ$/, /^?¤ë¡œ$/, /ë§ê³ \?/, /\?$/, /?…ë‹ˆ???$/];/* =============== ?´ë©”??ë¹„ë?ë²ˆí˜¸ =============== */const normalizeEmailSpeech = (u: string) => {  let s = (u || "").toLowerCase();  // 0) ?œê? ë¶ˆìš©???œê±°  s = s.replace(/(?´ë©”???„ì?°í¸|ì£¼ì†Œ??ì£¼ì†Œê°€|ì£¼ì†Œ|?…ë‹ˆ???´ì—???ˆìš”|?œê²ƒ|?´ê²ƒ|?´êº¼|?œêº¼|?€|????ê°€)/g, "");  // 1) ê³µë°± ?œê±°  s = s.replace(/\s+/g, "");  // 2) amp/?°í”„ ê³„ì—´ ?¸ì´ì¦??œê±°  s = s.replace(/amp|&amp;|?°í”„|?ì´? í”¼/gi, "");  // 3) 'ê³¨ë±…?????ì´?????? -> '@'  s = s.replace(/ê³¨ë±…?????ì´??\bat\b|????gi, "@");  // 4) '???? -> '.', 'ì½? -> 'com'  s = s.replace(/????gi, ".");  s = s.replace(/ì½?gi, "com");  // 5) ì¤‘ë³µ @ ?•ë¦¬ + ?œê? ?¼í‘œ ?œê±°  s = s.replace(/@{2,}/g, "@").replace(/[ï¼Œã€?/g, "");  return s;};// ?´ë©”??ì² ì ëª¨ë“œ (?œì´-?€??/ ?œì´ ?€??const parseEmailSpell = (s: string) => {  if (!/(ì² ì|?¤í |?˜ì´??-)/i.test(s)) return "";  const parts = s.split(/[\s,-]+/).map(w => w.trim()).filter(Boolean);  if (parts.length < 2) return "";    // ì²?ë²ˆì§¸ ë¶€ë¶„ì„ IDë¡? ?˜ë¨¸ì§€ë¥??„ë©”?¸ìœ¼ë¡?ì²˜ë¦¬  const id = parts[0];  const domain = parts.slice(1).join(".");    // ?„ë©”?¸ì— .com ?±ì´ ?†ìœ¼ë©?ì¶”ê?  const finalDomain = domain.includes(".") ? domain : domain + ".com";  return `${id}@${finalDomain}`;};const EMAIL_RE = /\b[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}\b/i;const tryEmail = (u: string) => {  // 1) ì² ì ëª¨ë“œ ?°ì„  ?œë„  const spelled = parseEmailSpell(u);  if (spelled && EMAIL_RE.test(spelled)) return spelled;    // 2) ?¼ë°˜ ?´ë©”???¨í„´ ?œë„  return EMAIL_RE.exec(normalizeEmailSpeech(u))?.[0] || "";};const tryPassword = (u: string) => {  if (!/(ë¹„ë?ë²ˆí˜¸|?¨ìŠ¤?Œë“œ|password)/i.test(u)) return "";  const pw = u.replace(/(ë¹„ë?ë²ˆí˜¸|?¨ìŠ¤?Œë“œ|password|?€|??:)/gi, " ").trim().replace(/\s/g, "");  return pw.length >= 8 ? pw : "";};/* =============== ì² ì ëª¨ë“œ =============== */export const parseSpell = (s: string) => {  if (!/(ì² ì|?¤í |?˜ì´??-)/i.test(s)) return "";  const joined = s.split(/[\s,-]+/).map(w => w.replace(/[^\uAC00-\uD7A3]/g, "")).join("");  return normalizeName(joined);};/* =============== ?´ë¦„ ?„ë³´ ì¶”ì¶œ/?•ì • =============== */const KNAME = /[ê°€-??{2,6}(?:\s*[ê°€-??{0,4})?/g;export const extractNames = (u: string): string[] =>  (u.match(KNAME) || [])    .map(x => normalizeName(x))    .filter(n => n && n.length >= 2 && n.length <= 6);// ?•ì • ? í°(?¤ì–‘??ë³€??const CORR_RE = /(?„ë‹ˆê³??„ë‹ˆ???„ë‹ˆë©?ë§ê³ |ë§ì???s*?„ë‹ˆê³??„ë‹Œ|?„ë‹ˆêµ??„ë‹ˆê³ ìš”|ë§ê³ ??/;export const isCorrectionUtter = (u: string) => CORR_RE.test(u);/* =============== ê±°ë¦¬/?¤ì½”??=============== */export const editDistance = (a: string, b: string) => {  const dp = Array(a.length + 1).fill(0).map(() => Array(b.length + 1).fill(0));  for (let i = 0; i <= a.length; i++) dp[i][0] = i;  for (let j = 0; j <= b.length; j++) dp[0][j] = j;  for (let i = 1; i <= a.length; i++)    for (let j = 1; j <= b.length; j++)      dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1] + (a[i-1]===b[i-1]?0:1));  return dp[a.length][b.length];};const UNI_BASE = 0xAC00;const CHO = ["??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??];const JUNG = ["??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??];const JONG = ["","??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"?€","??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??,"??];const decomposeKR = (ch:string) => {  const c = ch.charCodeAt(0);  if (c < 0xAC00 || c > 0xD7A3) return {cho:"", jung:"", jong:""};  const idx = c - UNI_BASE;  return { cho: CHO[Math.floor(idx/588)], jung: JUNG[Math.floor((idx%588)/28)], jong: JONG[idx%28] };};export const jamoDistance = (a:string,b:string) => {  if (!a || !b) return 9;  const A = decomposeKR(a), B = decomposeKR(b);  let d = 0;  if (A.cho !== B.cho) d++;  if (A.jung !== B.jung) d++;  if (A.jong !== B.jong) d++;  return d;};export const scoreName = (raw: string) => {  const n = normalizeName(raw);  if (!n) return { n: "", score: -1, cho: "" };  const len = n.length;  const lenScore = 1 - Math.abs(len - 3) / 3;  const krRatio = n.length / (raw.length || 1);  const cho = (() => {    let r = ""; for (const ch of n) {      const c = ch.charCodeAt(0);      if (c >= 0xAC00 && c <= 0xD7A3) r += CHO[Math.floor((c - 0xAC00)/588)];    } return r;  })();  const choLenScore = Math.min(cho.length / 3, 1);  return { n, cho, score: lenScore * 0.5 + krRatio * 0.3 + choLenScore * 0.2 };};/* =============== ?¬ë­??ë§ˆì?ë§??Œì ˆ ?ŒíŠ¸ ë°˜ì˜) =============== */export function reRankNameCandidates(finals: string[], raw: string): string {  const items = finals    .map(s => s.trim())    .flatMap(s => extractNames(s))    .filter(Boolean);  if (items.length === 0) return finals[0] || "";  const u = (raw || "").toLowerCase();  const wantGu = /(êµ?\s*(?…ë‹ˆ?????ìš”|?????\b/.test(u) || /\bêµ?b/.test(u);  const wantU  = /(??\s*(?…ë‹ˆ?????ìš”|?????\b/.test(u) || /\b??b/.test(u);  const wantHo = /(??\s*(?…ë‹ˆ?????ìš”|?????\b/.test(u) || /\b??b/.test(u);  const wantHee= /(??\s*(?…ë‹ˆ?????ìš”|?????\b/.test(u) || /\b??b/.test(u);  const scored = items.map(n => {    const base = scoreName(n).score;    const last = n.at(-1) || "";    let bonus = 0;    if (wantGu && last === "êµ?) bonus += 0.8;    if (wantU  && last === "??) bonus += 0.8;    if (wantHo && last === "??) bonus += 0.8;    if (wantHee&& last === "??) bonus += 0.8;    // stem ë³´ì •(?? ë°•ë³‘*)    if (/^[ê°€-??{1,2}ë³?.test(n)) bonus += 0.1;    return { n, score: base + bonus };  });  scored.sort((a,b) => b.score - a.score);  return scored[0].n;}/* =============== ë©”ì¸ ?Œì„œ =============== */export function parseUtterance(utter: string): ParseResult {  const raw = utter ?? "";  const u = toLowerTrim(raw);  // control intents  if (/(?œì‘|?¤í???\bstart\b|\bgo\b)/.test(u)) return { intent: "START" };  if (/(?•ì?|?¤íƒ‘|\bstop\b|ê·¸ë§Œ)/.test(u)) return { intent: "STOP" };  if (/(?¤ìŒ|\bnext\b|?˜ê²¨)/.test(u)) return { intent: "NEXT" };  if (/(?¤ë¡œ|?´ì „|\bback\b)/.test(u)) return { intent: "BACK" };  if (/(ì·¨ì†Œ|ìº”ìŠ¬|\bcancel\b)/.test(u)) return { intent: "CANCEL" };  if (/(?¤ì‹œ|\brepeat\b|ë°˜ë³µ)/.test(u)) return { intent: "REPEAT" };  // noise cuts  if (noisePatterns.some(p => p.test(u))) return { intent: "NOISE" };  if (NAME_BLACKLIST.some(w => u.includes(w))) return { intent: "NOISE" };  // email / password  const email = tryEmail(u);  if (email) return { intent: "SET_EMAIL", slot: { email }, _debug: { normalized: email } };  const pw = tryPassword(u);  if (pw) return { intent: "SET_PASSWORD", slot: { password: pw } };  // spelled  const spelled = parseSpell(raw);  if (spelled) return { intent: "SET_NAME", slot: { name: spelled }, _debug: { picked: spelled } };  // correction: ?•ì •? í° ?´í›„?ì„œ ë§ˆì?ë§??´ë¦„ë§?? íƒ  if (CORR_RE.test(u)) {    const after = raw.split(CORR_RE).pop() || "";    const cands = extractNames(after);    if (cands.length > 0) {      const last = cands[cands.length - 1];      return { intent: "SET_NAME", slot: { name: last }, _debug: { candidates: cands, picked: last } };    }    const all = extractNames(raw);    if (all.length > 0) {      const last = all[all.length - 1];      return { intent: "SET_NAME", slot: { name: last }, _debug: { candidates: all, picked: last } };    }  }  // "???´ë¦„?€ ..." ?¨í„´  const m1 = u.match(/(??s*?´ë¦„?€|??s*?´ë¦„?€|i am|my name is)\s*([a-zê°€-??s.'-]{2,})/i);  if (m1) {    const cleaned = normalizeName(m1[2]);    if (cleaned) return { intent: "SET_NAME", slot: { name: cleaned }, _debug: { picked: cleaned } };  }  // ë³´ìˆ˜?? ë¬¸ì¥ ?„ì²´?ì„œ ?¨ì¼ ?´ë¦„ ?¸ì‹  const kr = normalizeName(raw);  if (/^[ê°€-??{2,6}$/.test(kr)) {    return { intent: "SET_NAME", slot: { name: kr }, _debug: { picked: kr } };  }  return { intent: "UNKNOWN" };}/* =============== ?”ì ? ì? ê·œì¹™(?…ë°?´íŠ¸ ?¬ë? ?ë‹¨) =============== *//** ?…ë°?´íŠ¸ ?ë‹¨ ì»¨í…?¤íŠ¸ */export type UpdateCtx = {  /** ê°™ì? ?”ì?¼ê³  ?ë‹¨(voiceprint/diarization ê²°ê³¼) */  sameSpeaker?: boolean;  /** ë°œí™”ê°€ ?•ì •(?„ë‹ˆê³??„ë‹ˆ??ë§ê³ ???¸ì? */  isCorrection?: boolean;  /** ë§ˆì?ë§??Œì ˆ ?ŒíŠ¸(êµ?????????ë¥??ë¬¸?ì„œ ê°ì???ë¬¸ì??*/  hintText?: string;};/** ?´ì „ ?´ë¦„(prev)ê³????„ë³´(next) ì¤??´ë–¤ ê±?ì±„íƒ? ì? ê²°ì • */export function shouldUpdateName(prev: string, next: string, ctx: UpdateCtx = {}) {  const p = normalizeName(prev);  const n = normalizeName(next);  if (!n) return { update: false, reason: "invalid_next" };  if (!p) return { update: true, reason: "no_prev" };  // ê¸°ë³¸: ê°™ì? ?”ì + (?•ì •?´ê±°??ì¶©ë¶„??? ì‚¬)???Œë§Œ êµì²´  const same = !!ctx.sameSpeaker;  const corr = !!ctx.isCorrection;  // ? ì‚¬???¸ì§‘ê±°ë¦¬/?ëª¨ê±°ë¦¬)  const ed = editDistance(p, n);  const jd = jamoDistance(p.at(-1) || "", n.at(-1) || "");  // ?•ì •??ê²½ìš° ?„í™”(??ê¸€??ì°¨ì´ë©?ë¬´ì¡°ê±?êµì²´)  if (corr && (ed <= 1 || jd <= 1)) return { update: true, reason: "correction_close" };  // ê°™ì? ?”ì + ??ê¸€??ì°¨ì´ë©?êµì²´ ?ˆìš©  if (same && (ed <= 1 || jd <= 1)) return { update: true, reason: "same_speaker_close" };  // ?„ì „???¬ë¼ ë³´ì´ë©?? ì?  if (ed >= 2 && jd > 1) return { update: false, reason: "too_diff" };  // ?ŒíŠ¸ ?ìŠ¤?¸ê? ë§ˆì?ë§??Œì ˆê³??¼ì¹˜?˜ë©´ êµì²´ ìª?ê°€??  if (ctx.hintText) {    const last = n.at(-1);    if (last && ctx.hintText.includes(last)) return { update: true, reason: "hint_bonus" };  }  // ê·??? ê°™ì? ?”ì???Œë§Œ êµì²´  return { update: same, reason: same ? "same_speaker" : "not_same_speaker" };}/* =============== ê³ ìˆ˜ì¤€ ë¦¬ë?????ì¤„ë¡œ ì²˜ë¦¬) =============== *//** ??ë²ˆì˜ ë°œí™”ë¥?ë°›ì•„ ?´ë¦„??ê°±ì‹ ? ì? ê²°ì • */export function reduceName(prev: string, rawUtter: string, ctx: UpdateCtx = {}) {  const isCorr = isCorrectionUtter(rawUtter.toLowerCase());  const processed = reRankNameCandidates([rawUtter], rawUtter); // ë§ˆì?ë§??Œì ˆ ?ŒíŠ¸ ë°˜ì˜  const { intent, slot } = parseUtterance(processed);  if (intent !== "SET_NAME" || !slot?.name) {    return { next: prev, updated: false, reason: "no_name_intent" };  }  const next = slot.name;  const judge = shouldUpdateName(prev, next, { ...ctx, isCorrection: isCorr, hintText: rawUtter });  return { next: judge.update ? next : prev, updated: judge.update, reason: judge.reason };}// ===== NLU Helpers for email accumulation =====// ë°˜ë³µ ?¨í„´ ì¶•ì•½: 2~6ê¸€??ë¸”ë¡???°ì† 2???´ìƒ ë°˜ë³µ?˜ë©´ 1?Œë¡œ ì¶•ì•½function compressRepeats(s: string): string {  return s.replace(/(.{2,6})\1{1,}/g, "$1");}// ??ë¬¸ì?´ì˜ ìµœì¥ ?‘í•©(???? ê²¹ì¹¨ ê¸¸ì´function longestOverlap(a: string, b: string): number {  const max = Math.min(a.length, b.length);  for (let k = max; k > 0; k--) {    if (a.slice(-k) === b.slice(0, k)) return k;  }  return 0;}// ë¶€ë¶?ID ?•ê·œ?? ê³µë°±/?œê? ?œê±°, ?Œë¬¸?? ?ˆì „ë¬¸ìë§?? ì?export function normalizeEmailId(raw: string): string {  return raw    .toLowerCase()    .replace(/[^\w.+-]/g, "") // ?ë¬¸/?«ì/_ . + - ë§??¨ê?    .replace(/[????????ê°€-??s]/g, "");}// ?„ë©”???•ê·œ?? ?œê? ë°œí™” ?•ê·œ??+ ?Œë¬¸??+ ???ë¬¸ë§?export function normalizeDomain(raw: string): string {  const m = raw    .toLowerCase()    // ?œê? ë°œí™” ë³´ì •    .replace(/\bì§€ ?ë©”ì¼\b/g, "gmail")    .replace(/\b?¤ì´ë²?b/g, "naver")    .replace(/\b?¤ìŒ\b/g, "daum")    .replace(/\b?„ì›ƒë£?b/g, "outlook")    .replace(/\b??b/g, ".")    .replace(/\s+/g, "");  return m.replace(/[^a-z0-9.-]/g, "");}// ID ë¨¸ì?: append ?€??'?€ì²??•ì¥' ê·œì¹™ ?ìš©export function mergeId(prev: string, next: string): string {  const p = normalizeEmailId(prev);  const n = normalizeEmailId(next);  if (!p) return n;  if (!n) return p;  if (n.startsWith(p)) return compressRepeats(n);   // ?•ì¥  if (p.startsWith(n)) return compressRepeats(p);   // ??ì§§ì? ? ë§‰ ??? ì?  if (n.includes(p))   return compressRepeats(n);   // ì¤‘ê°„ ?½ì…/ì¤‘ë³µ  if (p.includes(n))   return compressRepeats(p);  // ê²¹ì¹¨ ?‘í•©  const ov = longestOverlap(p, n);  if (ov > 0) return compressRepeats(p + n.slice(ov));  // ë§ˆì?ë§??ˆì „?¥ì¹˜: ??ê¸?ìª?? íƒ  return compressRepeats(p.length >= n.length ? p : n);}// ?„ë©”??ë¨¸ì?:  sub + root(.com ?? ?œì„œë¡??ˆì •??export function mergeDomain(prev: string, next: string): string {  const p = normalizeDomain(prev);  const n = normalizeDomain(next);  if (!p) return n;  if (!n) return p;  if (n.startsWith(p)) return n;  if (p.startsWith(n)) return p;  // gmail + .com / gmail.com + com ??gmail.com  if (p.endsWith(".") && /^[a-z]{2,10}$/.test(n)) return p + n;  if (n.endsWith(".") && /^[a-z]{2,10}$/.test(n)) return n + p;  // ????ë£¨íŠ¸ ?„ë©”?¸ì´ë©???ê¸?ìª?  return p.length >= n.length ? p : n;}// ?´ë©”???íƒœ ê´€ë¦?(?‘ì—… ë²„í¼)export const emailState = {  idDraft: "",  domDraft: "",  committed: false,  session: 0,};// ? í°???´ë©”??ID ?„ë³´ë¡?ê°ì??ì„ ??export function applyIdToken(piece: string) {  const merged = mergeId(emailState.idDraft, piece);  emailState.idDraft = merged;  emitPreview(); // ë¯¸ë¦¬ë³´ê¸° ê°±ì‹  (UI??'id@dom' ?„ì‹œ ?œì‹œ)}// ? í°???„ë©”???„ë³´ë¡?ê°ì??ì„ ??export function applyDomainToken(piece: string) {  const merged = mergeDomain(emailState.domDraft, piece);  emailState.domDraft = merged;  emitPreview();}// ë¯¸ë¦¬ë³´ê¸°(?”ë²„ê·??”ë©´)??draftë¥?'?€ì²?ë¡?ë°˜ì˜function emitPreview() {  const id = emailState.idDraft;  const dom = emailState.domDraft;  const draft = [id, dom].filter(Boolean).join("@");  // ?¬ê¸°??ê¸°ì¡´???°ì‹œ???„ë¦¬ë·?ê°±ì‹  ë¡œê¹…/?íƒœ ?¸í„°ë¡?êµì²´  // pushLog(`?“§ draft: ${draft}`);  // setEmailDraft(draft) ê°™ì???}// ìµœì¢… ì»¤ë°‹: id + dom ?????•ì •?ì„ ?Œë§Œ 1??ì»¤ë°‹export function commitEmailIfReady(onCommit: (finalEmail: string) => void) {  const { idDraft, domDraft } = emailState;  if (!idDraft || !domDraft) return;  const finalEmail = `${normalizeEmailId(idDraft)}@${normalizeDomain(domDraft)}`;  // ? íš¨??ê°„ë‹¨ ì²´í¬  if (!/^[a-z0-9._%+-]{1,64}$/.test(normalizeEmailId(idDraft))) return;  if (!/^[a-z0-9.-]+\.[a-z]{2,10}$/.test(normalizeEmailId(domDraft))) return;  onCommit(finalEmail);  // ??ì»¤ë°‹ ???‘ì—… ë²„í¼ ì´ˆê¸°??(?¬ê¸°ê°€ ë§¤ìš° ì¤‘ìš”!)  emailState.idDraft = "";  emailState.domDraft = "";  emailState.committed = true;  emailState.session++;  emitPreview();}// "?´ë©”???…ë ¥ ì´ˆê¸°?? ê°™ì? ëª…ë ¹?´ê? ?¤ì–´?”ì„ ??export function resetEmailDraft() {  emailState.idDraft = "";  emailState.domDraft = "";  emailState.committed = false;  emitPreview();}
