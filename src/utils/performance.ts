// ?±ëŠ¥ ìµœì ??? í‹¸ë¦¬í‹°// ?´ë?ì§€ ì§€??ë¡œë”©???„í•œ Intersection Observerexport const createImageObserver = (  callback: (entry: IntersectionObserverEntry) => void,  options: IntersectionObserverInit = {}) => {  const defaultOptions: IntersectionObserverInit = {    root: null,    rootMargin: '50px',    threshold: 0.1,    ...options  };  return new IntersectionObserver((entries) => {    entries.forEach(callback);  }, defaultOptions);};// ?”ë°”?´ìŠ¤ ?¨ìˆ˜export const debounce = <T extends (...args: any[]) => any>(  func: T,  wait: number): ((...args: Parameters<T>) => void) => {  let timeout: NodeJS.Timeout;    return (...args: Parameters<T>) => {    clearTimeout(timeout);    timeout = setTimeout(() => func(...args), wait);  };};// ?¤ë¡œ?€ ?¨ìˆ˜export const throttle = <T extends (...args: any[]) => any>(  func: T,  limit: number): ((...args: Parameters<T>) => void) => {  let inThrottle: boolean;    return (...args: Parameters<T>) => {    if (!inThrottle) {      func(...args);      inThrottle = true;      setTimeout(() => inThrottle = false, limit);    }  };};// ?´ë?ì§€ ìµœì ???¨ìˆ˜export const optimizeImage = async (  file: File,  options: {    maxWidth?: number;    maxHeight?: number;    quality?: number;    format?: 'webp' | 'avif' | 'jpeg' | 'png';  } = {}): Promise<File> => {  const {    maxWidth = 1600,    maxHeight = 1600,    quality = 0.8,    format = 'webp'  } = options;  return new Promise((resolve, reject) => {    const canvas = document.createElement('canvas');    const ctx = canvas.getContext('2d');    const img = new Image();    img.onload = () => {      // ìº”ë²„???¬ê¸° ê³„ì‚°      const { width, height } = calculateDimensions(        img.width,        img.height,        maxWidth,        maxHeight      );      canvas.width = width;      canvas.height = height;      // ?´ë?ì§€ ê·¸ë¦¬ê¸?      ctx?.drawImage(img, 0, 0, width, height);      // ?¬ë§·ë³??ˆì§ˆ ?¤ì •      let mimeType: string;      let qualityValue: number;      switch (format) {        case 'webp':          mimeType = 'image/webp';          qualityValue = quality;          break;        case 'avif':          mimeType = 'image/avif';          qualityValue = quality;          break;        case 'jpeg':          mimeType = 'image/jpeg';          qualityValue = quality;          break;        case 'png':          mimeType = 'image/png';          qualityValue = 1;          break;        default:          mimeType = 'image/webp';          qualityValue = quality;      }      // ìº”ë²„?¤ë? Blob?¼ë¡œ ë³€??      canvas.toBlob(        (blob) => {          if (blob) {            const optimizedFile = new File([blob], file.name, {              type: mimeType,              lastModified: Date.now()            });            resolve(optimizedFile);          } else {            reject(new Error('?´ë?ì§€ ìµœì ???¤íŒ¨'));          }        },        mimeType,        qualityValue      );    };    img.onerror = () => reject(new Error('?´ë?ì§€ ë¡œë“œ ?¤íŒ¨'));    img.src = URL.createObjectURL(file);  });};// ?´ë?ì§€ ?¬ê¸° ê³„ì‚°const calculateDimensions = (  originalWidth: number,  originalHeight: number,  maxWidth: number,  maxHeight: number) => {  let { width, height } = { width: originalWidth, height: originalHeight };  if (width > maxWidth) {    height = (height * maxWidth) / width;    width = maxWidth;  }  if (height > maxHeight) {    width = (width * maxHeight) / height;    height = maxHeight;  }  return { width: Math.round(width), height: Math.round(height) };};// ë©”ëª¨ë¦??¬ìš©??ëª¨ë‹ˆ?°ë§export const monitorMemoryUsage = () => {  if ('memory' in performance) {    const memory = (performance as any).memory;    const used = Math.round(memory.usedJSHeapSize / 1048576);    const total = Math.round(memory.totalJSHeapSize / 1048576);    const limit = Math.round(memory.jsHeapSizeLimit / 1048576);        console.log(`ë©”ëª¨ë¦??¬ìš©?? ${used}MB / ${total}MB (?œí•œ: ${limit}MB)`);        // ë©”ëª¨ë¦??¬ìš©?‰ì´ 80%ë¥??˜ìœ¼ë©?ê²½ê³     if (used / limit > 0.8) {      console.warn('ë©”ëª¨ë¦??¬ìš©?‰ì´ ?’ìŠµ?ˆë‹¤. ?´ë?ì§€ ìºì‹œë¥??•ë¦¬?˜ì„¸??');    }  }};// ?´ë?ì§€ ìºì‹œ ?•ë¦¬export const clearImageCache = () => {  // URL.createObjectURLë¡??ì„±??ê°ì²´???•ë¦¬  if ('revokeObjectURL' in URL) {    // ?¤ì œë¡œëŠ” ê°??´ë?ì§€ URL??ì¶”ì ?´ì„œ ?•ë¦¬?´ì•¼ ??    console.log('?´ë?ì§€ ìºì‹œ ?•ë¦¬ ?„ë£Œ');  }}; 
