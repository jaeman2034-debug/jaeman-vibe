"use strict";
// File: src/utils/speechName.ts// ?�국???�름 ?�성 ???�스???�규??+ 짧�? ?�막 ?�적const STOPWORDS = [  "?�이름�?","???�름?�","?�??,"?�름?�","?�라�?,"?�고??,"?�고","?�니??,"?�에??,"?�니??,  "?�니??","?�에??","?�고??","?�고.","?�요","?�요.","?�니?�요",".","-"];// ??글???�러(?�리) ???�독?�로 ?�어?�면 버림const FILLERS_1 = ["??,"??,"??,"??,"??,"??,"??,"??,"?�니??,"??];function stripStopWords(s: string) {  let x = s;  for (const w of STOPWORDS) x = x.split(w).join("");  return x;}function onlyHangul(s: string) {  // ?��?/?�어?�기/?�이?�만 ?��?  return (s || "")    .replace(/[^\uAC00-\uD7A3\s-]/g, "") // ?��? ???�거    .replace(/\s+/g, "")                 // 공백 ?�거    .replace(/[.-]+$/g, "");             // ?�의 ???�이???�거}export function normalizeName(raw: string) {  let s = (raw || "").trim();  s = s.replace(/\./g, "");       // 문장부?�성 ???�거  s = stripStopWords(s);  s = onlyHangul(s);  // ?��?/?�칭 ?�거  s = s.replace(/(????$/g, "");  return s;}/** prev?????�막???�적. 2글???�상 ?�면 ?�정 가??*/export function appendNamePiece(prev: string, raw: string) {  let piece = normalizeName(raw);  if (!piece) return { name: prev, changed: false };  // ?�독 1글???�러�?버림  if (piece.length === 1 && FILLERS_1.includes(piece)) {    return { name: prev, changed: false };  }  // 1글?�면 ?�적(?�전�??�쳐 2??만들�?  if (piece.length === 1) return { name: (prev + piece), changed: true };  if (!prev) return { name: piece, changed: true };  if (piece.includes(prev)) return { name: piece, changed: true };  if (prev.length === 1 && piece.startsWith(prev)) return { name: piece, changed: true };  const concat = prev + piece;  return { name: concat.length <= 5 ? concat : piece, changed: true };}/** ?�효?? 2???�상(?�국??기본 규칙) */export const isValidName = (s: string) => (normalizeName(s).length >= 2); 
