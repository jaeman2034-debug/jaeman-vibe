"use strict";
// src/utils/voiceSignupParser.tsexport type ParsedSignup = {    name: string | null;    email: string | null;    phone: string | null;    password: string | null;    debug?: {      emailRaw?: string;      phoneRaw?: string;      nameCandidates?: string[];      passwordRaw?: string;      tokens?: string[];    };  };// === NEW: ?�션 ===export type ParseMode = "mixed" | "en_strict";export interface ParseOptions {  emailMode?: ParseMode;           // default: "mixed"  passwordMode?: ParseMode;        // default: "mixed"  emailPick?: "first" | "last";    // ?�효 ?�메??�??�택 기�? (mixed=last, en_strict=first 권장)  passwordOrder?: "as_spoken" | "letters_first" | "digits_first"; // ??NEW}// === ?�?????�서 ?�장 ===// ?�연?�도 ?�식?�여 ?�?�체?�서 ?�정?�인 구간 ?�싱// - ?�메?? "메일주소??..", "?�메??주소??.." ??// - 비�?번호: "?�호??..", "?�스?�드??.." ?? // - ?�화: "?��??��?...", "?�락처는..." ??// [ADD] ?�메??구간 ?�큰 ?�리?�터: STT ?�음(amp/주소/?�메???? ?�거function filterEmailNoiseToken(t: string) {  const x = t.toLowerCase();  // ?�한 STT ?�음  if (x === "amp" || x === "&" || x === "주소" || x === "address") return "";  if (x === "?�메?? || x === "메일" || x === "email" || x === "e") return "";  return t;}// ?�한 ?��? 보정function fixEmailDomain(domain: string) {  let d = domain.toLowerCase().replace(/[^\w.\-]/g, "").replace(/\.\.+/g, ".");  const gmailLike = ["demail.com","gemail.com","qmail.com","gmai.com","gmaii.com","gmai1.com","gnail.com","gmall.com","gmail.co"];  if (gmailLike.includes(d)) d = "gmail.com";  if (d === "naver.co") d = "naver.com";  if (d === "hotmail.co") d = "hotmail.com";  return d;}// ??NEW: ga.com.gmail.com ??gmail.com, abc.naver.co.kr ??naver.co.krfunction normalizeDomain(d: string) {  const labels = d.split(".").filter(Boolean);  if (labels.length <= 2) return labels.join(".");  const last = labels[labels.length - 1];  const second = labels[labels.length - 2];  const third = labels[labels.length - 3];  const isCc = /^[a-z]{2}$/i.test(last);  const slds = new Set(["co","or","ac","go","ne","re"]);  if (isCc && slds.has(second)) return [third, second, last].join("."); // *.co.kr  return [second, last].join("."); // ?�반 ?�메?��? 마�?�????�벨�?}    // ===== 공통 ?�처�?& ?�전 =====    const KO_SYMBOLS: Record<string, string> = {    "골뱅??: "@",    "??: "@",    "?�드?�인": "@",    "??: ".",    "??: ".",    "?�컴": ".com",    "?�넷": ".net",    "?�오?��?": ".org",      "?�낌??: "!",    "?�스?�라메이??: "!",    "??: "#",    "?�시": "#",    "?�러": "$",    "?�센??: "%",    "?�드": "&",    "?�퍼?�드": "&",    "별표": "*",    "?�러??: "+",    "?�이??: "-",    "빼기": "-",    "?�더�?: "_",    "?�더?�코??: "_",    "?�래??: "/",    "??��?�시": "\\",    "공백": " ",    "?�페?�스": " ",    "마침??: ".",  };    const PROVIDER_KO: Record<string, string> = {    "지메일": "gmail",    "지 메일": "gmail",    "구�?메일": "gmail",    "?�이�?: "naver",    "?�음": "daum",    "?�메??: "hanmail",    "?�이??: "nate",    "카카??: "kakao",    "?�후": "yahoo",    "?�메??: "hotmail",  };    const TLD_KO: Record<string, string> = {    "�?: "com",    "??: "net",    "?�알지": "org",    "?�오": "co",    "케?�알": "kr",    "코리??: "kr",    "?�이??: "jp",    "?��???: "uk",    "?��?": "edu",  };    // ?�메?�에???�주 ?�는 ?�문???��? 발음  const KO_ALPHA: Record<string, string> = {    "?�이": "a", "�?: "b", "??: "c", "??: "d", "?�이": "e",    "?�프": "f", "지": "g", "?�이�?: "h", "?�이": "i", "?�이": "j",    "케??: "k", "??: "l", "??: "m", "??: "n", "??: "o",    "??: "p", "??: "q", "?�르": "r", "?�스": "s", "??: "t",    "??: "u", "브이": "v", "?�블??: "w", "?�스": "x", "?�??: "y", "?�트": "z",  };    // ?�국???�자 ???�자  const KO_NUM: Record<string, string> = {    "�?: "0", "??: "0", "?�로": "0",    "?�나": "1", "??: "1", "??: "1",    "??: "2", "??: "2", "??: "2",    "??: "3", "??: "3", "??: "3",    "??: "4", "??: "4", "??: "4",    "?�섯": "5", "??: "5",    "?�섯": "6", "??: "6",    "?�곱": "7", "�?: "7",    "?�덟": "8", "??: "8",    "?�홉": "9", "�?: "9",  };    const FILLERS = [    "?�니??, "?�니??", "?�에??, "?�요", "?�니?�요",    "?�고??, "?�고", "?�고,", "?�고.", "?�고 ?�니??,    "?�니?�요.", "?�고", "?�고??, "?�고 ?�니??,  ];    function normalizeSpaces(s: string) {    return s.replace(/\s+/g, " ").trim();  }    function splitToTokens(s: string): string[] {    const kept = /[@._\-+!#$/\\]/;    const out: string[] = [];    let cur = "";    const pushCur = () => { if (cur) { out.push(cur); cur = ""; } };      for (const ch of s) {      if (/\s/.test(ch)) { pushCur(); continue; }      if (kept.test(ch)) { pushCur(); out.push(ch); continue; }      if (/[0-9A-Za-z\u3131-\uD79D]/.test(ch)) { cur += ch; }      else { pushCur(); }    }    pushCur();    return out;  }    // ===== ?�메???�용 ?�퍼 =====  // [REPLACE] 구간 추출 ?�퍼  function sliceWindow(tokens: string[], startCues: string[], endCues: string[]) {    const lt = tokens.map(t => t.toLowerCase());    let s = lt.findIndex(t =>      startCues.some(c => t.includes(c)) || t === "@" || t === "골뱅??    );    if (s < 0) return null;    let e = tokens.length;    for (let i = s + 1; i < tokens.length; i++) {      const t = lt[i];      // '?�니??, '?�니??', '?�에?? ???�함?�면 종료      if (t.includes("?�니??) || t.includes("?�에??) || t.includes("?�요") || t.includes("??)) { e = i; break; }      if (endCues.some(c => t.includes(c))) { e = i; break; }    }    return tokens.slice(s, e);  }    function looksLikePhoneDigits(t: string) {    return /^01\d{8,9}$/.test(t); // 01x�??�작 10~11?�리  }  // ??.)?�로 ?�긴 ?�펠�??�을 마�?�?것만 뽑아 붙이�?+ ?�이�?�?  function sanitizeEmailLocal(local: string) {    let s = local.toLowerCase();    // ?�화 ?�염 ?�거    s = s.replace(/01\d{6,}[a-z0-9-]*/g, "");    s = s.replace(/(?:^|\.)01\d{6,}[a-z0-9-]*(?=\.|$)/g, "");    // ?�용 ???�거    s = s.replace(/[^\w.\-]/g, "");    // ??기�? 분할    let parts = s.split(".").filter(Boolean);    // ?�한 ?�이�?조각 ?�거(amp, jje, mail/gmail ??    const NOISE = new Set(["amp", "jje", "mail", "email", "gmail"]);    parts = parts.filter(p => !NOISE.has(p));    // ?�화처럼 �??�자 ?�어�??�거    parts = parts.filter(p => !/^\d{6,}$/.test(p));    // --- ?�심: "?�펠�??? ?��?(??글??a~z ?�는 ???�리 ?�자가 '.'�??�속??구간) ---    type Run = { from: number; to: number; items: string[] };    const runs: Run[] = [];    let i = 0;    while (i < parts.length) {      const isSpellish = (x: string) => /^[a-z0-9]$/.test(x);      if (!isSpellish(parts[i])) { i++; continue; }      const start = i;      const arr = [parts[i]];      i++;      while (i < parts.length && isSpellish(parts[i])) { arr.push(parts[i]); i++; }      if (arr.length >= 3) runs.push({ from: start, to: i - 1, items: arr });    }    if (runs.length) {      // 마�?�??�펠�??�을 채택 ??�??��?분을 ?�뢰      const last = runs[runs.length - 1];      const joined = last.items.join(""); // ?? j.a.e.m.a.n.2.0.3.4 ??jaeman2034      s = joined;    } else {      // ?�펠�??�이 ?�으�?짧�? 조각??3�??�상?�면 ?�치�?jae.man.2034 ??      const allShort = parts.every(p => p.length <= 4);      const hasDigitChunk = parts.some(p => /^\d{2,}$/.test(p));      const alphaCount = parts.filter(p => /^[a-z]+$/.test(p)).length;      s = (parts.length >= 3 && allShort && (hasDigitChunk || alphaCount >= 2))        ? parts.join("")        : parts.join(".");    }    // ?�쪽 TLD/?�음 ?�거(?�수�??�인 com/co/kr ??    s = s.replace(/\.(?:com|net|org|co|kr|jp|uk|edu)$/g, "");    // 마무�?    s = s.replace(/\.+/g, ".").replace(/^\./, "").replace(/\.$/, "");    if (!s) s = "id";    return s;  }  // ?�메??최종 ?�리 + ?�효??검????반환  function finalizeEmail(buf: string): string | null {    let b = buf      .replace(/[^\w.@\-]+/g, "") // ?��? ???�거      .replace(/@+/g, "@")      .replace(/\.\.+/g, ".")      .replace(/\.@/g, "@")      .replace(/@\./g, "@");    if (!b.includes("@")) return null;    let [local, domain] = b.split("@");    local = sanitizeEmailLocal(local);    domain = (domain || "")      .replace(/[^\w.\-]/g, "")      .replace(/\.\.+/g, ".")      .replace(/^\./, "")      .replace(/\.$/, "");    const email = `${local}@${domain}`;    const re = /^[A-Za-z0-9._\-]+@[A-Za-z0-9._\-]+\.[A-Za-z]{2,}$/;    return re.test(email) ? email : null;  }      // ===== ?�메???�싱(강화 버전) =====  // 보조: '@' ?�전?�서 ?�화 ?�새?�는 ?�숫??�?  function phoneishAlnumPreAt(t: string) {    return /01\d{5,}/.test(t); // ?? 0105689abc123456  }  // [REPLACE] tokensToEmail (Strict EN/?�합 모두?�서 ?�용)  function tokensToEmail(tokens: string[], mode: ParseMode = "mixed", pick: "first" | "last" = "last"): string | null {    // ?�메??구간 ???�장: ?�연?�도 ?�식    const EMAIL_START = ["?�메??, "메일", "?�메?�주??, "메일주소", "email", "e메일", "??�???];    const EMAIL_END   = ["?�화", "?�화번호", "번호", "?�드??, "?��???, "?�락�?, "비�?번호", "비�?번호??, "?�스?�드", "?�호"];        const win = sliceWindow(      tokens,      EMAIL_START,      EMAIL_END    );    const list = (win ?? tokens);    let seenAt = false;    const parts: string[] = [];    for (const raw0 of list) {      const raw = filterEmailNoiseToken(raw0);       // ???�음 ?�큰 ?�거      if (!raw) continue;      const t = raw.toLowerCase();      // 기호/?�전      if (t === "@" || t === "골뱅??) { parts.push("@"); seenAt = true; continue; }      if (t === "." || t === "?? || t === "??) { parts.push("."); continue; }      if (PROVIDER_KO[t]) { if (!seenAt) { parts.push("@"); seenAt = true; } parts.push(PROVIDER_KO[t]); continue; }      if (TLD_KO[t])      { if (seenAt) { if (parts[parts.length-1] !== ".") parts.push("."); parts.push(TLD_KO[t]); } continue; }      if (KO_ALPHA[t])    { parts.push(KO_ALPHA[t]); continue; }      // 모드�??�터      if (mode === "en_strict") {        if (/^[A-Za-z0-9._\-]+$/.test(raw)) parts.push(raw);      } else {        if (/^[A-Za-z0-9._\-]+$/.test(raw)) parts.push(raw);      }    }    const s = parts.join("")      .replace(/\s+/g, "")      .replace(/\.@/g, "@")      .replace(/@\./g, "@")      .replace(/\.\.+/g, ".");    const re = /[A-Za-z0-9._\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}/g;    const matches = Array.from(s.matchAll(re)).map(m => m[0]);    const chosen = matches.length ? (pick === "first" ? matches[0] : matches[matches.length - 1]) : null;    if (!chosen) return null;    let [local, domain] = chosen.split("@");    local = sanitizeEmailLocal(local);    domain = fixEmailDomain(domain);    domain = normalizeDomain(domain);    const email = `${local}@${domain}`;    return /^[A-Za-z0-9._\-]+@[A-Za-z0-9._\-]+\.[A-Za-z]{2,}$/.test(email) ? email : null;  }    // ===== ?�화번호 처리(기존 로직 ?��?) =====  // ?�화번호 구간 ???�장: ?�연?�도 ?�식  // const PHONE_START = ["?�화", "?�화번호", "번호", "?�드??, "?��???, "?�락�?];  function tokensToPhone(tokens: string[]): string | null {    const joined = tokens.join(" ");    const rough = joined      .replace(/[^\u3131-\uD79D0-9\- ]/g, " ")      .replace(/\s+/g, " ")      .trim();      if (!rough) return null;      const parts = rough.split(" ");    let digits = "";    for (const p of parts) {      const t = p.toLowerCase();        if (/^\d+$/.test(t)) { digits += t; continue; }      if (t === "-" || t === "빼기" || t === "?�이??) { continue; }        if (KO_NUM[t]) { digits += KO_NUM[t]; continue; }        const expanded = [...t].map(ch => KO_NUM[ch] ?? "").join("");      if (expanded && /^[0-9]+$/.test(expanded)) {        digits += expanded;        continue;      }    }      const m = digits.match(/01\d(\d{7,8})/);    if (!m) return null;      const start = digits.indexOf(m[0]);    const candidate = digits.slice(start, start + m[0].length);    if (candidate.length === 11) {      return `${candidate.slice(0, 3)}-${candidate.slice(3, 7)}-${candidate.slice(7)}`;    }    if (candidate.length === 10) {      return `${candidate.slice(0, 3)}-${candidate.slice(3, 6)}-${candidate.slice(6)}`;    }    return null;  }      // ===== ?�름 처리(강화 버전) =====  // [REPLACE] ?�름 ?�서  function extractName(s: string): { value: string | null; candidates: string[] } {    const clean = s.replace(/\s+/g, " ");    const ignoreExact = new Set([      "?�녕?�세??,"?�녕","감사?�니??,"감사",      "?�니??,"?�에??,"?�요",      "?�화번호","?�메??,"비�?번호","번호","?�화","비번",      "?�??,"?�는","??,"??,"?�름?�"    ]);    const isGreeting = (w: string) => /^?�녕??.test(w);    const strip = (w: string) =>      w.replace(/(????$/, "")       .replace(/\s+/g, "")       .replace(/?�니????s]*$/, "")       .replace(/[.,]+$/, "");    const cands: string[] = [];    const m0 = clean.match(/([가-??{2,6})\s*?�니??);    if (m0) cands.push(strip(m0[1]));    const m1 = clean.match(/(?:?????\s*?�름?�\s*([가-??{1,3}\s?[가-??{1,3})(?:?????/);    if (m1) cands.push(strip(m1[1]));    const m2 = clean.match(/(?:?�???�는)\s*([가-??{1,3}\s?[가-??{1,3})(?:?????\s*(?:?�니???�에???�요|?�고)?/);    if (m2) cands.push(strip(m2[1]));    const all = clean.match(/[가-??{2,7}/g) ?? [];    for (let w of all) {      const sw = strip(w);      if (sw.length >= 2 && sw.length <= 6 && !ignoreExact.has(sw) && !isGreeting(sw)) cands.push(sw);    }    const uniq = Array.from(new Set(cands)).filter(w => !ignoreExact.has(w) && !isGreeting(w));    const best = uniq.length ? uniq[0] : null;    return { value: best, candidates: uniq };  }           // [REPLACE] 비�?번호 ?�서: ?�양???�인??cue + 구두??공백 ?�거 + ?�문·?�자 ?�함 검??   function tokensToPassword(     tokens: string[],     mode: ParseMode = "mixed",     opts?: ParseOptions   ): { value: string | null; raw: string } {         // 1) cue(?�워?? ?�게 ?�용: '�?밀 �???, '비번', '비빌번호', '비�? 번호',     //    ?�문 'password', 'pass word', 'pw' ??+ ?�연??변??     const joined = tokens.join(" ");     const PASS_CUE = /(�?s*밀\s*�?s*??�?s*�?�?s*�?비빌번호|비�?번호|?�호|?�스?�드|password|pass\s*word|pw)/i;    const m = joined.match(PASS_CUE);    if (!m) return { value: null, raw: "" };    // 2) cue ?�후부??문장 경계(., ?�니?? ????까�?�?tail�?    const start = m.index! + m[0].length;    let tail = joined.slice(start).trim();    const stops = [".", "?�니??, "??, "?�에??, "?�요", "?�화", "?�메??];    let stop = tail.length;    for (const s of stops) {      const i = tail.indexOf(s);      if (i >= 0) stop = Math.min(stop, i);    }    let raw = tail.slice(0, stop).trim();    // 3) ????구두???�리    raw = raw.replace(/^[^\w!@#$%&*._\-\\/+]+/, "").replace(/[^\w!@#$%&*._\-\\/+]+$/, "");    // 4) ?�큰??결합 (Strict EN?�면 ?��? ?�어 무시)    const pwTokens = splitToTokens(raw);    let buf = "";    for (const tk of pwTokens) {      const t = tk.toLowerCase();      // ?�용 기호/치환      if (KO_SYMBOLS[t]) { buf += KO_SYMBOLS[t]; continue; }      if (KO_ALPHA[t])   { buf += KO_ALPHA[t];   continue; }      if (KO_NUM[t])     { buf += KO_NUM[t];     continue; }      // ?�문/?�자      if (/^[A-Za-z0-9]+$/.test(tk)) { buf += tk; continue; }      // 기호 그�?�?      if (/[@._\-+!#$%&*\/\\]/.test(tk)) { buf += tk; continue; }      // Strict EN 모드?�선 ?��?/기�? 버림      if (mode === "en_strict") continue;    }         // 5) 최종 ?�화: 구분??구두??공백 ?�거 ??"Abc. 1234567" => "Abc1234567"     buf = buf.replace(/[.\s,·:;]+/g, "");     // ???�정???�션 ?�용     buf = reorderPassword(buf, opts?.passwordOrder ?? "as_spoken");     // 6) 검�? 8???�상 + ?�문/?�자�?1�??�상 ?�함     const hasLetter = /[A-Za-z]/.test(buf);     const hasDigit  = /\d/.test(buf);     const value = buf.length >= 8 && hasLetter && hasDigit ? buf : null;     return { value, raw };}// ??NEW: 비�?번호 ?�정???�우�?function reorderPassword(buf: string, order: "as_spoken"|"letters_first"|"digits_first") {  if (order === "as_spoken") return buf;  const letters = buf.replace(/[^A-Za-z]/g, "");  const digits  = buf.replace(/[^0-9]/g, "");  const symbols = buf.replace(/[A-Za-z0-9]/g, ""); // 기호??�??�로  if (order === "letters_first") return letters + digits + symbols;  if (order === "digits_first")  return digits + letters + symbols;  return buf;}    // ===== ?�싱 fallback 추�? =====// ?�문 ?�라?�에???�메??복구(???�어?�기 ?�여??function fallbackEmailFromRaw(s: string): string | null {  let t = s.toLowerCase();  // ?�국???�어 ?�서 치환  t = t.replace(/골뱅??at/gi, "@");  t = t.replace(/????dot/gi, ".");  // 기호 주위 공백 ?�리  t = t.replace(/@\s+/g, "@")       .replace(/\s+\./g, ".")       .replace(/(\w)\s+\.(?=\w)/g, "$1.")       .replace(/\.{2,}/g, ".");  // ?�메???�외 문자 축소  t = t.replace(/[^\w@.\-]+/g, " ");  const re = /[a-z0-9._\-]+@[a-z0-9.\-]+\.[a-z]{2,}/i;  const m = t.match(re);  return m ? m[0] : null;}// ====== ?�서 보강 ?�수??======// 1) ?�메?? @ ???��? ?�자/?�음 ?�리export function normalizeEmail(raw: string) {  const koNum: Record<string,string> = { �?"0",??"0",??"1",??"2",??"3",??"4",??"5",??"6",�?"7",??"8",�?"9" };  const m = raw.match(/([A-Za-z0-9._%+\- ]+)\s*([공영?�이?�사?�육칠팔�?)?\s*@\s*([A-Za-z0-9.\-]+)\s*\.\s*([A-Za-z]{2,})/i);  if (!m) return null;  const local = m[1].replace(/[ \.]/g, "").toLowerCase();  const hangul = m[2] ? (koNum[m[2]] ?? "") : "";  const domain = (m[3] + "." + m[4]).replace(/\s+/g, "").toLowerCase();  // ?��? ?�자가 ?�더?�도, 직전???�자???�만 1?�리 ?�자�?채택(�??�는 ?�음?�로 무시)  const local2 = /\d$/.test(local) ? local + hangul : local;  return `${local2}@${domain}`;}// 2) ?�화: ?�국???�자 ?�임 ?�용 + ?�어�??�치�?export function extractPhone(raw: string) {  const rep = (s: string) => s    .replace(/�?g,"0").replace(/??g,"0")    .replace(/??g,"1").replace(/??g,"2").replace(/??g,"3").replace(/??g,"4")    .replace(/??g,"5").replace(/??g,"6").replace(/�?g,"7").replace(/??g,"8").replace(/�?g,"9")    .replace(/[^\d]/g,"");  const digits = rep(raw);  const m = digits.match(/01[016789]\d{7,8}/); // 10~11?�리�?  if (!m) return "";  const d = m[0];  return d.length === 10 ? `${d.slice(0,3)}-${d.slice(3,6)}-${d.slice(6)}`                         : `${d.slice(0,3)}-${d.slice(3,7)}-${d.slice(7)}`;}// 3) 비�?번호: 철자 ?�위(A. B. C.), ?��? 철자�? ?�음 ?�거 ??결합export function extractPassword(raw: string) {  // 비번 구간�??�라?�기(가??마�?�?"비�?번호" ?�후 80??  const mm = raw.match(/(�?s*밀\s*�?s*??�?s*�??�호|password)[^A-Za-z0-9가-??{0,10}([\s\S]{0,80})$/i);  if (!mm) return { value:"", status:"missing" };  let s = mm[2];  // ?�음 ?�거  s = s.replace(/?�시 말할�?�??�아???�어|?�파�?그래|?�본???�니????./g, " ");  // ?��? 철자�????�문  const koLetter: Record<string,string> = { ?�이:"A", �?"B", ??"C", ??"D", ??"E", ?�프:"F", 지:"G", ?�이�?"H", ?�취:"H", ?�이:"I", ?�이:"J", 케??"K", ??"L", ??"M", ??"N", ??"O", ??"P", ??"Q", ??"R", ?�스:"S", ??"T", ??"U", 브이:"V", ?�블??"W", ?�스:"X", ?�??"Y", 지??"Z" };  s = s.replace(new RegExp(Object.keys(koLetter).join("|"),"g"), (m)=>koLetter[m]);  // A. B. C. / A B C / Abc. ?�태 모두 ?�용  s = s.replace(/\./g," ").replace(/\s+/g," ");  s = s.replace(/[^A-Za-z0-9!@#$%^&*_\-+= ]/g,"");  const letters = s.match(/[A-Za-z0-9!@#$%^&*_\-+=]+/g) || [];  const joined = letters.join("");  if (joined.length >= 8) return { value: joined, status: "ok" };  if (joined.length >= 6) return { value: joined, status: "weak" };  return { value:"", status:"missing" };}// ===== 메인 ?�트�?=====export function parseSignupFromText(    input: string,    optOrDebug?: boolean | ParseOptions,    debugMaybe?: boolean  ): ParsedSignup {    // 기존 ?�출(parseSignupFromText(text, true)) ?�환    let opts: ParseOptions = { emailMode: "mixed", passwordMode: "mixed", emailPick: "last" };    let withDebug = false;    if (typeof optOrDebug === "boolean") withDebug = optOrDebug;    else if (typeof optOrDebug === "object" && optOrDebug) {      opts = { ...opts, ...optOrDebug };      withDebug = !!debugMaybe;    }    const pre = normalizeSpaces(      input        .replace(/\u200B/g, "")        .replace(/[?��?']/g, " ")    );    const tokens = splitToTokens(pre);    let email = tokensToEmail(tokens, opts.emailMode!, opts.emailPick!);    if (!email) email = fallbackEmailFromRaw(pre);  // ??추�?    const phone = tokensToPhone(tokens);    const { value: name, candidates: nameCandidates } = extractName(pre);         const pw = tokensToPassword(tokens, opts.passwordMode!, opts);    const out: ParsedSignup = {      name: name ?? null,      email: email ?? null,      phone: phone ?? null,      password: pw.value ?? null,    };    if (withDebug) out.debug = { emailRaw: email ?? "", phoneRaw: phone ?? "", nameCandidates, passwordRaw: pw.raw, tokens };    return out;  }    // ===== Node?�서 빠른 ?�동 ?�스???�션) =====  if (typeof window === "undefined") {    const sample1 = "?�???�재만이�??�메?��? j a e m a n 2 0 3 4 골뱅??지메일 ??�??�니?? ?�화번호??공일�??�팔??구구구구. 비�?번호??a 1 2 3 4 5 6 7.";    const sample2 = "???�름?� 박선?? ?�메?��? id 골뱅???�이�???�? 번호??010 1234 5678, 비�?번호??qwer!234.";    console.log(parseSignupFromText(sample1, true));    console.log(parseSignupFromText(sample2, true));  }  
