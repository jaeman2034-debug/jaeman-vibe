// src/utils/voiceSignupParser.tsexport type ParsedSignup = {    name: string | null;    email: string | null;    phone: string | null;    password: string | null;    debug?: {      emailRaw?: string;      phoneRaw?: string;      nameCandidates?: string[];      passwordRaw?: string;      tokens?: string[];    };  };// === NEW: ?µì…˜ ===export type ParseMode = "mixed" | "en_strict";export interface ParseOptions {  emailMode?: ParseMode;           // default: "mixed"  passwordMode?: ParseMode;        // default: "mixed"  emailPick?: "first" | "last";    // ? íš¨ ?´ë©”??ì¤?? íƒ ê¸°ì? (mixed=last, en_strict=first ê¶Œì¥)  passwordOrder?: "as_spoken" | "letters_first" | "digits_first"; // ??NEW}// === ?€?????¨ì„œ ?•ì¥ ===// ?ì—°?´ë„ ?¸ì‹?˜ì—¬ ?€?”ì²´?ì„œ ?ˆì •?ì¸ êµ¬ê°„ ?Œì‹±// - ?´ë©”?? "ë©”ì¼ì£¼ì†Œ??..", "?´ë©”??ì£¼ì†Œ??.." ??// - ë¹„ë?ë²ˆí˜¸: "?”í˜¸??..", "?¨ìŠ¤?Œë“œ??.." ?? // - ?„í™”: "?´ë??°ì?...", "?°ë½ì²˜ëŠ”..." ??// [ADD] ?´ë©”??êµ¬ê°„ ? í° ?„ë¦¬?„í„°: STT ?¡ìŒ(amp/ì£¼ì†Œ/?´ë©”???? ?œê±°function filterEmailNoiseToken(t: string) {  const x = t.toLowerCase();  // ?”í•œ STT ?¡ìŒ  if (x === "amp" || x === "&" || x === "ì£¼ì†Œ" || x === "address") return "";  if (x === "?´ë©”?? || x === "ë©”ì¼" || x === "email" || x === "e") return "";  return t;}// ?”í•œ ?¤í? ë³´ì •function fixEmailDomain(domain: string) {  let d = domain.toLowerCase().replace(/[^\w.\-]/g, "").replace(/\.\.+/g, ".");  const gmailLike = ["demail.com","gemail.com","qmail.com","gmai.com","gmaii.com","gmai1.com","gnail.com","gmall.com","gmail.co"];  if (gmailLike.includes(d)) d = "gmail.com";  if (d === "naver.co") d = "naver.com";  if (d === "hotmail.co") d = "hotmail.com";  return d;}// ??NEW: ga.com.gmail.com ??gmail.com, abc.naver.co.kr ??naver.co.krfunction normalizeDomain(d: string) {  const labels = d.split(".").filter(Boolean);  if (labels.length <= 2) return labels.join(".");  const last = labels[labels.length - 1];  const second = labels[labels.length - 2];  const third = labels[labels.length - 3];  const isCc = /^[a-z]{2}$/i.test(last);  const slds = new Set(["co","or","ac","go","ne","re"]);  if (isCc && slds.has(second)) return [third, second, last].join("."); // *.co.kr  return [second, last].join("."); // ?¼ë°˜ ?„ë©”?¸ì? ë§ˆì?ë§????¼ë²¨ë§?}    // ===== ê³µí†µ ?„ì²˜ë¦?& ?¬ì „ =====    const KO_SYMBOLS: Record<string, string> = {    "ê³¨ë±…??: "@",    "??: "@",    "?ë“œ?¬ì¸": "@",    "??: ".",    "??: ".",    "?·ì»´": ".com",    "?·ë„·": ".net",    "?·ì˜¤?Œì?": ".org",      "?ë‚Œ??: "!",    "?‘ìŠ¤?´ë¼ë©”ì´??: "!",    "??: "#",    "?´ì‹œ": "#",    "?¬ëŸ¬": "$",    "?¼ì„¼??: "%",    "?¤ë“œ": "&",    "?¤í¼?¼ë“œ": "&",    "ë³„í‘œ": "*",    "?ŒëŸ¬??: "+",    "?˜ì´??: "-",    "ë¹¼ê¸°": "-",    "?¸ë”ë°?: "_",    "?¸ë”?¤ì½”??: "_",    "?¬ë˜??: "/",    "??Š¬?˜ì‹œ": "\\",    "ê³µë°±": " ",    "?¤í˜?´ìŠ¤": " ",    "ë§ˆì¹¨??: ".",  };    const PROVIDER_KO: Record<string, string> = {    "ì§€ë©”ì¼": "gmail",    "ì§€ ë©”ì¼": "gmail",    "êµ¬ê?ë©”ì¼": "gmail",    "?¤ì´ë²?: "naver",    "?¤ìŒ": "daum",    "?œë©”??: "hanmail",    "?¤ì´??: "nate",    "ì¹´ì¹´??: "kakao",    "?¼í›„": "yahoo",    "?«ë©”??: "hotmail",  };    const TLD_KO: Record<string, string> = {    "ì»?: "com",    "??: "net",    "?¤ì•Œì§€": "org",    "?¨ì˜¤": "co",    "ì¼€?´ì•Œ": "kr",    "ì½”ë¦¬??: "kr",    "?œì´??: "jp",    "? ì???: "uk",    "?ë?": "edu",  };    // ?´ë©”?¼ì—???ì£¼ ?°ëŠ” ?ë¬¸???œê? ë°œìŒ  const KO_ALPHA: Record<string, string> = {    "?ì´": "a", "ë¹?: "b", "??: "c", "??: "d", "?´ì´": "e",    "?í”„": "f", "ì§€": "g", "?ì´ì¹?: "h", "?„ì´": "i", "?œì´": "j",    "ì¼€??: "k", "??: "l", "??: "m", "??: "n", "??: "o",    "??: "p", "??: "q", "?„ë¥´": "r", "?ìŠ¤": "s", "??: "t",    "??: "u", "ë¸Œì´": "v", "?”ë¸”??: "w", "?‘ìŠ¤": "x", "?€??: "y", "?œíŠ¸": "z",  };    // ?œêµ­???«ì ???«ì  const KO_NUM: Record<string, string> = {    "ê³?: "0", "??: "0", "?œë¡œ": "0",    "?˜ë‚˜": "1", "??: "1", "??: "1",    "??: "2", "??: "2", "??: "2",    "??: "3", "??: "3", "??: "3",    "??: "4", "??: "4", "??: "4",    "?¤ì„¯": "5", "??: "5",    "?¬ì„¯": "6", "??: "6",    "?¼ê³±": "7", "ì¹?: "7",    "?¬ëŸ": "8", "??: "8",    "?„í™‰": "9", "êµ?: "9",  };    const FILLERS = [    "?…ë‹ˆ??, "?…ë‹ˆ??", "?´ì—??, "?ˆìš”", "?…ë‹ˆ?¤ìš”",    "?´ê³ ??, "?´ê³ ", "?´ê³ ,", "?´ê³ .", "?´ê³  ?…ë‹ˆ??,    "?…ë‹ˆ?¤ìš”.", "?¼ê³ ", "?¼ê³ ??, "?¼ê³  ?©ë‹ˆ??,  ];    function normalizeSpaces(s: string) {    return s.replace(/\s+/g, " ").trim();  }    function splitToTokens(s: string): string[] {    const kept = /[@._\-+!#$/\\]/;    const out: string[] = [];    let cur = "";    const pushCur = () => { if (cur) { out.push(cur); cur = ""; } };      for (const ch of s) {      if (/\s/.test(ch)) { pushCur(); continue; }      if (kept.test(ch)) { pushCur(); out.push(ch); continue; }      if (/[0-9A-Za-z\u3131-\uD79D]/.test(ch)) { cur += ch; }      else { pushCur(); }    }    pushCur();    return out;  }    // ===== ?´ë©”???„ìš© ?¬í¼ =====  // [REPLACE] êµ¬ê°„ ì¶”ì¶œ ?¬í¼  function sliceWindow(tokens: string[], startCues: string[], endCues: string[]) {    const lt = tokens.map(t => t.toLowerCase());    let s = lt.findIndex(t =>      startCues.some(c => t.includes(c)) || t === "@" || t === "ê³¨ë±…??    );    if (s < 0) return null;    let e = tokens.length;    for (let i = s + 1; i < tokens.length; i++) {      const t = lt[i];      // '?…ë‹ˆ??, '?…ë‹ˆ??', '?´ì—?? ???¬í•¨?˜ë©´ ì¢…ë£Œ      if (t.includes("?…ë‹ˆ??) || t.includes("?´ì—??) || t.includes("?ˆìš”") || t.includes("??)) { e = i; break; }      if (endCues.some(c => t.includes(c))) { e = i; break; }    }    return tokens.slice(s, e);  }    function looksLikePhoneDigits(t: string) {    return /^01\d{8,9}$/.test(t); // 01xë¡??œì‘ 10~11?ë¦¬  }  // ??.)?¼ë¡œ ?Šê¸´ ?¤í ë§??°ì„ ë§ˆì?ë§?ê²ƒë§Œ ë½‘ì•„ ë¶™ì´ê¸?+ ?¸ì´ì¦?ì»?  function sanitizeEmailLocal(local: string) {    let s = local.toLowerCase();    // ?„í™” ?¤ì—¼ ?œê±°    s = s.replace(/01\d{6,}[a-z0-9-]*/g, "");    s = s.replace(/(?:^|\.)01\d{6,}[a-z0-9-]*(?=\.|$)/g, "");    // ?ˆìš© ???œê±°    s = s.replace(/[^\w.\-]/g, "");    // ??ê¸°ì? ë¶„í•     let parts = s.split(".").filter(Boolean);    // ?”í•œ ?¸ì´ì¦?ì¡°ê° ?œê±°(amp, jje, mail/gmail ??    const NOISE = new Set(["amp", "jje", "mail", "email", "gmail"]);    parts = parts.filter(p => !NOISE.has(p));    // ?„í™”ì²˜ëŸ¼ ê¸??«ì ?©ì–´ë¦??œê±°    parts = parts.filter(p => !/^\d{6,}$/.test(p));    // --- ?µì‹¬: "?¤í ë§??? ?ì?(??ê¸€??a~z ?ëŠ” ???ë¦¬ ?«ìê°€ '.'ë¡??°ì†??êµ¬ê°„) ---    type Run = { from: number; to: number; items: string[] };    const runs: Run[] = [];    let i = 0;    while (i < parts.length) {      const isSpellish = (x: string) => /^[a-z0-9]$/.test(x);      if (!isSpellish(parts[i])) { i++; continue; }      const start = i;      const arr = [parts[i]];      i++;      while (i < parts.length && isSpellish(parts[i])) { arr.push(parts[i]); i++; }      if (arr.length >= 3) runs.push({ from: start, to: i - 1, items: arr });    }    if (runs.length) {      // ë§ˆì?ë§??¤í ë§??°ì„ ì±„íƒ ??ë§??ë?ë¶„ì„ ? ë¢°      const last = runs[runs.length - 1];      const joined = last.items.join(""); // ?? j.a.e.m.a.n.2.0.3.4 ??jaeman2034      s = joined;    } else {      // ?¤í ë§??°ì´ ?†ìœ¼ë©?ì§§ì? ì¡°ê°??3ê°??´ìƒ?´ë©´ ?©ì¹˜ê¸?jae.man.2034 ??      const allShort = parts.every(p => p.length <= 4);      const hasDigitChunk = parts.some(p => /^\d{2,}$/.test(p));      const alphaCount = parts.filter(p => /^[a-z]+$/.test(p)).length;      s = (parts.length >= 3 && allShort && (hasDigitChunk || alphaCount >= 2))        ? parts.join("")        : parts.join(".");    }    // ?ìª½ TLD/?¡ìŒ ?œê±°(?¤ìˆ˜ë¡??ì¸ com/co/kr ??    s = s.replace(/\.(?:com|net|org|co|kr|jp|uk|edu)$/g, "");    // ë§ˆë¬´ë¦?    s = s.replace(/\.+/g, ".").replace(/^\./, "").replace(/\.$/, "");    if (!s) s = "id";    return s;  }  // ?´ë©”??ìµœì¢… ?•ë¦¬ + ? íš¨??ê²€????ë°˜í™˜  function finalizeEmail(buf: string): string | null {    let b = buf      .replace(/[^\w.@\-]+/g, "") // ?œê? ???œê±°      .replace(/@+/g, "@")      .replace(/\.\.+/g, ".")      .replace(/\.@/g, "@")      .replace(/@\./g, "@");    if (!b.includes("@")) return null;    let [local, domain] = b.split("@");    local = sanitizeEmailLocal(local);    domain = (domain || "")      .replace(/[^\w.\-]/g, "")      .replace(/\.\.+/g, ".")      .replace(/^\./, "")      .replace(/\.$/, "");    const email = `${local}@${domain}`;    const re = /^[A-Za-z0-9._\-]+@[A-Za-z0-9._\-]+\.[A-Za-z]{2,}$/;    return re.test(email) ? email : null;  }      // ===== ?´ë©”???Œì‹±(ê°•í™” ë²„ì „) =====  // ë³´ì¡°: '@' ?´ì „?ì„œ ?„í™” ?„ìƒˆ?˜ëŠ” ?ìˆ«??ì»?  function phoneishAlnumPreAt(t: string) {    return /01\d{5,}/.test(t); // ?? 0105689abc123456  }  // [REPLACE] tokensToEmail (Strict EN/?¼í•© ëª¨ë‘?ì„œ ?¬ìš©)  function tokensToEmail(tokens: string[], mode: ParseMode = "mixed", pick: "first" | "last" = "last"): string | null {    // ?´ë©”??êµ¬ê°„ ???•ì¥: ?ì—°?´ë„ ?¸ì‹    const EMAIL_START = ["?´ë©”??, "ë©”ì¼", "?´ë©”?¼ì£¼??, "ë©”ì¼ì£¼ì†Œ", "email", "eë©”ì¼", "??ë©???];    const EMAIL_END   = ["?„í™”", "?„í™”ë²ˆí˜¸", "ë²ˆí˜¸", "?¸ë“œ??, "?´ë???, "?°ë½ì²?, "ë¹„ë?ë²ˆí˜¸", "ë¹„ë?ë²ˆí˜¸??, "?¨ìŠ¤?Œë“œ", "?”í˜¸"];        const win = sliceWindow(      tokens,      EMAIL_START,      EMAIL_END    );    const list = (win ?? tokens);    let seenAt = false;    const parts: string[] = [];    for (const raw0 of list) {      const raw = filterEmailNoiseToken(raw0);       // ???¡ìŒ ? í° ?œê±°      if (!raw) continue;      const t = raw.toLowerCase();      // ê¸°í˜¸/?¬ì „      if (t === "@" || t === "ê³¨ë±…??) { parts.push("@"); seenAt = true; continue; }      if (t === "." || t === "?? || t === "??) { parts.push("."); continue; }      if (PROVIDER_KO[t]) { if (!seenAt) { parts.push("@"); seenAt = true; } parts.push(PROVIDER_KO[t]); continue; }      if (TLD_KO[t])      { if (seenAt) { if (parts[parts.length-1] !== ".") parts.push("."); parts.push(TLD_KO[t]); } continue; }      if (KO_ALPHA[t])    { parts.push(KO_ALPHA[t]); continue; }      // ëª¨ë“œë³??„í„°      if (mode === "en_strict") {        if (/^[A-Za-z0-9._\-]+$/.test(raw)) parts.push(raw);      } else {        if (/^[A-Za-z0-9._\-]+$/.test(raw)) parts.push(raw);      }    }    const s = parts.join("")      .replace(/\s+/g, "")      .replace(/\.@/g, "@")      .replace(/@\./g, "@")      .replace(/\.\.+/g, ".");    const re = /[A-Za-z0-9._\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}/g;    const matches = Array.from(s.matchAll(re)).map(m => m[0]);    const chosen = matches.length ? (pick === "first" ? matches[0] : matches[matches.length - 1]) : null;    if (!chosen) return null;    let [local, domain] = chosen.split("@");    local = sanitizeEmailLocal(local);    domain = fixEmailDomain(domain);    domain = normalizeDomain(domain);    const email = `${local}@${domain}`;    return /^[A-Za-z0-9._\-]+@[A-Za-z0-9._\-]+\.[A-Za-z]{2,}$/.test(email) ? email : null;  }    // ===== ?„í™”ë²ˆí˜¸ ì²˜ë¦¬(ê¸°ì¡´ ë¡œì§ ? ì?) =====  // ?„í™”ë²ˆí˜¸ êµ¬ê°„ ???•ì¥: ?ì—°?´ë„ ?¸ì‹  // const PHONE_START = ["?„í™”", "?„í™”ë²ˆí˜¸", "ë²ˆí˜¸", "?¸ë“œ??, "?´ë???, "?°ë½ì²?];  function tokensToPhone(tokens: string[]): string | null {    const joined = tokens.join(" ");    const rough = joined      .replace(/[^\u3131-\uD79D0-9\- ]/g, " ")      .replace(/\s+/g, " ")      .trim();      if (!rough) return null;      const parts = rough.split(" ");    let digits = "";    for (const p of parts) {      const t = p.toLowerCase();        if (/^\d+$/.test(t)) { digits += t; continue; }      if (t === "-" || t === "ë¹¼ê¸°" || t === "?˜ì´??) { continue; }        if (KO_NUM[t]) { digits += KO_NUM[t]; continue; }        const expanded = [...t].map(ch => KO_NUM[ch] ?? "").join("");      if (expanded && /^[0-9]+$/.test(expanded)) {        digits += expanded;        continue;      }    }      const m = digits.match(/01\d(\d{7,8})/);    if (!m) return null;      const start = digits.indexOf(m[0]);    const candidate = digits.slice(start, start + m[0].length);    if (candidate.length === 11) {      return `${candidate.slice(0, 3)}-${candidate.slice(3, 7)}-${candidate.slice(7)}`;    }    if (candidate.length === 10) {      return `${candidate.slice(0, 3)}-${candidate.slice(3, 6)}-${candidate.slice(6)}`;    }    return null;  }      // ===== ?´ë¦„ ì²˜ë¦¬(ê°•í™” ë²„ì „) =====  // [REPLACE] ?´ë¦„ ?Œì„œ  function extractName(s: string): { value: string | null; candidates: string[] } {    const clean = s.replace(/\s+/g, " ");    const ignoreExact = new Set([      "?ˆë…•?˜ì„¸??,"?ˆë…•","ê°ì‚¬?©ë‹ˆ??,"ê°ì‚¬",      "?…ë‹ˆ??,"?´ì—??,"?ˆìš”",      "?„í™”ë²ˆí˜¸","?´ë©”??,"ë¹„ë?ë²ˆí˜¸","ë²ˆí˜¸","?„í™”","ë¹„ë²ˆ",      "?€??,"?˜ëŠ”","??,"??,"?´ë¦„?€"    ]);    const isGreeting = (w: string) => /^?ˆë…•??.test(w);    const strip = (w: string) =>      w.replace(/(????$/, "")       .replace(/\s+/g, "")       .replace(/?…ë‹ˆ????s]*$/, "")       .replace(/[.,]+$/, "");    const cands: string[] = [];    const m0 = clean.match(/([ê°€-??{2,6})\s*?…ë‹ˆ??);    if (m0) cands.push(strip(m0[1]));    const m1 = clean.match(/(?:?????\s*?´ë¦„?€\s*([ê°€-??{1,3}\s?[ê°€-??{1,3})(?:?????/);    if (m1) cands.push(strip(m1[1]));    const m2 = clean.match(/(?:?€???˜ëŠ”)\s*([ê°€-??{1,3}\s?[ê°€-??{1,3})(?:?????\s*(?:?…ë‹ˆ???´ì—???ˆìš”|?´ê³ )?/);    if (m2) cands.push(strip(m2[1]));    const all = clean.match(/[ê°€-??{2,7}/g) ?? [];    for (let w of all) {      const sw = strip(w);      if (sw.length >= 2 && sw.length <= 6 && !ignoreExact.has(sw) && !isGreeting(sw)) cands.push(sw);    }    const uniq = Array.from(new Set(cands)).filter(w => !ignoreExact.has(w) && !isGreeting(w));    const best = uniq.length ? uniq[0] : null;    return { value: best, candidates: uniq };  }           // [REPLACE] ë¹„ë?ë²ˆí˜¸ ?Œì„œ: ?¤ì–‘???¤ì¸??cue + êµ¬ë‘??ê³µë°± ?œê±° + ?ë¬¸Â·?«ì ?¬í•¨ ê²€??   function tokensToPassword(     tokens: string[],     mode: ParseMode = "mixed",     opts?: ParseOptions   ): { value: string | null; raw: string } {         // 1) cue(?¤ì›Œ?? ?“ê²Œ ?ˆìš©: 'ë¹?ë°€ ë²???, 'ë¹„ë²ˆ', 'ë¹„ë¹Œë²ˆí˜¸', 'ë¹„ë? ë²ˆí˜¸',     //    ?ë¬¸ 'password', 'pass word', 'pw' ??+ ?ì—°??ë³€??     const joined = tokens.join(" ");     const PASS_CUE = /(ë¹?s*ë°€\s*ë²?s*??ë¹?s*ë³?ë¹?s*ë²?ë¹„ë¹Œë²ˆí˜¸|ë¹„ë?ë²ˆí˜¸|?”í˜¸|?¨ìŠ¤?Œë“œ|password|pass\s*word|pw)/i;    const m = joined.match(PASS_CUE);    if (!m) return { value: null, raw: "" };    // 2) cue ?´í›„ë¶€??ë¬¸ì¥ ê²½ê³„(., ?…ë‹ˆ?? ????ê¹Œì?ë¥?tailë¡?    const start = m.index! + m[0].length;    let tail = joined.slice(start).trim();    const stops = [".", "?…ë‹ˆ??, "??, "?´ì—??, "?ˆìš”", "?„í™”", "?´ë©”??];    let stop = tail.length;    for (const s of stops) {      const i = tail.indexOf(s);      if (i >= 0) stop = Math.min(stop, i);    }    let raw = tail.slice(0, stop).trim();    // 3) ????êµ¬ë‘???•ë¦¬    raw = raw.replace(/^[^\w!@#$%&*._\-\\/+]+/, "").replace(/[^\w!@#$%&*._\-\\/+]+$/, "");    // 4) ? í°??ê²°í•© (Strict EN?´ë©´ ?œê? ?¨ì–´ ë¬´ì‹œ)    const pwTokens = splitToTokens(raw);    let buf = "";    for (const tk of pwTokens) {      const t = tk.toLowerCase();      // ?ˆìš© ê¸°í˜¸/ì¹˜í™˜      if (KO_SYMBOLS[t]) { buf += KO_SYMBOLS[t]; continue; }      if (KO_ALPHA[t])   { buf += KO_ALPHA[t];   continue; }      if (KO_NUM[t])     { buf += KO_NUM[t];     continue; }      // ?ë¬¸/?«ì      if (/^[A-Za-z0-9]+$/.test(tk)) { buf += tk; continue; }      // ê¸°í˜¸ ê·¸ë?ë¡?      if (/[@._\-+!#$%&*\/\\]/.test(tk)) { buf += tk; continue; }      // Strict EN ëª¨ë“œ?ì„  ?œê?/ê¸°í? ë²„ë¦¼      if (mode === "en_strict") continue;    }         // 5) ìµœì¢… ?•í™”: êµ¬ë¶„??êµ¬ë‘??ê³µë°± ?œê±° ??"Abc. 1234567" => "Abc1234567"     buf = buf.replace(/[.\s,Â·:;]+/g, "");     // ???¬ì •???µì…˜ ?ìš©     buf = reorderPassword(buf, opts?.passwordOrder ?? "as_spoken");     // 6) ê²€ì¦? 8???´ìƒ + ?ë¬¸/?«ìê°?1ê°??´ìƒ ?¬í•¨     const hasLetter = /[A-Za-z]/.test(buf);     const hasDigit  = /\d/.test(buf);     const value = buf.length >= 8 && hasLetter && hasDigit ? buf : null;     return { value, raw };}// ??NEW: ë¹„ë?ë²ˆí˜¸ ?¬ì •???„ìš°ë¯?function reorderPassword(buf: string, order: "as_spoken"|"letters_first"|"digits_first") {  if (order === "as_spoken") return buf;  const letters = buf.replace(/[^A-Za-z]/g, "");  const digits  = buf.replace(/[^0-9]/g, "");  const symbols = buf.replace(/[A-Za-z0-9]/g, ""); // ê¸°í˜¸??ë§??¤ë¡œ  if (order === "letters_first") return letters + digits + symbols;  if (order === "digits_first")  return digits + letters + symbols;  return buf;}    // ===== ?Œì‹± fallback ì¶”ê? =====// ?ë¬¸ ?¸ë¼?¸ì—???´ë©”??ë³µêµ¬(???„ì–´?°ê¸° ?ì—¬??function fallbackEmailFromRaw(s: string): string | null {  let t = s.toLowerCase();  // ?œêµ­???ì–´ ?¨ì„œ ì¹˜í™˜  t = t.replace(/ê³¨ë±…??at/gi, "@");  t = t.replace(/????dot/gi, ".");  // ê¸°í˜¸ ì£¼ìœ„ ê³µë°± ?•ë¦¬  t = t.replace(/@\s+/g, "@")       .replace(/\s+\./g, ".")       .replace(/(\w)\s+\.(?=\w)/g, "$1.")       .replace(/\.{2,}/g, ".");  // ?´ë©”???´ì™¸ ë¬¸ì ì¶•ì†Œ  t = t.replace(/[^\w@.\-]+/g, " ");  const re = /[a-z0-9._\-]+@[a-z0-9.\-]+\.[a-z]{2,}/i;  const m = t.match(re);  return m ? m[0] : null;}// ====== ?Œì„œ ë³´ê°• ?¨ìˆ˜??======// 1) ?´ë©”?? @ ???œê? ?«ì/?¡ìŒ ?•ë¦¬export function normalizeEmail(raw: string) {  const koNum: Record<string,string> = { ê³?"0",??"0",??"1",??"2",??"3",??"4",??"5",??"6",ì¹?"7",??"8",êµ?"9" };  const m = raw.match(/([A-Za-z0-9._%+\- ]+)\s*([ê³µì˜?¼ì´?¼ì‚¬?¤ìœ¡ì¹ íŒ”êµ?)?\s*@\s*([A-Za-z0-9.\-]+)\s*\.\s*([A-Za-z]{2,})/i);  if (!m) return null;  const local = m[1].replace(/[ \.]/g, "").toLowerCase();  const hangul = m[2] ? (koNum[m[2]] ?? "") : "";  const domain = (m[3] + "." + m[4]).replace(/\s+/g, "").toLowerCase();  // ?œê? ?«ìê°€ ?ˆë”?¼ë„, ì§ì „???«ì???Œë§Œ 1?ë¦¬ ?«ìë¡?ì±„íƒ(ê·??¸ëŠ” ?¡ìŒ?¼ë¡œ ë¬´ì‹œ)  const local2 = /\d$/.test(local) ? local + hangul : local;  return `${local2}@${domain}`;}// 2) ?„í™”: ?œêµ­???«ì ?ì„ ?ˆìš© + ?©ì–´ë¦??©ì¹˜ê¸?export function extractPhone(raw: string) {  const rep = (s: string) => s    .replace(/ê³?g,"0").replace(/??g,"0")    .replace(/??g,"1").replace(/??g,"2").replace(/??g,"3").replace(/??g,"4")    .replace(/??g,"5").replace(/??g,"6").replace(/ì¹?g,"7").replace(/??g,"8").replace(/êµ?g,"9")    .replace(/[^\d]/g,"");  const digits = rep(raw);  const m = digits.match(/01[016789]\d{7,8}/); // 10~11?ë¦¬ë§?  if (!m) return "";  const d = m[0];  return d.length === 10 ? `${d.slice(0,3)}-${d.slice(3,6)}-${d.slice(6)}`                         : `${d.slice(0,3)}-${d.slice(3,7)}-${d.slice(7)}`;}// 3) ë¹„ë?ë²ˆí˜¸: ì² ì ?¨ìœ„(A. B. C.), ?œê? ì² ìëª? ?¡ìŒ ?œê±° ??ê²°í•©export function extractPassword(raw: string) {  // ë¹„ë²ˆ êµ¬ê°„ë§??˜ë¼?¤ê¸°(ê°€??ë§ˆì?ë§?"ë¹„ë?ë²ˆí˜¸" ?´í›„ 80??  const mm = raw.match(/(ë¹?s*ë°€\s*ë²?s*??ë¹?s*ë²??”í˜¸|password)[^A-Za-z0-9ê°€-??{0,10}([\s\S]{0,80})$/i);  if (!mm) return { value:"", status:"missing" };  let s = mm[2];  // ?¡ìŒ ?œê±°  s = s.replace(/?¤ì‹œ ë§í• ê²?ëª??Œì•„???ì–´|?ŒíŒŒë²?ê·¸ë˜|?¼ë³¸???…ë‹ˆ????./g, " ");  // ?œê? ì² ìëª????ë¬¸  const koLetter: Record<string,string> = { ?ì´:"A", ë¹?"B", ??"C", ??"D", ??"E", ?í”„:"F", ì§€:"G", ?ì´ì¹?"H", ?ì·¨:"H", ?„ì´:"I", ?œì´:"J", ì¼€??"K", ??"L", ??"M", ??"N", ??"O", ??"P", ??"Q", ??"R", ?ìŠ¤:"S", ??"T", ??"U", ë¸Œì´:"V", ?”ë¸”??"W", ?‘ìŠ¤:"X", ?€??"Y", ì§€??"Z" };  s = s.replace(new RegExp(Object.keys(koLetter).join("|"),"g"), (m)=>koLetter[m]);  // A. B. C. / A B C / Abc. ?•íƒœ ëª¨ë‘ ?˜ìš©  s = s.replace(/\./g," ").replace(/\s+/g," ");  s = s.replace(/[^A-Za-z0-9!@#$%^&*_\-+= ]/g,"");  const letters = s.match(/[A-Za-z0-9!@#$%^&*_\-+=]+/g) || [];  const joined = letters.join("");  if (joined.length >= 8) return { value: joined, status: "ok" };  if (joined.length >= 6) return { value: joined, status: "weak" };  return { value:"", status:"missing" };}// ===== ë©”ì¸ ?”íŠ¸ë¦?=====export function parseSignupFromText(    input: string,    optOrDebug?: boolean | ParseOptions,    debugMaybe?: boolean  ): ParsedSignup {    // ê¸°ì¡´ ?¸ì¶œ(parseSignupFromText(text, true)) ?¸í™˜    let opts: ParseOptions = { emailMode: "mixed", passwordMode: "mixed", emailPick: "last" };    let withDebug = false;    if (typeof optOrDebug === "boolean") withDebug = optOrDebug;    else if (typeof optOrDebug === "object" && optOrDebug) {      opts = { ...opts, ...optOrDebug };      withDebug = !!debugMaybe;    }    const pre = normalizeSpaces(      input        .replace(/\u200B/g, "")        .replace(/[?œâ€?']/g, " ")    );    const tokens = splitToTokens(pre);    let email = tokensToEmail(tokens, opts.emailMode!, opts.emailPick!);    if (!email) email = fallbackEmailFromRaw(pre);  // ??ì¶”ê?    const phone = tokensToPhone(tokens);    const { value: name, candidates: nameCandidates } = extractName(pre);         const pw = tokensToPassword(tokens, opts.passwordMode!, opts);    const out: ParsedSignup = {      name: name ?? null,      email: email ?? null,      phone: phone ?? null,      password: pw.value ?? null,    };    if (withDebug) out.debug = { emailRaw: email ?? "", phoneRaw: phone ?? "", nameCandidates, passwordRaw: pw.raw, tokens };    return out;  }    // ===== Node?ì„œ ë¹ ë¥¸ ?˜ë™ ?ŒìŠ¤???µì…˜) =====  if (typeof window === "undefined") {    const sample1 = "?€???´ì¬ë§Œì´ê³??´ë©”?¼ì? j a e m a n 2 0 3 4 ê³¨ë±…??ì§€ë©”ì¼ ??ì»??…ë‹ˆ?? ?„í™”ë²ˆí˜¸??ê³µì¼ê³??”íŒ”??êµ¬êµ¬êµ¬êµ¬. ë¹„ë?ë²ˆí˜¸??a 1 2 3 4 5 6 7.";    const sample2 = "???´ë¦„?€ ë°•ì„ ?? ?´ë©”?¼ì? id ê³¨ë±…???¤ì´ë²???ì»? ë²ˆí˜¸??010 1234 5678, ë¹„ë?ë²ˆí˜¸??qwer!234.";    console.log(parseSignupFromText(sample1, true));    console.log(parseSignupFromText(sample2, true));  }  