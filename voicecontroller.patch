diff --git a/src/components/VoiceController.tsx b/src/components/VoiceController.tsx
index 0000000..1234567 100644
--- a/src/components/VoiceController.tsx
+++ b/src/components/VoiceController.tsx
@@ -0,0 +1,108 @@
+import React, { useEffect, useRef, useState } from 'react';
+
+type Intent =
+  | { type: 'OPEN_CREATE' }
+  | { type: 'FILTER_NEARBY'; km: number }
+  | { type: 'FILTER_PRICE_MAX'; max: number }
+  | { type: 'OPEN_DETAIL'; index: number }
+  | { type: 'ANALYZE_CURRENT' }
+  | { type: 'NEXT_PAGE' }
+  | { type: 'PREV_PAGE' }
+  | { type: 'SEARCH'; query: string };
+
+type Props = { onIntent: (intent: Intent) => void; tts?: boolean; };
+
+const SpeechRecognition =
+  (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
+
+export default function VoiceController({ onIntent, tts = true }: Props) {
+  const [active, setActive] = useState(false);
+  const [lastTranscript, setLastTranscript] = useState('');
+  const recRef = useRef<any>(null);
+
+  const speak = (text: string) => {
+    if (!tts) return;
+    const u = new SpeechSynthesisUtterance(text);
+    u.lang = 'ko-KR';
+    window.speechSynthesis.speak(u);
+  };
+
+  useEffect(() => {
+    if (!SpeechRecognition) return;
+    const rec = new SpeechRecognition();
+    rec.lang = 'ko-KR';
+    rec.interimResults = false;
+    rec.maxAlternatives = 1;
+
+    rec.onresult = (e: any) => {
+      const transcript = e.results[0][0].transcript.trim();
+      setLastTranscript(transcript);
+      const intent = parseIntent(transcript);
+      if (intent) {
+        onIntent(intent);
+        feedback(intent, speak);
+      } else {
+        speak(`ì£„ì†¡í•´ìš”. ì´í•´í•˜ì§€ ëª»í–ˆì–´ìš”: ${transcript}`);
+      }
+    };
+    rec.onerror = () => setActive(false);
+    rec.onend = () => setActive(false);
+
+    recRef.current = rec;
+  }, [onIntent]);
+
+  const onToggle = () => {
+    if (!recRef.current) return;
+    if (active) {
+      recRef.current.stop();
+      setActive(false);
+    } else {
+      recRef.current.start();
+      setActive(true);
+      speak('ë“£ê³  ìˆì–´ìš”.');
+    }
+  };
+
+  return (
+    <div className="fixed right-4 bottom-5 z-40">
+      <button
+        onClick={onToggle}
+        className={`rounded-full shadow-lg px-5 py-4 text-white transition ${
+          active ? 'bg-red-500 animate-pulse' : 'bg-indigo-600 hover:bg-indigo-700'
+        }`}
+        aria-pressed={active}
+        aria-label="ìŒì„± ì œì–´"
+      >
+        ğŸ™ï¸ {active ? 'ë„ê¸°' : 'ë§í•˜ê¸°'}
+      </button>
+      {lastTranscript && (
+        <div className="mt-2 text-xs text-gray-600 bg-white/80 backdrop-blur rounded px-2 py-1 shadow">
+          "{lastTranscript}"
+        </div>
+      )}
+    </div>
+  );
+}
+
+function feedback(intent: Intent, speak: (t:string)=>void) {
+  switch (intent.type) {
+    case 'OPEN_CREATE': speak('ìƒí’ˆ ë“±ë¡ í™”ë©´ì„ ì—´ê²Œìš”.'); break;
+    case 'FILTER_NEARBY': speak(`${intent.km}í‚¬ë¡œ ì´ë‚´ë¡œ í•„í„°ë§í–ˆì–´ìš”.`); break;
+    case 'FILTER_PRICE_MAX': speak(`ìµœëŒ€ ${intent.max}ì›ìœ¼ë¡œ ì œí•œí–ˆì–´ìš”.`); break;
+    case 'OPEN_DETAIL': speak(`${intent.index}ë²ˆ ìƒì„¸ë¥¼ ì—´ê²Œìš”.`); break;
+    case 'ANALYZE_CURRENT': speak('AI ë¶„ì„ì„ ì‹œì‘í• ê²Œìš”.'); break;
+    case 'NEXT_PAGE': speak('ë‹¤ìŒìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.'); break;
+    case 'PREV_PAGE': speak('ì´ì „ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.'); break;
+    case 'SEARCH': speak(`${intent.query}ë¡œ ê²€ìƒ‰í–ˆì–´ìš”.`); break;
+  }
+}
+
+function parseIntent(t: string): Intent | null {
+  const s = t.replace(/\s+/g, '');
+
+  if (s.includes('ìƒí’ˆë“±ë¡')) return { type: 'OPEN_CREATE' };
+  if (s.includes('ë‹¤ìŒ')) return { type: 'NEXT_PAGE' };
+  if (s.includes('ì´ì „')) return { type: 'PREV_PAGE' };
+  if (s.includes('ë¶„ì„')) return { type: 'ANALYZE_CURRENT' };
+
+  const mKm = s.match(/(\d+)\s*í‚¬?ë¡œ/);
+  if (mKm) return { type: 'FILTER_NEARBY', km: Number(mKm[1]) };
+
+  const mWon = s.match(/(\d+)\s*(ì›|ë§Œì›)/);
+  if (mWon && s.includes('ì´í•˜')) {
+    const num = Number(mWon[1]) * (s.includes('ë§Œì›') ? 10000 : 1);
+    return { type: 'FILTER_PRICE_MAX', max: num };
+  }
+
+  const mDetail = s.match(/(\d+)\s*ë²ˆ(ìƒì„¸|ì—´ì–´ì¤˜|ë³´ê¸°)/);
+  if (mDetail) return { type: 'OPEN_DETAIL', index: Number(mDetail[1]) };
+
+  if (t.length >= 2) return { type: 'SEARCH', query: t };
+  return null;
+}
